
//           Copyright Nathaniel Christen 2020.
//  Distributed under the Boost Software License, Version 1.0.
//     (See accompanying file LICENSE_1_0.txt or copy at
//           http://www.boost.org/LICENSE_1_0.txt)


#include <QDebug>

#include <QDirIterator>

#include "test-class.h"

#include "unified-runtime-object.h"

#include "metatype-object.h"

#include "textio.h"
USING_KANS(TextIO)


int main1(int argc, char *argv[])
{
 Unified_Runtime_Object& uro = *Unified_Runtime_Object::instance();
 uro.register_new_metatype_object("Test_Class");

 Test_Class tc("OK");
 qDebug() << tc.text();


 Metatype_Object& mto = *uro.get_metetype_object_by_type_name("Test_Class");

 mto.register_guard_fn("test_method@enter", [](QVector<n8> args) -> n8
 {
  QString& arg0 = *(QString*)args[0];
  u4& arg1 = *(u4*)args[1];
  u4& arg2 = *(u4*)args[2];
  return 0;
 });

// mto

 tc.test_method(ROOT_FOLDER "/dev/extra", 79, 81);
 tc.test_cuo();
 return 0;
}

void get_section_files(QString paper_name, QMap<QString, QString>& result)
{
 QString folder = ROOT_FOLDER "/../dev/documents/" + paper_name + "/src";

 QDirIterator qdi(folder, {"*.gt"});
 while(qdi.hasNext())
 {
  qdi.next();
  QString fp = qdi.filePath();
  QFileInfo qfi(fp);
  if(qfi.fileName().startsWith("section"))
  {
   QString tail;
   if(qfi.fileName().length() == 12)
     tail = qfi.fileName().mid(8, 1);
   int sectno = qfi.fileName().midRef(7, 1).toInt();
   result[QString("%1-%2%3").arg(paper_name).arg(sectno).arg(tail)] = fp;
  }
 }

}

void get_source_files(QString paper_name, QMap<QString, QStringList>& result)
{
 QString folder = ROOT_FOLDER "/../dev/documents/" + paper_name + "/src";

 QDirIterator qdi(folder, {"*.gt", "*.tex"});
 while(qdi.hasNext())
 {
  qdi.next();
  QString fp = qdi.filePath();
  QFileInfo qfi(fp);
  if(qfi.completeSuffix() == "gt.tex")
    continue;
  if(qfi.completeSuffix() == "prep.tex")
    continue;
  result[paper_name].push_back(fp);
 }
}


void generate_swl()
{
 // //  Pull all the `swl tag-commands

 QMap<QString, QString> files;

 get_section_files("ctg", files);
 get_section_files("icg", files);
 get_section_files("itm", files);

 qDebug() << files;


 QMap<QString, QStringList> source_files;

 get_source_files("ctg", source_files);
 get_source_files("icg", source_files);
 get_source_files("itm", source_files);

 QString src_copy_folder = ROOT_FOLDER "/../dev";
 QDir scdir(src_copy_folder);
 if(!scdir.exists("src-copy"))
   scdir.mkdir("src-copy");
 scdir.cd("src-copy");
 QMapIterator<QString, QStringList> sfit(source_files);
 while(sfit.hasNext())
 {
  sfit.next();
  QString pn = sfit.key();
  if(!scdir.exists(pn))
    scdir.mkdir(pn);
  scdir.cd(pn);
  if(!scdir.exists("src"))
    scdir.mkdir("src");
  scdir.cd("src");
  for(QString sf : sfit.value())
  {
   copy_binary_file_to_folder(sf, scdir.absolutePath());
  }
  scdir.cdUp();
  scdir.cdUp();
 }

 QString all_swl = R"(
;;--

  This file is automatically generated by extracting
  all "swl" and "udref" tag-commands from each .gt
  file used to generate the essays from which the
  data set is compiled.  The main purpose of this
  file is to document notation for different facets
  of language-sample annotations and metadata.

  While the GTagML compiler can parse this file
  and produce TeX output, the resulting code
  by itself would not be able to generate
  a usable PDF file (for example).

--;;
)";

 QMapIterator<QString, QString> it(files);

 while(it.hasNext())
 {
  it.next();

  QString sect = it.key();
  sect.replace("-", " (section ");
  sect += ")";

  all_swl += "\n\n ;;- __________ \n ;;- From file: " + sect + "\n ;;- __________ \n\n";

  QString text = load_file(it.value());

  int index = 0;
  int last = 0;
  int udr = 0;
  while(last != -1)
  {
   index = text.indexOf("`swl", last);
   if(index == -1)
     break;
   last = text.indexOf(";;", index);

   QString swl = text.mid(index, last - index + 3);

   // // now look for a udref
   udr = text.indexOf("`udref", last);
   if(udr != -1)
   {
    // // 10 here is a rough number, just want to be
     //   sure only to match a udref immediately after
     //   the relevant swl ...
    if(udr < last + 10)
    {
     last = text.indexOf(";;", udr);
     if(!swl.endsWith("\n"))
       swl += "\n";
     swl += text.mid(udr, last - udr + 3);
    }
   }

   if(!swl.endsWith("\n"))
     all_swl += "\n";

   all_swl += "\n" + swl;
  }
 }

 save_file(ROOT_FOLDER "/documents/all-samples.gt", all_swl);
}

void merge_markdown_samples(QStringList paper_names, QString out_name)
{
 QString markdown_folder = ROOT_FOLDER "/documents/markdown";
 QString all_text;
 for(QString pn : paper_names)
 {
  all_text += load_file(markdown_folder + "/" + pn + ".md");
 }

 backup_binary_file(markdown_folder + "/" + out_name + ".md");
 save_file(markdown_folder + "/" + out_name + ".md", all_text);
}

void copy_and_backup(QString paper_name, QString full_name)
{
 QString out_folder = ROOT_FOLDER "/../dev/documents/" + paper_name + "/out";
 QString dataset_folder = ROOT_FOLDER "/data/dataset/" + paper_name;

 QString documents_folder = ROOT_FOLDER "/documents";

 QDir qd(dataset_folder);
 if(!qd.exists("dryad"))
   qd.mkdir("dryad");

 qd.cd("dryad");

 QString dryad_folder = qd.absolutePath();

 backup_binary_file(dataset_folder + "/samples.ntxh");
 backup_binary_file(dryad_folder + QString("/samples-%1.ntxh").arg(paper_name));

 copy_binary_file_to_folder_with_rename(out_folder + "/" + paper_name + ".ntxh",
   dataset_folder, "samples");
 copy_binary_file_to_folder_with_rename(out_folder + "/" + paper_name + ".ntxh",
   dryad_folder, QString("samples-%1").arg(paper_name));

 backup_binary_file(dataset_folder + "/sdi-merge.ntxh");
 backup_binary_file(dryad_folder + QString("/sdi-merge-%1.ntxh").arg(paper_name));

 copy_binary_file_to_folder_with_rename(out_folder + "/../sdi-merge.ntxh",
   dataset_folder, "sdi-merge");
 copy_binary_file_to_folder_with_rename(out_folder + "/../sdi-merge.ntxh",
   dryad_folder, QString("sdi-merge-%1").arg(paper_name));

 backup_binary_file(dataset_folder + "/main.pdf");
 copy_binary_file_to_folder_with_rename(out_folder + "/" + paper_name + ".pdf",
   dataset_folder, "main");

 copy_binary_file_to_folder_with_rename(out_folder + "/" + paper_name + ".pdf",
   documents_folder, full_name);
}

// // a handful of utilities for finalizing the data set ...
int main(int argc, char *argv[])
{
 generate_swl();

 copy_and_backup("ctg", "CognitiveTransformGrammar");
 copy_and_backup("icg", "ConceptualSpacesAndTheIntroToCognitiveGrammar");
 copy_and_backup("itm", "InterfaceTheoryOfMeaning");

 merge_markdown_samples({"ctg", "icg", "itm"}, "samples");
}



