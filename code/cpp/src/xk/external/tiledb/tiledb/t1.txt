./sm/array_schema/array_schema.cc:#include "tiledb/sm/enums/compressor.h"
./sm/array_schema/array_schema.cc:#include "tiledb/sm/filter/compression_filter.h"
./sm/array_schema/array_schema.cc:      constants::coords_compression, constants::coords_compression_level));
./sm/array_schema/array_schema.cc:      constants::cell_var_offsets_compression,
./sm/array_schema/array_schema.cc:      constants::cell_var_offsets_compression_level));
./sm/array_schema/array_schema.cc:  RETURN_NOT_OK(check_double_delta_compressor());
./sm/array_schema/array_schema.cc:Status ArraySchema::check_double_delta_compressor() const {
./sm/array_schema/array_schema.cc:  // Check if coordinate filters have DOUBLE DELTA as a compressor
./sm/array_schema/array_schema.cc:                                   "filters with DOUBLE DELTA compression"));
./sm/array_schema/array_schema.h:   * Returns error if double delta compression is used in the zipped
./sm/array_schema/array_schema.h:  Status check_double_delta_compressor() const;
./sm/array_schema/attribute.cc:#include "tiledb/sm/enums/compressor.h"
./sm/array_schema/attribute.cc:#include "tiledb/sm/filter/compression_filter.h"
./sm/compressors/bzip_compressor.cc: * @file   bzip_compressor.cc
./sm/compressors/bzip_compressor.cc: * This file implements the bzip compressor class.
./sm/compressors/bzip_compressor.cc:#include "tiledb/sm/compressors/bzip_compressor.h"
./sm/compressors/bzip_compressor.cc:Status BZip::compress(
./sm/compressors/bzip_compressor.cc:        "Failed compressing with BZip; invalid buffer format"));
./sm/compressors/bzip_compressor.cc:            "BZip compression error: library has been miscompiled");
./sm/compressors/bzip_compressor.cc:            "BZip compression error: 'output_buffer' or 'output_buffer_size' "
./sm/compressors/bzip_compressor.cc:            "BZip compression error: insufficient memory");
./sm/compressors/bzip_compressor.cc:            "BZip compression error: compressed size exceeds limits for "
./sm/compressors/bzip_compressor.cc:            "BZip compression error: unknown error code");
./sm/compressors/bzip_compressor.cc:  // Set size of compressed data
./sm/compressors/bzip_compressor.cc:Status BZip::decompress(
./sm/compressors/bzip_compressor.cc:        "Failed decompressing with BZip; invalid buffer format"));
./sm/compressors/bzip_compressor.cc:  // Decompress
./sm/compressors/bzip_compressor.cc:  int rc = BZ2_bzBuffToBuffDecompress(
./sm/compressors/bzip_compressor.cc:            "BZip decompression error: library has been miscompiled");
./sm/compressors/bzip_compressor.cc:            "BZip decompression error: 'output_buffer' or 'output_buffer_size' "
./sm/compressors/bzip_compressor.cc:            "BZip decompression error: insufficient memory");
./sm/compressors/bzip_compressor.cc:            "BZip decompression error: compressed data is corrupted");
./sm/compressors/bzip_compressor.cc:            "BZip decompression error: unknown error code ");
./sm/compressors/bzip_compressor.cc:  // Set size of compressed data
./sm/compressors/bzip_compressor.cc:  // To guarantee that the compressed data will fit in its buffer, allocate an
./sm/compressors/bzip_compressor.cc:  // output buffer of size 1% larger than the uncompressed data, plus six
./sm/compressors/bzip_compressor.h: * @file   bzip_compressor.h
./sm/compressors/bzip_compressor.h: * This file defines the bzip compressor class.
./sm/compressors/bzip_compressor.h:/** Handles compression/decompression with the bzip2 library. */
./sm/compressors/bzip_compressor.h:   * @param output_buffer Output buffer to write to the compressed data.
./sm/compressors/bzip_compressor.h:  static Status compress(
./sm/compressors/bzip_compressor.h:   * Decompression function.
./sm/compressors/bzip_compressor.h:   * @param output_buffer Output buffer to write the decompressed data to.
./sm/compressors/bzip_compressor.h:  static Status decompress(
./sm/compressors/bzip_compressor.h:  /** Returns the default compression level. */
./sm/compressors/bzip_compressor.h:  /** Returns the compression overhead for the given input. */
./sm/compressors/dd_compressor.cc: * @file   dd_compressor.cc
./sm/compressors/dd_compressor.cc: * This file implements the double delta compressor class.
./sm/compressors/dd_compressor.cc:#include "tiledb/sm/compressors/dd_compressor.h"
./sm/compressors/dd_compressor.cc:Status DoubleDelta::compress(
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<int8_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<uint8_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<int16_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<uint16_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<int>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<uint32_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<int64_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<uint64_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<char>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<int64_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::compress<uint8_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:          "Cannot compress tile with DoubleDelta; Float "
./sm/compressors/dd_compressor.cc:      "Cannot compress tile with DoubleDelta; Not supported datatype"));
./sm/compressors/dd_compressor.cc:Status DoubleDelta::decompress(
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<int8_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<uint8_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<int16_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<uint16_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<int>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<uint32_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<int64_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<uint64_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<char>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<int64_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:      return DoubleDelta::decompress<uint8_t>(input_buffer, output_buffer);
./sm/compressors/dd_compressor.cc:          "Cannot decompress tile with DoubleDelta; Float "
./sm/compressors/dd_compressor.cc:      "Cannot decompress tile with DoubleDelta; Not supported datatype"));
./sm/compressors/dd_compressor.cc:Status DoubleDelta::compress(ConstBuffer* input_buffer, Buffer* output_buffer) {
./sm/compressors/dd_compressor.cc:  // Trivial case - no compression
./sm/compressors/dd_compressor.cc:        Status::CompressionError("Cannot compress with DoubleDelta; Some "
./sm/compressors/dd_compressor.cc:Status DoubleDelta::decompress(
./sm/compressors/dd_compressor.cc:  // Trivial case - no compression
./sm/compressors/dd_compressor.cc:  // Decompress rest of the values
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<char>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<int8_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<uint8_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<int16_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<uint16_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<int>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<uint32_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<int64_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::compress<uint64_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<char>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<int8_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<uint8_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<int16_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<uint16_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<int>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<uint32_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<int64_t>(
./sm/compressors/dd_compressor.cc:template Status DoubleDelta::decompress<uint64_t>(
./sm/compressors/dd_compressor.h: * @file   dd_compressor.h
./sm/compressors/dd_compressor.h: * This file defines the double delta compressor class.
./sm/compressors/dd_compressor.h:/** Implements a double delta compressor. */
./sm/compressors/dd_compressor.h:   * The output buffer will contain the following after compression:
./sm/compressors/dd_compressor.h:   *  the sign), then it does not make sense to compress and, thus, the
./sm/compressors/dd_compressor.h:   * @param output_buffer Output buffer to write to the compressed data.
./sm/compressors/dd_compressor.h:  static Status compress(
./sm/compressors/dd_compressor.h:   * Decompression function.
./sm/compressors/dd_compressor.h:   * @param type The type of the original decompressed values.
./sm/compressors/dd_compressor.h:   * @param output_buffer Output buffer to write the decompressed data to.
./sm/compressors/dd_compressor.h:  static Status decompress(
./sm/compressors/dd_compressor.h:  /** Returns the compression overhead for the given input. */
./sm/compressors/dd_compressor.h:  /** Templated version of *compress* on the type of buffer values. */
./sm/compressors/dd_compressor.h:  static Status compress(ConstBuffer* input_buffer, Buffer* output_buffer);
./sm/compressors/dd_compressor.h:   * Decompression function.
./sm/compressors/dd_compressor.h:   * @param output_buffer Output buffer to write the decompressed data to.
./sm/compressors/dd_compressor.h:  static Status decompress(
./sm/compressors/dd_compressor.h:   * Reads/reconstructs a double delta value from a compressed buffer.
./sm/compressors/dd_compressor.h:   * @param bitsize The bitsize of the double delta compression.
./sm/compressors/gzip_compressor.cc: * @file   gzip_compressor.cc
./sm/compressors/gzip_compressor.cc: * This file implements the gzip compressor class.
./sm/compressors/gzip_compressor.cc:#include "tiledb/sm/compressors/gzip_compressor.h"
./sm/compressors/gzip_compressor.cc:Status GZip::compress(
./sm/compressors/gzip_compressor.cc:        "Failed compressing with GZip; invalid buffer format"));
./sm/compressors/gzip_compressor.cc:    return LOG_STATUS(Status::GZipError("Cannot compress with GZIP"));
./sm/compressors/gzip_compressor.cc:    return LOG_STATUS(Status::GZipError("Cannot compress with GZIP"));
./sm/compressors/gzip_compressor.cc:  // Set size of compressed data
./sm/compressors/gzip_compressor.cc:  uint64_t compressed_size = output_buffer->free_space() - strm.avail_out;
./sm/compressors/gzip_compressor.cc:  output_buffer->advance_size(compressed_size);
./sm/compressors/gzip_compressor.cc:  output_buffer->advance_offset(compressed_size);
./sm/compressors/gzip_compressor.cc:Status GZip::decompress(
./sm/compressors/gzip_compressor.cc:        "Failed decompressing with GZip; invalid buffer format"));
./sm/compressors/gzip_compressor.cc:    return LOG_STATUS(Status::GZipError("Cannot decompress with GZIP"));
./sm/compressors/gzip_compressor.cc:  // Decompress
./sm/compressors/gzip_compressor.cc:        Status::GZipError("Cannot decompress with GZIP, Stream Error"));
./sm/compressors/gzip_compressor.cc:  // Set size of decompressed data
./sm/compressors/gzip_compressor.cc:  uint64_t compressed_size = output_buffer->free_space() - strm.avail_out;
./sm/compressors/gzip_compressor.cc:  output_buffer->advance_offset(compressed_size);
./sm/compressors/gzip_compressor.h: * @file   gzip_compressor.h
./sm/compressors/gzip_compressor.h: * This file defines the gzip compressor class.
./sm/compressors/gzip_compressor.h:/** Handles compression/decompression with the zlib (gzip) library. */
./sm/compressors/gzip_compressor.h:   * @param output_buffer Output buffer to write to the compressed data.
./sm/compressors/gzip_compressor.h:  static Status compress(
./sm/compressors/gzip_compressor.h:   * Decompression function.
./sm/compressors/gzip_compressor.h:   * @param output_buffer Output buffer to write the decompressed data to.
./sm/compressors/gzip_compressor.h:  static Status decompress(
./sm/compressors/gzip_compressor.h:  /** Returns the compression overhead for the given input. */
./sm/compressors/gzip_compressor.h:  /** Returns the default compression level. */
./sm/compressors/lz4_compressor.cc: * @file   lz4_compressor.cc
./sm/compressors/lz4_compressor.cc: * This file implements the lz4 compressor class.
./sm/compressors/lz4_compressor.cc:#include "tiledb/sm/compressors/lz4_compressor.h"
./sm/compressors/lz4_compressor.cc:Status LZ4::compress(
./sm/compressors/lz4_compressor.cc:        "Failed compressing with LZ4; invalid buffer format"));
./sm/compressors/lz4_compressor.cc:  int ret = LZ4_compress_default(
./sm/compressors/lz4_compressor.cc:  int ret = LZ4_compress(
./sm/compressors/lz4_compressor.cc:    return Status::CompressionError("LZ4 compression failed");
./sm/compressors/lz4_compressor.cc:  // Set size of compressed data
./sm/compressors/lz4_compressor.cc:Status LZ4::decompress(
./sm/compressors/lz4_compressor.cc:        "Failed decompressing with LZ4; invalid buffer format"));
./sm/compressors/lz4_compressor.cc:  // Decompress
./sm/compressors/lz4_compressor.cc:  int ret = LZ4_decompress_safe(
./sm/compressors/lz4_compressor.cc:    return Status::CompressionError("LZ4 decompression failed");
./sm/compressors/lz4_compressor.cc:  // Set size of decompressed data
./sm/compressors/lz4_compressor.cc:      static_cast<uint64_t>(LZ4_compressBound((int)ceil(nbytes / 2.0)));
./sm/compressors/lz4_compressor.h: * @file   lz4_compressor.h
./sm/compressors/lz4_compressor.h: * This file defines the lz4 compressor class.
./sm/compressors/lz4_compressor.h:/** Handles compression/decompression with the lz4 library. */
./sm/compressors/lz4_compressor.h:   * @param output_buffer Output buffer to write to the compressed data.
./sm/compressors/lz4_compressor.h:  static Status compress(
./sm/compressors/lz4_compressor.h:   * Decompression function.
./sm/compressors/lz4_compressor.h:   * @param output_buffer Output buffer to write the decompressed data to.
./sm/compressors/lz4_compressor.h:  static Status decompress(
./sm/compressors/lz4_compressor.h:  /** Returns the default compression level. */
./sm/compressors/lz4_compressor.h:  /** Returns the compression overhead for the given input. */
./sm/compressors/rle_compressor.cc: * @file   rle_compressor.cc
./sm/compressors/rle_compressor.cc: * This file implements the rle compressor class.
./sm/compressors/rle_compressor.cc:#include "tiledb/sm/compressors/rle_compressor.h"
./sm/compressors/rle_compressor.cc:Status RLE::compress(
./sm/compressors/rle_compressor.cc:        "Failed compressing with RLE; null input buffer"));
./sm/compressors/rle_compressor.cc:        "Failed compressing with RLE; invalid input buffer format"));
./sm/compressors/rle_compressor.cc:Status RLE::decompress(
./sm/compressors/rle_compressor.cc:        "Failed decompressing with RLE; null input buffer"));
./sm/compressors/rle_compressor.cc:        "Failed decompressing with RLE; invalid input buffer format"));
./sm/compressors/rle_compressor.cc:  // Decompress runs
./sm/compressors/rle_compressor.h: * @file   rle_compressor.h
./sm/compressors/rle_compressor.h: * This file defines the rle compressor class.
./sm/compressors/rle_compressor.h:/** Handles compression/decompression Run-Length-Encoding. */
./sm/compressors/rle_compressor.h:   * @param output_buffer Output buffer to write the compressed data to.
./sm/compressors/rle_compressor.h:  static Status compress(
./sm/compressors/rle_compressor.h:   * Decompression function.
./sm/compressors/rle_compressor.h:   * @param output_buffer Output buffer to write to the decompressed data.
./sm/compressors/rle_compressor.h:  static Status decompress(
./sm/compressors/rle_compressor.h:  /** Returns the compression overhead for the given input. */
./sm/compressors/zstd_compressor.cc: * @file   zstd_compressor.cc
./sm/compressors/zstd_compressor.cc: * This file implements the zstd compressor class.
./sm/compressors/zstd_compressor.cc:#include "tiledb/sm/compressors/zstd_compressor.h"
./sm/compressors/zstd_compressor.cc:Status ZStd::compress(
./sm/compressors/zstd_compressor.cc:        "Failed compressing with ZStd; invalid buffer format"));
./sm/compressors/zstd_compressor.cc:        std::string("ZStd compression failed; could not allocate context.")));
./sm/compressors/zstd_compressor.cc:  uint64_t zstd_ret = ZSTD_compressCCtx(
./sm/compressors/zstd_compressor.cc:        std::string("ZStd compression failed: ") + msg));
./sm/compressors/zstd_compressor.cc:  // Set size of compressed data
./sm/compressors/zstd_compressor.cc:Status ZStd::decompress(
./sm/compressors/zstd_compressor.cc:        "Failed decompressing with ZStd; invalid buffer format"));
./sm/compressors/zstd_compressor.cc:        std::string("ZStd decompression failed; could not allocate context.")));
./sm/compressors/zstd_compressor.cc:  // Decompress
./sm/compressors/zstd_compressor.cc:  uint64_t zstd_ret = ZSTD_decompressDCtx(
./sm/compressors/zstd_compressor.cc:        std::string("ZStd decompression failed: ") + msg));
./sm/compressors/zstd_compressor.cc:  // Set size decompressed data
./sm/compressors/zstd_compressor.cc:  return ZSTD_compressBound(nbytes) - nbytes;
./sm/compressors/zstd_compressor.h: * @file   zstd_compressor.h
./sm/compressors/zstd_compressor.h: * This file defines the zstd compressor class.
./sm/compressors/zstd_compressor.h:/** Handles compression/decompression with the zstd library. */
./sm/compressors/zstd_compressor.h:   * @param output_buffer Output buffer to write to the compressed data.
./sm/compressors/zstd_compressor.h:  static Status compress(
./sm/compressors/zstd_compressor.h:   * Decompression function.
./sm/compressors/zstd_compressor.h:   * @param output_buffer Output buffer to write the decompressed data to.
./sm/compressors/zstd_compressor.h:  static Status decompress(
./sm/compressors/zstd_compressor.h:  /** Returns the default compression level. */
./sm/compressors/zstd_compressor.h:  /** Returns the compression overhead for the given input. */
./sm/config/config.cc:  param_values_["rest.http_compressor"] = REST_SERVER_DEFAULT_HTTP_COMPRESSOR;
./sm/config/config.cc:  } else if (param == "rest.http_compressor") {
./sm/config/config.cc:    param_values_["rest.http_compressor"] = REST_SERVER_DEFAULT_HTTP_COMPRESSOR;
./sm/config/config.h:  /** The default compressor for http requests with the rest server. */
./sm/cpp_api/array_schema.h: * domain, cell types, and compression details. An array schema is composed of:
./sm/cpp_api/array_schema.h:   * coordinate compressor, use `set_coords_filter_list()`.
./sm/cpp_api/array_schema.h:   * (such as compression).
./sm/cpp_api/array_schema.h:   * offsets compressor, use `set_offsets_filter_list()`.
./sm/cpp_api/array_schema.h:   * (such as compression).
./sm/cpp_api/attribute.h: * // Change compression scheme
./sm/cpp_api/attribute.h:   * compression).
./sm/cpp_api/dimension.h:   * compression).
./sm/cpp_api/filter.h: * with compression, delta encoding, etc.
./sm/cpp_api/filter.h:   * // level == -1 (the default compression level)
./sm/cpp_api/filter.h:   * // level == -1 (the default compression level)
./sm/c_api/tiledb.cc:#include "tiledb/sm/filter/compression_filter.h"
./sm/c_api/tiledb_enum.h:    /** Gzip compressor */
./sm/c_api/tiledb_enum.h:    /** Zstandard compressor */
./sm/c_api/tiledb_enum.h:    /** LZ4 compressor */
./sm/c_api/tiledb_enum.h:    /** Run-length encoding compressor */
./sm/c_api/tiledb_enum.h:    /** Bzip2 compressor */
./sm/c_api/tiledb_enum.h:    /** Double-delta compressor */
./sm/c_api/tiledb_struct_def.h:#include "tiledb/sm/filter/compression_filter.h"
./sm/enums/compressor.h: * @file compressor.h
./sm/enums/compressor.h: * This defines the tiledb CompressorType enum that maps to tiledb_compressor_t
./sm/enums/compressor.h:/** Defines the compressor type. */
./sm/enums/compressor.h:  /** No compressor */
./sm/enums/compressor.h:  /** Gzip compressor */
./sm/enums/compressor.h:  /** Zstandard compressor */
./sm/enums/compressor.h:  /** LZ4 compressor */
./sm/enums/compressor.h:  /** Run-length encoding compressor */
./sm/enums/compressor.h:  /** Bzip2 compressor */
./sm/enums/compressor.h:  /** Double-delta compressor */
./sm/enums/compressor.h:/** Returns the string representation of the input compressor. */
./sm/enums/compressor.h:inline const std::string& compressor_str(Compressor type) {
./sm/enums/compressor.h:      return constants::no_compression_str;
./sm/enums/compressor.h:/** Returns the compressor based on the string representation. */
./sm/enums/compressor.h:inline Status compressor_enum(
./sm/enums/compressor.h:    const std::string& compressor_type_str, Compressor* compressor) {
./sm/enums/compressor.h:  if (compressor_type_str == constants::no_compression_str)
./sm/enums/compressor.h:    *compressor = Compressor::NO_COMPRESSION;
./sm/enums/compressor.h:  else if (compressor_type_str == constants::gzip_str)
./sm/enums/compressor.h:    *compressor = Compressor::GZIP;
./sm/enums/compressor.h:  else if (compressor_type_str == constants::zstd_str)
./sm/enums/compressor.h:    *compressor = Compressor::ZSTD;
./sm/enums/compressor.h:  else if (compressor_type_str == constants::lz4_str)
./sm/enums/compressor.h:    *compressor = Compressor::LZ4;
./sm/enums/compressor.h:  else if (compressor_type_str == constants::rle_str)
./sm/enums/compressor.h:    *compressor = Compressor::RLE;
./sm/enums/compressor.h:  else if (compressor_type_str == constants::bzip2_str)
./sm/enums/compressor.h:    *compressor = Compressor::BZIP2;
./sm/enums/compressor.h:  else if (compressor_type_str == constants::double_delta_str)
./sm/enums/compressor.h:    *compressor = Compressor::DOUBLE_DELTA;
./sm/enums/compressor.h:    return Status::Error("Invalid Compressor " + compressor_type_str);
./sm/enums/filter_option.h:      return constants::filter_option_compression_level_str;
./sm/enums/filter_option.h:  if (filter_option_str == constants::filter_option_compression_level_str)
./sm/filter/bitshuffle_filter.cc:          Status::FilterError("Bitshuffle error; Decompression error, wrong "
./sm/filter/bitshuffle_filter.cc:          Status::FilterError("Bitshuffle error; Decompression error, wrong "
./sm/filter/bit_width_reduction_filter.cc:  // If bit width compression can't work, just return the input unmodified.
./sm/filter/bit_width_reduction_filter.cc:    RETURN_NOT_OK(compress_part<T>(&parts[i], output, output_metadata));
./sm/filter/bit_width_reduction_filter.cc:Status BitWidthReductionFilter::compress_part(
./sm/filter/bit_width_reduction_filter.cc:    uint8_t compressed_bits =
./sm/filter/bit_width_reduction_filter.cc:    RETURN_NOT_OK(output_metadata->write(&compressed_bits, sizeof(uint8_t)));
./sm/filter/bit_width_reduction_filter.cc:    if (compressed_bits >= orig_bits || window_nbytes % sizeof(T) != 0) {
./sm/filter/bit_width_reduction_filter.cc:      // Can't compress; just write the window bytes unmodified.
./sm/filter/bit_width_reduction_filter.cc:            write_compressed_value(output, relative_value, compressed_bits));
./sm/filter/bit_width_reduction_filter.cc:  // If bit width compression wasn't applied, just return the input unmodified.
./sm/filter/bit_width_reduction_filter.cc:    uint8_t orig_bits = sizeof(T) * 8, compressed_bits;
./sm/filter/bit_width_reduction_filter.cc:    RETURN_NOT_OK(input_metadata->read(&compressed_bits, sizeof(uint8_t)));
./sm/filter/bit_width_reduction_filter.cc:    if (compressed_bits >= orig_bits || window_nbytes % sizeof(T) != 0) {
./sm/filter/bit_width_reduction_filter.cc:      // Window was not compressed.
./sm/filter/bit_width_reduction_filter.cc:      // Read and uncompress each window value.
./sm/filter/bit_width_reduction_filter.cc:            read_compressed_value(input, compressed_bits, &input_value));
./sm/filter/bit_width_reduction_filter.cc:Status BitWidthReductionFilter::write_compressed_value(
./sm/filter/bit_width_reduction_filter.cc:Status BitWidthReductionFilter::read_compressed_value(
./sm/filter/bit_width_reduction_filter.cc:    FilterBuffer* buffer, uint8_t compressed_bits, T* value) const {
./sm/filter/bit_width_reduction_filter.cc:  switch (compressed_bits) {
./sm/filter/bit_width_reduction_filter.h: * A filter that compresses an array of unsigned integers by reducing the number
./sm/filter/bit_width_reduction_filter.h: * When compressing, the filter determines the min and max values of the input
./sm/filter/bit_width_reduction_filter.h: * Input metadata is not compressed or modified.
./sm/filter/bit_width_reduction_filter.h:  /** Maximum size, in bytes, of a window of input elements to compress. */
./sm/filter/bit_width_reduction_filter.h:   * @param input Buffer to compress
./sm/filter/bit_width_reduction_filter.h:   * @param output Buffer to store compressed output.
./sm/filter/bit_width_reduction_filter.h:  Status compress_part(
./sm/filter/bit_width_reduction_filter.h:   * Reads a compressed value of type T from the given buffer after
./sm/filter/bit_width_reduction_filter.h:   * decompressing from a value of the given bit width.
./sm/filter/bit_width_reduction_filter.h:   * @param compressed_bits Bit width of compressed value to read
./sm/filter/bit_width_reduction_filter.h:   * @param value Will be set to the decompressed value
./sm/filter/bit_width_reduction_filter.h:  Status read_compressed_value(
./sm/filter/bit_width_reduction_filter.h:      FilterBuffer* buffer, uint8_t compressed_bits, T* value) const;
./sm/filter/bit_width_reduction_filter.h:   * Writes the given value of type T to the given buffer after compressing
./sm/filter/bit_width_reduction_filter.h:   * @param value Uncompressed value to write
./sm/filter/bit_width_reduction_filter.h:   * @param num_bits Bit width of compressed value to write
./sm/filter/bit_width_reduction_filter.h:  Status write_compressed_value(
./sm/filter/compression_filter.cc: * @file   compression_filter.cc
./sm/filter/compression_filter.cc:#include "tiledb/sm/filter/compression_filter.h"
./sm/filter/compression_filter.cc:#include "tiledb/sm/compressors/bzip_compressor.h"
./sm/filter/compression_filter.cc:#include "tiledb/sm/compressors/dd_compressor.h"
./sm/filter/compression_filter.cc:#include "tiledb/sm/compressors/gzip_compressor.h"
./sm/filter/compression_filter.cc:#include "tiledb/sm/compressors/lz4_compressor.h"
./sm/filter/compression_filter.cc:#include "tiledb/sm/compressors/rle_compressor.h"
./sm/filter/compression_filter.cc:#include "tiledb/sm/compressors/zstd_compressor.h"
./sm/filter/compression_filter.cc:#include "tiledb/sm/enums/compressor.h"
./sm/filter/compression_filter.cc:CompressionFilter::CompressionFilter(FilterType compressor, int level)
./sm/filter/compression_filter.cc:    : Filter(compressor) {
./sm/filter/compression_filter.cc:  compressor_ = filter_to_compressor(compressor);
./sm/filter/compression_filter.cc:CompressionFilter::CompressionFilter(Compressor compressor, int level)
./sm/filter/compression_filter.cc:  compressor_ = compressor;
./sm/filter/compression_filter.cc:  type_ = compressor_to_filter(compressor);
./sm/filter/compression_filter.cc:Compressor CompressionFilter::compressor() const {
./sm/filter/compression_filter.cc:  return compressor_;
./sm/filter/compression_filter.cc:int CompressionFilter::compression_level() const {
./sm/filter/compression_filter.cc:  std::string compressor_str;
./sm/filter/compression_filter.cc:  switch (compressor_) {
./sm/filter/compression_filter.cc:      compressor_str = "NO_COMPRESSION";
./sm/filter/compression_filter.cc:      compressor_str = "GZIP";
./sm/filter/compression_filter.cc:      compressor_str = "ZSTD";
./sm/filter/compression_filter.cc:      compressor_str = "LZ4";
./sm/filter/compression_filter.cc:      compressor_str = "RLE";
./sm/filter/compression_filter.cc:      compressor_str = "BZIP2";
./sm/filter/compression_filter.cc:      compressor_str = "DOUBLE_DELTA";
./sm/filter/compression_filter.cc:      compressor_str = "NO_COMPRESSION";
./sm/filter/compression_filter.cc:  fprintf(out, "%s: COMPRESSION_LEVEL=%i", compressor_str.c_str(), level_);
./sm/filter/compression_filter.cc:  return new CompressionFilter(compressor_, level_);
./sm/filter/compression_filter.cc:void CompressionFilter::set_compressor(Compressor compressor) {
./sm/filter/compression_filter.cc:  compressor_ = compressor;
./sm/filter/compression_filter.cc:  type_ = compressor_to_filter(compressor);
./sm/filter/compression_filter.cc:void CompressionFilter::set_compression_level(int compressor_level) {
./sm/filter/compression_filter.cc:  level_ = compressor_level;
./sm/filter/compression_filter.cc:FilterType CompressionFilter::compressor_to_filter(Compressor compressor) {
./sm/filter/compression_filter.cc:  switch (compressor) {
./sm/filter/compression_filter.cc:Compressor CompressionFilter::filter_to_compressor(FilterType type) {
./sm/filter/compression_filter.cc:  // Easy case: no compression
./sm/filter/compression_filter.cc:  if (compressor_ == Compressor::NO_COMPRESSION) {
./sm/filter/compression_filter.cc:        Status::FilterError("Input is too large to be compressed."));
./sm/filter/compression_filter.cc:    RETURN_NOT_OK(compress_part(&part, buffer_ptr, output_metadata));
./sm/filter/compression_filter.cc:    RETURN_NOT_OK(compress_part(&part, buffer_ptr, output_metadata));
./sm/filter/compression_filter.cc:  // Easy case: no compression
./sm/filter/compression_filter.cc:  if (compressor_ == Compressor::NO_COMPRESSION) {
./sm/filter/compression_filter.cc:    RETURN_NOT_OK(decompress_part(input, metadata_buffer, input_metadata));
./sm/filter/compression_filter.cc:    RETURN_NOT_OK(decompress_part(input, data_buffer, input_metadata));
./sm/filter/compression_filter.cc:Status CompressionFilter::compress_part(
./sm/filter/compression_filter.cc:  // Invoke the proper compressor
./sm/filter/compression_filter.cc:  switch (compressor_) {
./sm/filter/compression_filter.cc:      RETURN_NOT_OK(GZip::compress(level_, &input_buffer, output));
./sm/filter/compression_filter.cc:      RETURN_NOT_OK(ZStd::compress(level_, &input_buffer, output));
./sm/filter/compression_filter.cc:      RETURN_NOT_OK(LZ4::compress(level_, &input_buffer, output));
./sm/filter/compression_filter.cc:      RETURN_NOT_OK(RLE::compress(cell_size, &input_buffer, output));
./sm/filter/compression_filter.cc:      RETURN_NOT_OK(BZip::compress(level_, &input_buffer, output));
./sm/filter/compression_filter.cc:      RETURN_NOT_OK(DoubleDelta::compress(type, &input_buffer, output));
./sm/filter/compression_filter.cc:  // Write part original and compressed size to metadata
./sm/filter/compression_filter.cc:           compressed_size = (uint32_t)output->size() - orig_size;
./sm/filter/compression_filter.cc:  RETURN_NOT_OK(output_metadata->write(&compressed_size, sizeof(uint32_t)));
./sm/filter/compression_filter.cc:Status CompressionFilter::decompress_part(
./sm/filter/compression_filter.cc:  uint32_t compressed_size, uncompressed_size;
./sm/filter/compression_filter.cc:  RETURN_NOT_OK(input_metadata->read(&uncompressed_size, sizeof(uint32_t)));
./sm/filter/compression_filter.cc:  RETURN_NOT_OK(input_metadata->read(&compressed_size, sizeof(uint32_t)));
./sm/filter/compression_filter.cc:    RETURN_NOT_OK(output->realloc(output->alloced_size() + uncompressed_size));
./sm/filter/compression_filter.cc:  } else if (output->offset() + uncompressed_size > output->size()) {
./sm/filter/compression_filter.cc:  RETURN_NOT_OK(input->get_const_buffer(compressed_size, &input_buffer));
./sm/filter/compression_filter.cc:  PreallocatedBuffer output_buffer(output->cur_data(), uncompressed_size);
./sm/filter/compression_filter.cc:  // Invoke the proper decompressor
./sm/filter/compression_filter.cc:  switch (compressor_) {
./sm/filter/compression_filter.cc:      st = GZip::decompress(&input_buffer, &output_buffer);
./sm/filter/compression_filter.cc:      st = ZStd::decompress(&input_buffer, &output_buffer);
./sm/filter/compression_filter.cc:      st = LZ4::decompress(&input_buffer, &output_buffer);
./sm/filter/compression_filter.cc:      st = RLE::decompress(cell_size, &input_buffer, &output_buffer);
./sm/filter/compression_filter.cc:      st = BZip::decompress(&input_buffer, &output_buffer);
./sm/filter/compression_filter.cc:      st = DoubleDelta::decompress(type, &input_buffer, &output_buffer);
./sm/filter/compression_filter.cc:    output->advance_size(uncompressed_size);
./sm/filter/compression_filter.cc:  output->advance_offset(uncompressed_size);
./sm/filter/compression_filter.cc:  input->advance_offset(compressed_size);
./sm/filter/compression_filter.cc:  switch (compressor_) {
./sm/filter/compression_filter.cc:      // No compression
./sm/filter/compression_filter.cc:  auto compressor_char = static_cast<uint8_t>(compressor_);
./sm/filter/compression_filter.cc:  RETURN_NOT_OK(buff->write(&compressor_char, sizeof(uint8_t)));
./sm/filter/compression_filter.cc:  uint8_t compressor_char;
./sm/filter/compression_filter.cc:  RETURN_NOT_OK(buff->read(&compressor_char, sizeof(uint8_t)));
./sm/filter/compression_filter.cc:  compressor_ = static_cast<Compressor>(compressor_char);
./sm/filter/compression_filter.h: * @file   compression_filter.h
./sm/filter/compression_filter.h: * A filter that compresses/decompresses its input data. The FilterBuffer input
./sm/filter/compression_filter.h: * "part", and is compressed separately by this filter. Input metadata is
./sm/filter/compression_filter.h: * compressed as well.
./sm/filter/compression_filter.h: * The forward (compress) output metadata has the format:
./sm/filter/compression_filter.h: *   uint32_t - Number of compressed metadata parts
./sm/filter/compression_filter.h: *   uint32_t - Number of compressed data parts
./sm/filter/compression_filter.h: *   uint32_t - part uncompressed length
./sm/filter/compression_filter.h: *   uint32_t - part compressed length
./sm/filter/compression_filter.h: * The forward output data format is just the concatenated compressed bytes:
./sm/filter/compression_filter.h: *   uint8_t[] - metadata_part0's array of compressed bytes
./sm/filter/compression_filter.h: *   uint8_t[] - metadata_partN's array of compressed bytes
./sm/filter/compression_filter.h: *   uint8_t[] - data_part0's array of compressed bytes
./sm/filter/compression_filter.h: *   uint8_t[] - data_partN's array of compressed bytes
./sm/filter/compression_filter.h: * The reverse (decompress) output format is simply:
./sm/filter/compression_filter.h: *   uint8_t[] - Array of uncompressed bytes
./sm/filter/compression_filter.h:   * @param compressor Compressor to use
./sm/filter/compression_filter.h:  CompressionFilter(Compressor compressor, int level);
./sm/filter/compression_filter.h:   * @param compressor Compressor to use
./sm/filter/compression_filter.h:  CompressionFilter(FilterType compressor, int level);
./sm/filter/compression_filter.h:  /** Return the compressor used by this filter instance. */
./sm/filter/compression_filter.h:  Compressor compressor() const;
./sm/filter/compression_filter.h:  /** Return the compression level used by this filter instance. */
./sm/filter/compression_filter.h:  int compression_level() const;
./sm/filter/compression_filter.h:   * Decompress the given input into the given output.
./sm/filter/compression_filter.h:  /** Set the compressor used by this filter instance. */
./sm/filter/compression_filter.h:  void set_compressor(Compressor compressor);
./sm/filter/compression_filter.h:  /** Set the compression level used by this filter instance. */
./sm/filter/compression_filter.h:  void set_compression_level(int compressor_level);
./sm/filter/compression_filter.h:  /** The compressor. */
./sm/filter/compression_filter.h:  Compressor compressor_;
./sm/filter/compression_filter.h:  /** The compression level. */
./sm/filter/compression_filter.h:  /** Helper function to compress a single contiguous buffer (part). */
./sm/filter/compression_filter.h:  Status compress_part(
./sm/filter/compression_filter.h:  static FilterType compressor_to_filter(Compressor compressor);
./sm/filter/compression_filter.h:   * Helper function to decompress a single contiguous buffer (part), appending
./sm/filter/compression_filter.h:  Status decompress_part(
./sm/filter/compression_filter.h:  static Compressor filter_to_compressor(FilterType type);
./sm/filter/compression_filter.h:  /** Computes the compression overhead on nbytes of the input data. */
./sm/filter/filter.cc:#include "tiledb/sm/filter/compression_filter.h"
./sm/filter/filter_pipeline.cc:#include "tiledb/sm/filter/compression_filter.h"
./sm/filter/filter_pipeline.cc:        "Filter error; tile has allocated uncompressed chunk buffers."));
./sm/filter/filter_pipeline.cc:    // Note that format version < 2 only split the coordinates when compression
./sm/filter/filter_pipeline.cc:    bool using_compression = get_filter<CompressionFilter>() != nullptr;
./sm/filter/filter_pipeline.cc:    if (version > 1 || using_compression) {
./sm/filter/filter_pipeline.cc:    // For compatibility with the old attribute compressor API: if the filter
./sm/filter/filter_pipeline.cc:    // is a compression filter but with no compression, serialize the filter
./sm/filter/filter_pipeline.cc:    auto as_compression = dynamic_cast<CompressionFilter*>(f.get());
./sm/filter/filter_pipeline.cc:    if (as_compression != nullptr && f->type() == FilterType::FILTER_NONE) {
./sm/filter/filter_pipeline.h:   * uncompressed) Tile data into filtered (e.g. compressed) Tile data.
./sm/filter/filter_pipeline.h:   * during reads, and processes filtered Tile data (e.g. compressed) into
./sm/filter/positive_delta_filter.h: * Input metadata is not compressed or modified.
./sm/filter/positive_delta_filter.h:  /** Maximum size, in bytes, of a window of input elements to compress. */
./sm/fragment/fragment_metadata.h:   * compressed tile on disk) for a given attribute or dimension and tile index.
./sm/fragment/fragment_metadata.h:   * compressed tile on disk) for a given var-sized attribute or dimension
./sm/fragment/fragment_metadata.h:   * Returns the (uncompressed) tile size for a given attribute or dimension
./sm/fragment/fragment_metadata.h:   * Retrieves the (uncompressed) tile size for a given var-sized attribute or
./sm/fragment/fragment_metadata.h:   * when there is compression.
./sm/fragment/fragment_metadata.h:   * The sizes of the uncompressed variable tiles.
./sm/fragment/fragment_metadata.h:   * Meaningful only when there is compression for variable tiles.
./sm/misc/constants.cc:#include "tiledb/sm/enums/compressor.h"
./sm/misc/constants.cc:/** The default compressor for the offsets of variable-sized cells. */
./sm/misc/constants.cc:Compressor cell_var_offsets_compression = Compressor::ZSTD;
./sm/misc/constants.cc:/** The default compression level for the offsets of variable-sized cells. */
./sm/misc/constants.cc:int cell_var_offsets_compression_level = -1;
./sm/misc/constants.cc:/** The default compressor for the coordinates. */
./sm/misc/constants.cc:Compressor coords_compression = Compressor::ZSTD;
./sm/misc/constants.cc:/** The default compressor for real coordinates. */
./sm/misc/constants.cc:Compressor real_coords_compression = Compressor::ZSTD;
./sm/misc/constants.cc:/** The default compression level for the coordinates. */
./sm/misc/constants.cc:int coords_compression_level = -1;
./sm/misc/constants.cc:/** Default compressor for a generic tile. */
./sm/misc/constants.cc:Compressor generic_tile_compressor = Compressor::GZIP;
./sm/misc/constants.cc:/** Default compression level for a generic tile. */
./sm/misc/constants.cc:int generic_tile_compression_level = 1;
./sm/misc/constants.cc:/** String describing no compression. */
./sm/misc/constants.cc:const std::string no_compression_str = "NO_COMPRESSION";
./sm/misc/constants.cc:const std::string filter_type_compression_str = "COMPRESSION";
./sm/misc/constants.cc:/** The string representation for FilterOption type compression_level. */
./sm/misc/constants.cc:const std::string filter_option_compression_level_str = "COMPRESSION_LEVEL";
./sm/misc/constants.cc:/** The maximum size of a tile chunk (unit of compression) in bytes. */
./sm/misc/constants.h:/** The default compressor for the offsets of variable-sized cells. */
./sm/misc/constants.h:extern Compressor cell_var_offsets_compression;
./sm/misc/constants.h:/** The default compression level for the offsets of variable-sized cells. */
./sm/misc/constants.h:extern int cell_var_offsets_compression_level;
./sm/misc/constants.h:/** The default compressor for the coordinates. */
./sm/misc/constants.h:extern Compressor coords_compression;
./sm/misc/constants.h:/** The default compressor for real coordinates. */
./sm/misc/constants.h:extern Compressor real_coords_compression;
./sm/misc/constants.h:/** The default compression level for the coordinates. */
./sm/misc/constants.h:extern int coords_compression_level;
./sm/misc/constants.h:/** Default compressor for a generic tile. */
./sm/misc/constants.h:extern Compressor generic_tile_compressor;
./sm/misc/constants.h:/** Default compression level for a generic tile. */
./sm/misc/constants.h:extern int generic_tile_compression_level;
./sm/misc/constants.h:/** String describing no compression. */
./sm/misc/constants.h:extern const std::string no_compression_str;
./sm/misc/constants.h:extern const std::string filter_type_compression_str;
./sm/misc/constants.h:/** The string representation for FilterOption type compression_level. */
./sm/misc/constants.h:extern const std::string filter_option_compression_level_str;
./sm/misc/constants.h:/** The maximum size of a tile chunk (unit of compression) in bytes. */
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_bzip_compress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_bzip_decompress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_dd_compress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_dd_decompress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_gzip_compress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_gzip_decompress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_lz4_compress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_lz4_decompress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_rle_compress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_rle_decompress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_zstd_compress)
./sm/misc/stats_counters.h:STATS_DEFINE_FUNC_STAT(compressor_zstd_decompress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_bzip_compress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_bzip_decompress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_dd_compress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_dd_decompress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_gzip_compress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_gzip_decompress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_lz4_compress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_lz4_decompress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_rle_compress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_rle_decompress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_zstd_compress)
./sm/misc/stats_counters.h:STATS_INIT_FUNC_STAT(compressor_zstd_decompress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_bzip_compress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_bzip_decompress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_dd_compress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_dd_decompress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_gzip_compress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_gzip_decompress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_lz4_compress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_lz4_decompress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_rle_compress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_rle_decompress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_zstd_compress)
./sm/misc/stats_counters.h:STATS_REPORT_FUNC_STAT(compressor_zstd_decompress)
./sm/query/reader.cc:  // selective decompression intersection algorithm. For 1-dimensional arrays,
./sm/rest/curl.cc:    /* set compression */
./sm/rest/curl.cc:    const char* compressor = nullptr;
./sm/rest/curl.cc:    RETURN_NOT_OK(config_->get("rest.http_compressor", &compressor));
./sm/rest/curl.cc:    if (compressor != nullptr) {
./sm/rest/curl.cc:      std::string comp(compressor);
./sm/serialization/array_schema-ser.cc:#include "tiledb/sm/enums/compressor.h"
./sm/serialization/tiledb-rest.capnp:    # Type of compression for coordinates (enum)
./sm/storage_manager/open_array.h:   * (decompressed, decrypted) array metadata into constant buffers.
./sm/tile/generic_tile_io.cc:#include "tiledb/sm/filter/compression_filter.h"
./sm/tile/generic_tile_io.cc:      constants::generic_tile_compressor,
./sm/tile/generic_tile_io.cc:      constants::generic_tile_compression_level)));
./sm/tile/generic_tile_io.h:    /** Persisted (e.g. compressed) size of the tile. */
./sm/tile/generic_tile_io.h:    /** Uncompressed size of the tile. */
./sm/tile/tile.h:   * On writes, the pre-filtered size is the uncompressed size.
./sm/tile/tile.h:   * On reads, the pre-filtered size is the persisted (compressed) size.
