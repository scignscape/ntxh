# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Channel')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Channel')
    _Channel = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Channel', [dirname(__file__)])
        except ImportError:
            import _Channel
            return _Channel
        if fp is not None:
            try:
                _mod = imp.load_module('_Channel', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Channel = swig_import_helper()
    del swig_import_helper
else:
    import _Channel
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


import VPLSwig.Core.Core
import VPLSwig.Image.Image
import VPLSwig.Core.Geometry
class charArray(_object):
    """Proxy of C++ charArray class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, charArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, charArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """__init__(self, nelements) -> charArray"""
        this = _Channel.new_charArray(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Channel.delete_charArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        """__getitem__(self, index) -> char"""
        return _Channel.charArray___getitem__(self, index)


    def __setitem__(self, index, value):
        """__setitem__(self, index, value)"""
        return _Channel.charArray___setitem__(self, index, value)


    def cast(self):
        """cast(self) -> char *"""
        return _Channel.charArray_cast(self)


    def frompointer(t):
        """frompointer(t) -> charArray"""
        return _Channel.charArray_frompointer(t)

    frompointer = staticmethod(frompointer)
charArray_swigregister = _Channel.charArray_swigregister
charArray_swigregister(charArray)

def charArray_frompointer(t):
    """charArray_frompointer(t) -> charArray"""
    return _Channel.charArray_frompointer(t)

CH_UNKNOWN = _Channel.CH_UNKNOWN
CH_IN = _Channel.CH_IN
CH_OUT = _Channel.CH_OUT
CH_BIDIRECTIONAL = _Channel.CH_BIDIRECTIONAL
CH_COMPRESSOR = _Channel.CH_COMPRESSOR
CH_PREDICTOR = _Channel.CH_PREDICTOR
CH_NULL = _Channel.CH_NULL
CH_STDIO = _Channel.CH_STDIO
CH_FILE = _Channel.CH_FILE
CH_PIPE = _Channel.CH_PIPE
CH_SHM = _Channel.CH_SHM
CH_TCP = _Channel.CH_TCP
CH_MEM = _Channel.CH_MEM
class CChannel(VPLSwig.Core.Core.CObject):
    """Proxy of C++ vpl::mod::CChannel class."""

    __swig_setmethods__ = {}
    for _s in [VPLSwig.Core.Core.CObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CChannel, name, value)
    __swig_getmethods__ = {}
    for _s in [VPLSwig.Core.Core.CObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CChannel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self) -> CChannel
        __init__(self, Medium, Type) -> CChannel
        """
        if self.__class__ == CChannel:
            _self = None
        else:
            _self = self
        this = _Channel.new_CChannel(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Channel.delete_CChannel
    __del__ = lambda self: None

    def getType(self):
        """getType(self) -> int"""
        return _Channel.CChannel_getType(self)


    def checkType(self, Type):
        """checkType(self, Type) -> bool"""
        return _Channel.CChannel_checkType(self, Type)


    def getMedium(self):
        """getMedium(self) -> int"""
        return _Channel.CChannel_getMedium(self)


    def checkMedium(self, Medium):
        """checkMedium(self, Medium) -> bool"""
        return _Channel.CChannel_checkMedium(self, Medium)


    def connect(self, *args):
        """
        connect(self, uTimeout) -> bool
        connect(self) -> bool
        """
        return _Channel.CChannel_connect(self, *args)


    def listen(self, *args):
        """
        listen(self, uTimeout) -> bool
        listen(self) -> bool
        """
        return _Channel.CChannel_listen(self, *args)


    def disconnect(self):
        """disconnect(self)"""
        return _Channel.CChannel_disconnect(self)


    def isConnected(self):
        """isConnected(self) -> bool"""
        return _Channel.CChannel_isConnected(self)


    def wait(self, *args):
        """
        wait(self, uTimeout) -> bool
        wait(self) -> bool
        """
        return _Channel.CChannel_wait(self, *args)


    def read(self, pcData, iLength):
        """read(self, pcData, iLength) -> vpl::tSize"""
        return _Channel.CChannel_read(self, pcData, iLength)


    def write(self, pcData, iLength):
        """write(self, pcData, iLength) -> bool"""
        return _Channel.CChannel_write(self, pcData, iLength)


    def flush(self):
        """flush(self) -> bool"""
        return _Channel.CChannel_flush(self)


    def skip(self, iLength):
        """skip(self, iLength) -> bool"""
        return _Channel.CChannel_skip(self, iLength)


    def create(eType, sDesc):
        """create(eType, sDesc) -> CChannel"""
        return _Channel.CChannel_create(eType, sDesc)

    create = staticmethod(create)

    def separate(sDescs, Descs):
        """separate(sDescs, Descs)"""
        return _Channel.CChannel_separate(sDescs, Descs)

    separate = staticmethod(separate)

    def getFileName(self):
        """getFileName(self) -> std::string"""
        return _Channel.CChannel_getFileName(self)

    def __disown__(self):
        self.this.disown()
        _Channel.disown_CChannel(self)
        return weakref_proxy(self)
CChannel_swigregister = _Channel.CChannel_swigregister
CChannel_swigregister(CChannel)
cvar = _Channel.cvar
CH_NULL_TEXT = cvar.CH_NULL_TEXT
CH_STDIO_TEXT = cvar.CH_STDIO_TEXT
CH_FILE_TEXT = cvar.CH_FILE_TEXT
CH_PIPE_TEXT = cvar.CH_PIPE_TEXT
CH_SHM_TEXT = cvar.CH_SHM_TEXT
CH_MEDIUM_TYPE = cvar.CH_MEDIUM_TYPE
CH_CONNECTION_TIMEOUT = cvar.CH_CONNECTION_TIMEOUT
CH_WAIT_TIMEOUT = cvar.CH_WAIT_TIMEOUT

def CChannel_create(eType, sDesc):
    """CChannel_create(eType, sDesc) -> CChannel"""
    return _Channel.CChannel_create(eType, sDesc)

def CChannel_separate(sDescs, Descs):
    """CChannel_separate(sDescs, Descs)"""
    return _Channel.CChannel_separate(sDescs, Descs)

class CStdChannel(CChannel):
    """Proxy of C++ vpl::mod::CStdChannel class."""

    __swig_setmethods__ = {}
    for _s in [CChannel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CStdChannel, name, value)
    __swig_getmethods__ = {}
    for _s in [CChannel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CStdChannel, name)
    __repr__ = _swig_repr

    def __init__(self, Type):
        """__init__(self, Type) -> CStdChannel"""
        if self.__class__ == CStdChannel:
            _self = None
        else:
            _self = self
        this = _Channel.new_CStdChannel(_self, Type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Channel.delete_CStdChannel
    __del__ = lambda self: None

    def connect(self, *args):
        """
        connect(self, uTimeout) -> bool
        connect(self) -> bool
        """
        return _Channel.CStdChannel_connect(self, *args)


    def listen(self, *args):
        """
        listen(self, uTimeout) -> bool
        listen(self) -> bool
        """
        return _Channel.CStdChannel_listen(self, *args)


    def disconnect(self):
        """disconnect(self)"""
        return _Channel.CStdChannel_disconnect(self)


    def isConnected(self):
        """isConnected(self) -> bool"""
        return _Channel.CStdChannel_isConnected(self)


    def wait(self, *args):
        """
        wait(self, uTimeout) -> bool
        wait(self) -> bool
        """
        return _Channel.CStdChannel_wait(self, *args)


    def read(self, pcData, iLength):
        """read(self, pcData, iLength) -> vpl::tSize"""
        return _Channel.CStdChannel_read(self, pcData, iLength)


    def write(self, pcData, iLength):
        """write(self, pcData, iLength) -> bool"""
        return _Channel.CStdChannel_write(self, pcData, iLength)


    def flush(self):
        """flush(self) -> bool"""
        return _Channel.CStdChannel_flush(self)

    def __disown__(self):
        self.this.disown()
        _Channel.disown_CStdChannel(self)
        return weakref_proxy(self)
CStdChannel_swigregister = _Channel.CStdChannel_swigregister
CStdChannel_swigregister(CStdChannel)

class CFileChannel(CChannel):
    """Proxy of C++ vpl::mod::CFileChannel class."""

    __swig_setmethods__ = {}
    for _s in [CChannel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CFileChannel, name, value)
    __swig_getmethods__ = {}
    for _s in [CChannel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CFileChannel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, Type, sFileName) -> CFileChannel
        __init__(self, Type) -> CFileChannel
        """
        if self.__class__ == CFileChannel:
            _self = None
        else:
            _self = self
        this = _Channel.new_CFileChannel(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Channel.delete_CFileChannel
    __del__ = lambda self: None

    def setFilename(self, sFileName):
        """setFilename(self, sFileName)"""
        return _Channel.CFileChannel_setFilename(self, sFileName)


    def connect(self, *args):
        """
        connect(self, uTimeout) -> bool
        connect(self) -> bool
        """
        return _Channel.CFileChannel_connect(self, *args)


    def listen(self, *args):
        """
        listen(self, uTimeout) -> bool
        listen(self) -> bool
        """
        return _Channel.CFileChannel_listen(self, *args)


    def disconnect(self):
        """disconnect(self)"""
        return _Channel.CFileChannel_disconnect(self)


    def isConnected(self):
        """isConnected(self) -> bool"""
        return _Channel.CFileChannel_isConnected(self)


    def wait(self, *args):
        """
        wait(self, uTimeout) -> bool
        wait(self) -> bool
        """
        return _Channel.CFileChannel_wait(self, *args)


    def read(self, pcData, iLength):
        """read(self, pcData, iLength) -> vpl::tSize"""
        return _Channel.CFileChannel_read(self, pcData, iLength)


    def write(self, pcData, iLength):
        """write(self, pcData, iLength) -> bool"""
        return _Channel.CFileChannel_write(self, pcData, iLength)


    def flush(self):
        """flush(self) -> bool"""
        return _Channel.CFileChannel_flush(self)

    def __disown__(self):
        self.this.disown()
        _Channel.disown_CFileChannel(self)
        return weakref_proxy(self)
CFileChannel_swigregister = _Channel.CFileChannel_swigregister
CFileChannel_swigregister(CFileChannel)

class CFileChannelU(CChannel):
    """Proxy of C++ vpl::mod::CFileChannelU class."""

    __swig_setmethods__ = {}
    for _s in [CChannel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CFileChannelU, name, value)
    __swig_getmethods__ = {}
    for _s in [CChannel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CFileChannelU, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, Type, sFileName) -> CFileChannelU
        __init__(self, Type) -> CFileChannelU
        """
        if self.__class__ == CFileChannelU:
            _self = None
        else:
            _self = self
        this = _Channel.new_CFileChannelU(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Channel.delete_CFileChannelU
    __del__ = lambda self: None

    def setFilename(self, sFileName):
        """setFilename(self, sFileName)"""
        return _Channel.CFileChannelU_setFilename(self, sFileName)


    def connect(self, *args):
        """
        connect(self, uTimeout) -> bool
        connect(self) -> bool
        """
        return _Channel.CFileChannelU_connect(self, *args)


    def listen(self, *args):
        """
        listen(self, uTimeout) -> bool
        listen(self) -> bool
        """
        return _Channel.CFileChannelU_listen(self, *args)


    def disconnect(self):
        """disconnect(self)"""
        return _Channel.CFileChannelU_disconnect(self)


    def isConnected(self):
        """isConnected(self) -> bool"""
        return _Channel.CFileChannelU_isConnected(self)


    def wait(self, *args):
        """
        wait(self, uTimeout) -> bool
        wait(self) -> bool
        """
        return _Channel.CFileChannelU_wait(self, *args)


    def read(self, pcData, iLength):
        """read(self, pcData, iLength) -> vpl::tSize"""
        return _Channel.CFileChannelU_read(self, pcData, iLength)


    def write(self, pcData, iLength):
        """write(self, pcData, iLength) -> bool"""
        return _Channel.CFileChannelU_write(self, pcData, iLength)


    def flush(self):
        """flush(self) -> bool"""
        return _Channel.CFileChannelU_flush(self)

    def __disown__(self):
        self.this.disown()
        _Channel.disown_CFileChannelU(self)
        return weakref_proxy(self)
CFileChannelU_swigregister = _Channel.CFileChannelU_swigregister
CFileChannelU_swigregister(CFileChannelU)

class CPipeChannel(CChannel):
    """Proxy of C++ vpl::mod::CPipeChannel class."""

    __swig_setmethods__ = {}
    for _s in [CChannel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPipeChannel, name, value)
    __swig_getmethods__ = {}
    for _s in [CChannel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPipeChannel, name)
    __repr__ = _swig_repr

    def __init__(self, Type, ssName):
        """__init__(self, Type, ssName) -> CPipeChannel"""
        if self.__class__ == CPipeChannel:
            _self = None
        else:
            _self = self
        this = _Channel.new_CPipeChannel(_self, Type, ssName)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Channel.delete_CPipeChannel
    __del__ = lambda self: None

    def connect(self, *args):
        """
        connect(self, uTimeout) -> bool
        connect(self) -> bool
        """
        return _Channel.CPipeChannel_connect(self, *args)


    def listen(self, *args):
        """
        listen(self, uTimeout) -> bool
        listen(self) -> bool
        """
        return _Channel.CPipeChannel_listen(self, *args)


    def disconnect(self):
        """disconnect(self)"""
        return _Channel.CPipeChannel_disconnect(self)


    def isConnected(self):
        """isConnected(self) -> bool"""
        return _Channel.CPipeChannel_isConnected(self)


    def wait(self, *args):
        """
        wait(self, uTimeout) -> bool
        wait(self) -> bool
        """
        return _Channel.CPipeChannel_wait(self, *args)


    def read(self, pcData, iLength):
        """read(self, pcData, iLength) -> vpl::tSize"""
        return _Channel.CPipeChannel_read(self, pcData, iLength)


    def write(self, pcData, iLength):
        """write(self, pcData, iLength) -> bool"""
        return _Channel.CPipeChannel_write(self, pcData, iLength)


    def flush(self):
        """flush(self) -> bool"""
        return _Channel.CPipeChannel_flush(self)

    def __disown__(self):
        self.this.disown()
        _Channel.disown_CPipeChannel(self)
        return weakref_proxy(self)
CPipeChannel_swigregister = _Channel.CPipeChannel_swigregister
CPipeChannel_swigregister(CPipeChannel)

class CSharedMemChannel(CChannel):
    """Proxy of C++ vpl::mod::CSharedMemChannel class."""

    __swig_setmethods__ = {}
    for _s in [CChannel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSharedMemChannel, name, value)
    __swig_getmethods__ = {}
    for _s in [CChannel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CSharedMemChannel, name)
    __repr__ = _swig_repr

    def __init__(self, Type, ssName):
        """__init__(self, Type, ssName) -> CSharedMemChannel"""
        if self.__class__ == CSharedMemChannel:
            _self = None
        else:
            _self = self
        this = _Channel.new_CSharedMemChannel(_self, Type, ssName)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Channel.delete_CSharedMemChannel
    __del__ = lambda self: None

    def getSharedMemPtr(self):
        """getSharedMemPtr(self) -> vpl::sys::CSharedMem *"""
        return _Channel.CSharedMemChannel_getSharedMemPtr(self)


    def getDataPtr(self):
        """getDataPtr(self) -> char *"""
        return _Channel.CSharedMemChannel_getDataPtr(self)


    def connect(self, *args):
        """
        connect(self, uTimeout) -> bool
        connect(self) -> bool
        """
        return _Channel.CSharedMemChannel_connect(self, *args)


    def listen(self, *args):
        """
        listen(self, uTimeout) -> bool
        listen(self) -> bool
        """
        return _Channel.CSharedMemChannel_listen(self, *args)


    def disconnect(self):
        """disconnect(self)"""
        return _Channel.CSharedMemChannel_disconnect(self)


    def isConnected(self):
        """isConnected(self) -> bool"""
        return _Channel.CSharedMemChannel_isConnected(self)


    def wait(self, *args):
        """
        wait(self, uTimeout) -> bool
        wait(self) -> bool
        """
        return _Channel.CSharedMemChannel_wait(self, *args)


    def read(self, pcData, iLength):
        """read(self, pcData, iLength) -> vpl::tSize"""
        return _Channel.CSharedMemChannel_read(self, pcData, iLength)


    def write(self, pcData, iLength):
        """write(self, pcData, iLength) -> bool"""
        return _Channel.CSharedMemChannel_write(self, pcData, iLength)


    def flush(self):
        """flush(self) -> bool"""
        return _Channel.CSharedMemChannel_flush(self)


    def skip(self, iLength):
        """skip(self, iLength) -> bool"""
        return _Channel.CSharedMemChannel_skip(self, iLength)

    def __disown__(self):
        self.this.disown()
        _Channel.disown_CSharedMemChannel(self)
        return weakref_proxy(self)
CSharedMemChannel_swigregister = _Channel.CSharedMemChannel_swigregister
CSharedMemChannel_swigregister(CSharedMemChannel)


def write_Image8(Object, Channel, iFlags=0):
    """
    write_Image8(Object, Channel, iFlags=0) -> bool
    write_Image8(Object, Channel) -> bool
    """
    return _Channel.write_Image8(Object, Channel, iFlags)

def read_Image8(Object, Channel, iFlags=0):
    """
    read_Image8(Object, Channel, iFlags=0) -> bool
    read_Image8(Object, Channel) -> bool
    """
    return _Channel.read_Image8(Object, Channel, iFlags)

def Write_Image16(Object, Channel, iFlags=0):
    """
    Write_Image16(Object, Channel, iFlags=0) -> bool
    Write_Image16(Object, Channel) -> bool
    """
    return _Channel.Write_Image16(Object, Channel, iFlags)

def Read_Image16(Object, Channel, iFlags=0):
    """
    Read_Image16(Object, Channel, iFlags=0) -> bool
    Read_Image16(Object, Channel) -> bool
    """
    return _Channel.Read_Image16(Object, Channel, iFlags)

def Write_Image32(Object, Channel, iFlags=0):
    """
    Write_Image32(Object, Channel, iFlags=0) -> bool
    Write_Image32(Object, Channel) -> bool
    """
    return _Channel.Write_Image32(Object, Channel, iFlags)

def Read_Image32(Object, Channel, iFlags=0):
    """
    Read_Image32(Object, Channel, iFlags=0) -> bool
    Read_Image32(Object, Channel) -> bool
    """
    return _Channel.Read_Image32(Object, Channel, iFlags)

def Write_FImage(Object, Channel, iFlags=0):
    """
    Write_FImage(Object, Channel, iFlags=0) -> bool
    Write_FImage(Object, Channel) -> bool
    """
    return _Channel.Write_FImage(Object, Channel, iFlags)

def Read_FImage(Object, Channel, iFlags=0):
    """
    Read_FImage(Object, Channel, iFlags=0) -> bool
    Read_FImage(Object, Channel) -> bool
    """
    return _Channel.Read_FImage(Object, Channel, iFlags)

def Write_DImage(Object, Channel, iFlags=0):
    """
    Write_DImage(Object, Channel, iFlags=0) -> bool
    Write_DImage(Object, Channel) -> bool
    """
    return _Channel.Write_DImage(Object, Channel, iFlags)

def Read_DImage(Object, Channel, iFlags=0):
    """
    Read_DImage(Object, Channel, iFlags=0) -> bool
    Read_DImage(Object, Channel) -> bool
    """
    return _Channel.Read_DImage(Object, Channel, iFlags)

def Write_RGBAImage(Object, Channel, iFlags=0):
    """
    Write_RGBAImage(Object, Channel, iFlags=0) -> bool
    Write_RGBAImage(Object, Channel) -> bool
    """
    return _Channel.Write_RGBAImage(Object, Channel, iFlags)

def Read_RGBAImage(Object, Channel, iFlags=0):
    """
    Read_RGBAImage(Object, Channel, iFlags=0) -> bool
    Read_RGBAImage(Object, Channel) -> bool
    """
    return _Channel.Read_RGBAImage(Object, Channel, iFlags)

def Write_ComplexImage(Object, Channel, iFlags=0):
    """
    Write_ComplexImage(Object, Channel, iFlags=0) -> bool
    Write_ComplexImage(Object, Channel) -> bool
    """
    return _Channel.Write_ComplexImage(Object, Channel, iFlags)

def Read_ComplexImage(Object, Channel, iFlags=0):
    """
    Read_ComplexImage(Object, Channel, iFlags=0) -> bool
    Read_ComplexImage(Object, Channel) -> bool
    """
    return _Channel.Read_ComplexImage(Object, Channel, iFlags)
# This file is compatible with both classic and new-style classes.


