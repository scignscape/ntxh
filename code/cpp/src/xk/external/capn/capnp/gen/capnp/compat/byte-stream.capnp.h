// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: byte-stream.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

//?#if CAPNP_VERSION != 8000
#if CAPNP_VERSION != 9000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(d2e7d8a0dc0a9766);
CAPNP_DECLARE_SCHEMA(b23c0a13cf65c36e);
CAPNP_DECLARE_SCHEMA(ccb18eca8acafbe7);
CAPNP_DECLARE_SCHEMA(ba8feb56b5b6922d);
CAPNP_DECLARE_SCHEMA(d80bf35671585f44);
CAPNP_DECLARE_SCHEMA(ddd06638ed144353);
CAPNP_DECLARE_SCHEMA(a45d8c4c07bb36d2);
CAPNP_DECLARE_SCHEMA(cbd32047945c0144);
CAPNP_DECLARE_SCHEMA(e7e2ddbc3c63d594);
CAPNP_DECLARE_SCHEMA(c5b18e80fc80d9f8);
CAPNP_DECLARE_SCHEMA(8d198ede6d27756a);

}  // namespace schemas
}  // namespace capnp

namespace capnp {

struct ByteStream {
  ByteStream() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct SubstreamCallback;
  struct WriteParams;
  struct EndParams;
  struct EndResults;
  struct GetSubstreamParams;
  struct GetSubstreamResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(d2e7d8a0dc0a9766)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct ByteStream::SubstreamCallback {
  SubstreamCallback() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct EndedParams;
  struct EndedResults;
  struct ReachedLimitParams;
  struct ReachedLimitResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(b23c0a13cf65c36e)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct ByteStream::SubstreamCallback::EndedParams {
  EndedParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ccb18eca8acafbe7, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ByteStream::SubstreamCallback::EndedResults {
  EndedResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba8feb56b5b6922d, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ByteStream::SubstreamCallback::ReachedLimitParams {
  ReachedLimitParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d80bf35671585f44, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ByteStream::SubstreamCallback::ReachedLimitResults {
  ReachedLimitResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ddd06638ed144353, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ByteStream::WriteParams {
  WriteParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a45d8c4c07bb36d2, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ByteStream::EndParams {
  EndParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cbd32047945c0144, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ByteStream::EndResults {
  EndResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7e2ddbc3c63d594, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ByteStream::GetSubstreamParams {
  GetSubstreamParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c5b18e80fc80d9f8, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ByteStream::GetSubstreamResults {
  GetSubstreamResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8d198ede6d27756a, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class ByteStream::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef ByteStream Calls;
  typedef ByteStream Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::StreamingRequest< ::capnp::ByteStream::WriteParams> writeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnp::ByteStream::EndParams,  ::capnp::ByteStream::EndResults> endRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnp::ByteStream::GetSubstreamParams,  ::capnp::ByteStream::GetSubstreamResults> getSubstreamRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class ByteStream::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef ByteStream Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnp::ByteStream::WriteParams WriteParams;
  typedef ::capnp::StreamingCallContext<WriteParams> WriteContext;
  virtual ::kj::Promise<void> write(WriteContext context);
  typedef  ::capnp::ByteStream::EndParams EndParams;
  typedef  ::capnp::ByteStream::EndResults EndResults;
  typedef ::capnp::CallContext<EndParams, EndResults> EndContext;
  virtual ::kj::Promise<void> end(EndContext context);
  typedef  ::capnp::ByteStream::GetSubstreamParams GetSubstreamParams;
  typedef  ::capnp::ByteStream::GetSubstreamResults GetSubstreamResults;
  typedef ::capnp::CallContext<GetSubstreamParams, GetSubstreamResults> GetSubstreamContext;
  virtual ::kj::Promise<void> getSubstream(GetSubstreamContext context);

  inline  ::capnp::ByteStream::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnp::ByteStream>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class ByteStream::SubstreamCallback::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef SubstreamCallback Calls;
  typedef SubstreamCallback Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnp::ByteStream::SubstreamCallback::EndedParams,  ::capnp::ByteStream::SubstreamCallback::EndedResults> endedRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnp::ByteStream::SubstreamCallback::ReachedLimitParams,  ::capnp::ByteStream::SubstreamCallback::ReachedLimitResults> reachedLimitRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class ByteStream::SubstreamCallback::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef SubstreamCallback Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnp::ByteStream::SubstreamCallback::EndedParams EndedParams;
  typedef  ::capnp::ByteStream::SubstreamCallback::EndedResults EndedResults;
  typedef ::capnp::CallContext<EndedParams, EndedResults> EndedContext;
  virtual ::kj::Promise<void> ended(EndedContext context);
  typedef  ::capnp::ByteStream::SubstreamCallback::ReachedLimitParams ReachedLimitParams;
  typedef  ::capnp::ByteStream::SubstreamCallback::ReachedLimitResults ReachedLimitResults;
  typedef ::capnp::CallContext<ReachedLimitParams, ReachedLimitResults> ReachedLimitContext;
  virtual ::kj::Promise<void> reachedLimit(ReachedLimitContext context);

  inline  ::capnp::ByteStream::SubstreamCallback::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnp::ByteStream::SubstreamCallback>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class ByteStream::SubstreamCallback::EndedParams::Reader {
public:
  typedef EndedParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getByteCount() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::SubstreamCallback::EndedParams::Builder {
public:
  typedef EndedParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getByteCount();
  inline void setByteCount( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::SubstreamCallback::EndedParams::Pipeline {
public:
  typedef EndedParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ByteStream::SubstreamCallback::EndedResults::Reader {
public:
  typedef EndedResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::SubstreamCallback::EndedResults::Builder {
public:
  typedef EndedResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::SubstreamCallback::EndedResults::Pipeline {
public:
  typedef EndedResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ByteStream::SubstreamCallback::ReachedLimitParams::Reader {
public:
  typedef ReachedLimitParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::SubstreamCallback::ReachedLimitParams::Builder {
public:
  typedef ReachedLimitParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::SubstreamCallback::ReachedLimitParams::Pipeline {
public:
  typedef ReachedLimitParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ByteStream::SubstreamCallback::ReachedLimitResults::Reader {
public:
  typedef ReachedLimitResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNext() const;
#if !CAPNP_LITE
  inline  ::capnp::ByteStream::Client getNext() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::SubstreamCallback::ReachedLimitResults::Builder {
public:
  typedef ReachedLimitResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNext();
#if !CAPNP_LITE
  inline  ::capnp::ByteStream::Client getNext();
  inline void setNext( ::capnp::ByteStream::Client&& value);
  inline void setNext( ::capnp::ByteStream::Client& value);
  inline void adoptNext(::capnp::Orphan< ::capnp::ByteStream>&& value);
  inline ::capnp::Orphan< ::capnp::ByteStream> disownNext();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::SubstreamCallback::ReachedLimitResults::Pipeline {
public:
  typedef ReachedLimitResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::ByteStream::Client getNext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ByteStream::WriteParams::Reader {
public:
  typedef WriteParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBytes() const;
  inline  ::capnp::Data::Reader getBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::WriteParams::Builder {
public:
  typedef WriteParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBytes();
  inline  ::capnp::Data::Builder getBytes();
  inline void setBytes( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initBytes(unsigned int size);
  inline void adoptBytes(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownBytes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::WriteParams::Pipeline {
public:
  typedef WriteParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ByteStream::EndParams::Reader {
public:
  typedef EndParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::EndParams::Builder {
public:
  typedef EndParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::EndParams::Pipeline {
public:
  typedef EndParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ByteStream::EndResults::Reader {
public:
  typedef EndResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::EndResults::Builder {
public:
  typedef EndResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::EndResults::Pipeline {
public:
  typedef EndResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ByteStream::GetSubstreamParams::Reader {
public:
  typedef GetSubstreamParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCallback() const;
#if !CAPNP_LITE
  inline  ::capnp::ByteStream::SubstreamCallback::Client getCallback() const;
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLimit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::GetSubstreamParams::Builder {
public:
  typedef GetSubstreamParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCallback();
#if !CAPNP_LITE
  inline  ::capnp::ByteStream::SubstreamCallback::Client getCallback();
  inline void setCallback( ::capnp::ByteStream::SubstreamCallback::Client&& value);
  inline void setCallback( ::capnp::ByteStream::SubstreamCallback::Client& value);
  inline void adoptCallback(::capnp::Orphan< ::capnp::ByteStream::SubstreamCallback>&& value);
  inline ::capnp::Orphan< ::capnp::ByteStream::SubstreamCallback> disownCallback();
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLimit();
  inline void setLimit( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::GetSubstreamParams::Pipeline {
public:
  typedef GetSubstreamParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::ByteStream::SubstreamCallback::Client getCallback();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ByteStream::GetSubstreamResults::Reader {
public:
  typedef GetSubstreamResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSubstream() const;
#if !CAPNP_LITE
  inline  ::capnp::ByteStream::Client getSubstream() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ByteStream::GetSubstreamResults::Builder {
public:
  typedef GetSubstreamResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSubstream();
#if !CAPNP_LITE
  inline  ::capnp::ByteStream::Client getSubstream();
  inline void setSubstream( ::capnp::ByteStream::Client&& value);
  inline void setSubstream( ::capnp::ByteStream::Client& value);
  inline void adoptSubstream(::capnp::Orphan< ::capnp::ByteStream>&& value);
  inline ::capnp::Orphan< ::capnp::ByteStream> disownSubstream();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ByteStream::GetSubstreamResults::Pipeline {
public:
  typedef GetSubstreamResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::ByteStream::Client getSubstream();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline ByteStream::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline ByteStream::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline ByteStream::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline ByteStream::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline ByteStream::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnp::ByteStream::Client& ByteStream::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnp::ByteStream::Client& ByteStream::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline ByteStream::SubstreamCallback::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline ByteStream::SubstreamCallback::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline ByteStream::SubstreamCallback::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline ByteStream::SubstreamCallback::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline ByteStream::SubstreamCallback::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnp::ByteStream::SubstreamCallback::Client& ByteStream::SubstreamCallback::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnp::ByteStream::SubstreamCallback::Client& ByteStream::SubstreamCallback::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint64_t ByteStream::SubstreamCallback::EndedParams::Reader::getByteCount() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t ByteStream::SubstreamCallback::EndedParams::Builder::getByteCount() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ByteStream::SubstreamCallback::EndedParams::Builder::setByteCount( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ByteStream::SubstreamCallback::ReachedLimitResults::Reader::hasNext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ByteStream::SubstreamCallback::ReachedLimitResults::Builder::hasNext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::ByteStream::Client ByteStream::SubstreamCallback::ReachedLimitResults::Reader::getNext() const {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::ByteStream::Client ByteStream::SubstreamCallback::ReachedLimitResults::Builder::getNext() {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::ByteStream::Client ByteStream::SubstreamCallback::ReachedLimitResults::Pipeline::getNext() {
  return  ::capnp::ByteStream::Client(_typeless.getPointerField(0).asCap());
}
inline void ByteStream::SubstreamCallback::ReachedLimitResults::Builder::setNext( ::capnp::ByteStream::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void ByteStream::SubstreamCallback::ReachedLimitResults::Builder::setNext( ::capnp::ByteStream::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void ByteStream::SubstreamCallback::ReachedLimitResults::Builder::adoptNext(
    ::capnp::Orphan< ::capnp::ByteStream>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::ByteStream> ByteStream::SubstreamCallback::ReachedLimitResults::Builder::disownNext() {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool ByteStream::WriteParams::Reader::hasBytes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ByteStream::WriteParams::Builder::hasBytes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader ByteStream::WriteParams::Reader::getBytes() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder ByteStream::WriteParams::Builder::getBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ByteStream::WriteParams::Builder::setBytes( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder ByteStream::WriteParams::Builder::initBytes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ByteStream::WriteParams::Builder::adoptBytes(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> ByteStream::WriteParams::Builder::disownBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ByteStream::GetSubstreamParams::Reader::hasCallback() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ByteStream::GetSubstreamParams::Builder::hasCallback() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::ByteStream::SubstreamCallback::Client ByteStream::GetSubstreamParams::Reader::getCallback() const {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream::SubstreamCallback>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::ByteStream::SubstreamCallback::Client ByteStream::GetSubstreamParams::Builder::getCallback() {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream::SubstreamCallback>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::ByteStream::SubstreamCallback::Client ByteStream::GetSubstreamParams::Pipeline::getCallback() {
  return  ::capnp::ByteStream::SubstreamCallback::Client(_typeless.getPointerField(0).asCap());
}
inline void ByteStream::GetSubstreamParams::Builder::setCallback( ::capnp::ByteStream::SubstreamCallback::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream::SubstreamCallback>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void ByteStream::GetSubstreamParams::Builder::setCallback( ::capnp::ByteStream::SubstreamCallback::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream::SubstreamCallback>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void ByteStream::GetSubstreamParams::Builder::adoptCallback(
    ::capnp::Orphan< ::capnp::ByteStream::SubstreamCallback>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream::SubstreamCallback>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::ByteStream::SubstreamCallback> ByteStream::GetSubstreamParams::Builder::disownCallback() {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream::SubstreamCallback>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint64_t ByteStream::GetSubstreamParams::Reader::getLimit() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 18446744073709551615ull);
}

inline  ::uint64_t ByteStream::GetSubstreamParams::Builder::getLimit() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 18446744073709551615ull);
}
inline void ByteStream::GetSubstreamParams::Builder::setLimit( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 18446744073709551615ull);
}

inline bool ByteStream::GetSubstreamResults::Reader::hasSubstream() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ByteStream::GetSubstreamResults::Builder::hasSubstream() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::ByteStream::Client ByteStream::GetSubstreamResults::Reader::getSubstream() const {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::ByteStream::Client ByteStream::GetSubstreamResults::Builder::getSubstream() {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::ByteStream::Client ByteStream::GetSubstreamResults::Pipeline::getSubstream() {
  return  ::capnp::ByteStream::Client(_typeless.getPointerField(0).asCap());
}
inline void ByteStream::GetSubstreamResults::Builder::setSubstream( ::capnp::ByteStream::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void ByteStream::GetSubstreamResults::Builder::setSubstream( ::capnp::ByteStream::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void ByteStream::GetSubstreamResults::Builder::adoptSubstream(
    ::capnp::Orphan< ::capnp::ByteStream>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::ByteStream>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::ByteStream> ByteStream::GetSubstreamResults::Builder::disownSubstream() {
  return ::capnp::_::PointerHelpers< ::capnp::ByteStream>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

}  // namespace

