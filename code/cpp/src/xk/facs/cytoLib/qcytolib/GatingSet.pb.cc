// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GatingSet.proto

#include "cytolib/GatingSet.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BOOL_GATE_OP_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_COMP_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CytoFrame_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PARAM_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_POPINDICES_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_POPSTATS_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TRANS_TBL_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_biexpTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_boolGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_calibrationTable_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_clusterGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_coordinate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ellipseGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_fasinhTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_flinTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_gate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_logGML2Trans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_logTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_logicleTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_nodeProperties_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_paramPoly_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_paramRange_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_polygonGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_populationTree_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_quadGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_rangeGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_scaleTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_trans_local_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_trans_pair_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_transformation_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_treeNodes_GatingSet_2eproto;
namespace pb {
class paramRangeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<paramRange> _instance;
} _paramRange_default_instance_;
class rangeGateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<rangeGate> _instance;
} _rangeGate_default_instance_;
class paramPolyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<paramPoly> _instance;
} _paramPoly_default_instance_;
class polygonGateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<polygonGate> _instance;
} _polygonGate_default_instance_;
class coordinateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<coordinate> _instance;
} _coordinate_default_instance_;
class ellipseGateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ellipseGate> _instance;
} _ellipseGate_default_instance_;
class BOOL_GATE_OPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BOOL_GATE_OP> _instance;
} _BOOL_GATE_OP_default_instance_;
class boolGateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<boolGate> _instance;
} _boolGate_default_instance_;
class clusterGateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<clusterGate> _instance;
} _clusterGate_default_instance_;
class quadGateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<quadGate> _instance;
} _quadGate_default_instance_;
class gateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<gate> _instance;
} _gate_default_instance_;
class POPSTATSDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<POPSTATS> _instance;
} _POPSTATS_default_instance_;
class calibrationTableDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<calibrationTable> _instance;
} _calibrationTable_default_instance_;
class biexpTransDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<biexpTrans> _instance;
} _biexpTrans_default_instance_;
class fasinhTransDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<fasinhTrans> _instance;
} _fasinhTrans_default_instance_;
class scaleTransDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<scaleTrans> _instance;
} _scaleTrans_default_instance_;
class flinTransDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<flinTrans> _instance;
} _flinTrans_default_instance_;
class logTransDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<logTrans> _instance;
} _logTrans_default_instance_;
class logGML2TransDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<logGML2Trans> _instance;
} _logGML2Trans_default_instance_;
class logicleTransDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<logicleTrans> _instance;
} _logicleTrans_default_instance_;
class transformationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<transformation> _instance;
} _transformation_default_instance_;
class trans_pairDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<trans_pair> _instance;
} _trans_pair_default_instance_;
class trans_localDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<trans_local> _instance;
} _trans_local_default_instance_;
class POPINDICESDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<POPINDICES> _instance;
} _POPINDICES_default_instance_;
class nodePropertiesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<nodeProperties> _instance;
} _nodeProperties_default_instance_;
class treeNodesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<treeNodes> _instance;
} _treeNodes_default_instance_;
class populationTreeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<populationTree> _instance;
} _populationTree_default_instance_;
class COMPDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<COMP> _instance;
} _COMP_default_instance_;
class PARAMDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PARAM> _instance;
} _PARAM_default_instance_;
class GatingHierarchyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GatingHierarchy> _instance;
} _GatingHierarchy_default_instance_;
class CytoFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CytoFrame> _instance;
} _CytoFrame_default_instance_;
class TRANS_TBLDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TRANS_TBL> _instance;
} _TRANS_TBL_default_instance_;
class GatingSetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GatingSet> _instance;
} _GatingSet_default_instance_;
}  // namespace pb
static void InitDefaultsscc_info_BOOL_GATE_OP_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_BOOL_GATE_OP_default_instance_;
    new (ptr) ::pb::BOOL_GATE_OP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::BOOL_GATE_OP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BOOL_GATE_OP_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BOOL_GATE_OP_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_COMP_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_COMP_default_instance_;
    new (ptr) ::pb::COMP();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::COMP::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_COMP_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_COMP_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_CytoFrame_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_CytoFrame_default_instance_;
    new (ptr) ::pb::CytoFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::CytoFrame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CytoFrame_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CytoFrame_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_GatingHierarchy_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_GatingHierarchy_default_instance_;
    new (ptr) ::pb::GatingHierarchy();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::GatingHierarchy::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_GatingHierarchy_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, 0, InitDefaultsscc_info_GatingHierarchy_GatingSet_2eproto}, {
      &scc_info_populationTree_GatingSet_2eproto.base,
      &scc_info_COMP_GatingSet_2eproto.base,
      &scc_info_PARAM_GatingSet_2eproto.base,
      &scc_info_trans_local_GatingSet_2eproto.base,
      &scc_info_CytoFrame_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_GatingSet_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_GatingSet_default_instance_;
    new (ptr) ::pb::GatingSet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::GatingSet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_GatingSet_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_GatingSet_GatingSet_2eproto}, {
      &scc_info_TRANS_TBL_GatingSet_2eproto.base,
      &scc_info_trans_local_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_PARAM_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_PARAM_default_instance_;
    new (ptr) ::pb::PARAM();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::PARAM::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PARAM_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PARAM_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_POPINDICES_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_POPINDICES_default_instance_;
    new (ptr) ::pb::POPINDICES();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::POPINDICES::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_POPINDICES_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_POPINDICES_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_POPSTATS_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_POPSTATS_default_instance_;
    new (ptr) ::pb::POPSTATS();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::POPSTATS::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_POPSTATS_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_POPSTATS_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_TRANS_TBL_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_TRANS_TBL_default_instance_;
    new (ptr) ::pb::TRANS_TBL();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::TRANS_TBL::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TRANS_TBL_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TRANS_TBL_GatingSet_2eproto}, {
      &scc_info_transformation_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_biexpTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_biexpTrans_default_instance_;
    new (ptr) ::pb::biexpTrans();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::biexpTrans::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_biexpTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_biexpTrans_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_boolGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_boolGate_default_instance_;
    new (ptr) ::pb::boolGate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::boolGate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_boolGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_boolGate_GatingSet_2eproto}, {
      &scc_info_BOOL_GATE_OP_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_calibrationTable_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_calibrationTable_default_instance_;
    new (ptr) ::pb::calibrationTable();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::calibrationTable::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_calibrationTable_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_calibrationTable_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_clusterGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_clusterGate_default_instance_;
    new (ptr) ::pb::clusterGate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::clusterGate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_clusterGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_clusterGate_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_coordinate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_coordinate_default_instance_;
    new (ptr) ::pb::coordinate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::coordinate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_coordinate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_coordinate_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_ellipseGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_ellipseGate_default_instance_;
    new (ptr) ::pb::ellipseGate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::ellipseGate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ellipseGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ellipseGate_GatingSet_2eproto}, {
      &scc_info_coordinate_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_fasinhTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_fasinhTrans_default_instance_;
    new (ptr) ::pb::fasinhTrans();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::fasinhTrans::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_fasinhTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_fasinhTrans_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_flinTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_flinTrans_default_instance_;
    new (ptr) ::pb::flinTrans();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::flinTrans::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_flinTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_flinTrans_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_gate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_gate_default_instance_;
    new (ptr) ::pb::gate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::gate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_gate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, 0, InitDefaultsscc_info_gate_GatingSet_2eproto}, {
      &scc_info_rangeGate_GatingSet_2eproto.base,
      &scc_info_polygonGate_GatingSet_2eproto.base,
      &scc_info_ellipseGate_GatingSet_2eproto.base,
      &scc_info_boolGate_GatingSet_2eproto.base,
      &scc_info_clusterGate_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_logGML2Trans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_logGML2Trans_default_instance_;
    new (ptr) ::pb::logGML2Trans();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::logGML2Trans::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_logGML2Trans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_logGML2Trans_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_logTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_logTrans_default_instance_;
    new (ptr) ::pb::logTrans();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::logTrans::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_logTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_logTrans_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_logicleTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_logicleTrans_default_instance_;
    new (ptr) ::pb::logicleTrans();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::logicleTrans::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_logicleTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_logicleTrans_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_nodeProperties_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_nodeProperties_default_instance_;
    new (ptr) ::pb::nodeProperties();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::nodeProperties::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_nodeProperties_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_nodeProperties_GatingSet_2eproto}, {
      &scc_info_POPSTATS_GatingSet_2eproto.base,
      &scc_info_POPINDICES_GatingSet_2eproto.base,
      &scc_info_gate_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_paramPoly_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_paramPoly_default_instance_;
    new (ptr) ::pb::paramPoly();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::paramPoly::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_paramPoly_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_paramPoly_GatingSet_2eproto}, {
      &scc_info_coordinate_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_paramRange_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_paramRange_default_instance_;
    new (ptr) ::pb::paramRange();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::paramRange::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_paramRange_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_paramRange_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_polygonGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_polygonGate_default_instance_;
    new (ptr) ::pb::polygonGate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::polygonGate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_polygonGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_polygonGate_GatingSet_2eproto}, {
      &scc_info_paramPoly_GatingSet_2eproto.base,
      &scc_info_quadGate_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_populationTree_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_populationTree_default_instance_;
    new (ptr) ::pb::populationTree();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::populationTree::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_populationTree_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_populationTree_GatingSet_2eproto}, {
      &scc_info_treeNodes_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_quadGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_quadGate_default_instance_;
    new (ptr) ::pb::quadGate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::quadGate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_quadGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_quadGate_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_rangeGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_rangeGate_default_instance_;
    new (ptr) ::pb::rangeGate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::rangeGate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_rangeGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_rangeGate_GatingSet_2eproto}, {
      &scc_info_paramRange_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_scaleTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_scaleTrans_default_instance_;
    new (ptr) ::pb::scaleTrans();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::scaleTrans::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_scaleTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_scaleTrans_GatingSet_2eproto}, {}};

static void InitDefaultsscc_info_trans_local_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_trans_local_default_instance_;
    new (ptr) ::pb::trans_local();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::trans_local::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_trans_local_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_trans_local_GatingSet_2eproto}, {
      &scc_info_trans_pair_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_trans_pair_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_trans_pair_default_instance_;
    new (ptr) ::pb::trans_pair();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::trans_pair::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_trans_pair_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_trans_pair_GatingSet_2eproto}, {
      &scc_info_transformation_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_transformation_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_transformation_default_instance_;
    new (ptr) ::pb::transformation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::transformation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_transformation_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 8, 0, InitDefaultsscc_info_transformation_GatingSet_2eproto}, {
      &scc_info_calibrationTable_GatingSet_2eproto.base,
      &scc_info_biexpTrans_GatingSet_2eproto.base,
      &scc_info_logTrans_GatingSet_2eproto.base,
      &scc_info_flinTrans_GatingSet_2eproto.base,
      &scc_info_scaleTrans_GatingSet_2eproto.base,
      &scc_info_fasinhTrans_GatingSet_2eproto.base,
      &scc_info_logicleTrans_GatingSet_2eproto.base,
      &scc_info_logGML2Trans_GatingSet_2eproto.base,}};

static void InitDefaultsscc_info_treeNodes_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_treeNodes_default_instance_;
    new (ptr) ::pb::treeNodes();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::treeNodes::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_treeNodes_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_treeNodes_GatingSet_2eproto}, {
      &scc_info_nodeProperties_GatingSet_2eproto.base,}};

namespace pb {
bool QUADRANT_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> QUADRANT_strings[4] = {};

static const char QUADRANT_names[] =
  "Q1"
  "Q2"
  "Q3"
  "Q4";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry QUADRANT_entries[] = {
  { {QUADRANT_names + 0, 2}, 1 },
  { {QUADRANT_names + 2, 2}, 2 },
  { {QUADRANT_names + 4, 2}, 3 },
  { {QUADRANT_names + 6, 2}, 4 },
};

static const int QUADRANT_entries_by_number[] = {
  0, // 1 -> Q1
  1, // 2 -> Q2
  2, // 3 -> Q3
  3, // 4 -> Q4
};

const std::string& QUADRANT_Name(
    QUADRANT value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          QUADRANT_entries,
          QUADRANT_entries_by_number,
          4, QUADRANT_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      QUADRANT_entries,
      QUADRANT_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     QUADRANT_strings[idx].get();
}
bool QUADRANT_Parse(
    const std::string& name, QUADRANT* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      QUADRANT_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<QUADRANT>(int_value);
  }
  return success;
}
bool GATE_TYPE_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GATE_TYPE_strings[9] = {};

static const char GATE_TYPE_names[] =
  "BOOL_GATE"
  "CLUSTER_GATE"
  "ELLIPSE_GATE"
  "ELLIPSOID_GATE"
  "LOGICAL_GATE"
  "POLYGON_GATE"
  "QUAD_GATE"
  "RANGE_GATE"
  "RECT_GATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GATE_TYPE_entries[] = {
  { {GATE_TYPE_names + 0, 9}, 3 },
  { {GATE_TYPE_names + 9, 12}, 8 },
  { {GATE_TYPE_names + 21, 12}, 4 },
  { {GATE_TYPE_names + 33, 14}, 7 },
  { {GATE_TYPE_names + 47, 12}, 6 },
  { {GATE_TYPE_names + 59, 12}, 1 },
  { {GATE_TYPE_names + 71, 9}, 9 },
  { {GATE_TYPE_names + 80, 10}, 2 },
  { {GATE_TYPE_names + 90, 9}, 5 },
};

static const int GATE_TYPE_entries_by_number[] = {
  5, // 1 -> POLYGON_GATE
  7, // 2 -> RANGE_GATE
  0, // 3 -> BOOL_GATE
  2, // 4 -> ELLIPSE_GATE
  8, // 5 -> RECT_GATE
  4, // 6 -> LOGICAL_GATE
  3, // 7 -> ELLIPSOID_GATE
  1, // 8 -> CLUSTER_GATE
  6, // 9 -> QUAD_GATE
};

const std::string& GATE_TYPE_Name(
    GATE_TYPE value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GATE_TYPE_entries,
          GATE_TYPE_entries_by_number,
          9, GATE_TYPE_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GATE_TYPE_entries,
      GATE_TYPE_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GATE_TYPE_strings[idx].get();
}
bool GATE_TYPE_Parse(
    const std::string& name, GATE_TYPE* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GATE_TYPE_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<GATE_TYPE>(int_value);
  }
  return success;
}
bool ind_type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ind_type_strings[3] = {};

static const char ind_type_names[] =
  "BOOL"
  "INT"
  "ROOT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ind_type_entries[] = {
  { {ind_type_names + 0, 4}, 0 },
  { {ind_type_names + 4, 3}, 1 },
  { {ind_type_names + 7, 4}, 2 },
};

static const int ind_type_entries_by_number[] = {
  0, // 0 -> BOOL
  1, // 1 -> INT
  2, // 2 -> ROOT
};

const std::string& ind_type_Name(
    ind_type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ind_type_entries,
          ind_type_entries_by_number,
          3, ind_type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ind_type_entries,
      ind_type_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ind_type_strings[idx].get();
}
bool ind_type_Parse(
    const std::string& name, ind_type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ind_type_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ind_type>(int_value);
  }
  return success;
}
bool TRANS_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TRANS_TYPE_strings[9] = {};

static const char TRANS_TYPE_names[] =
  "PB_BIEXP"
  "PB_CALTBL"
  "PB_FASIGNH"
  "PB_FLIN"
  "PB_LIN"
  "PB_LOG"
  "PB_LOGGML2"
  "PB_LOGICLE"
  "PB_SCALE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TRANS_TYPE_entries[] = {
  { {TRANS_TYPE_names + 0, 8}, 5 },
  { {TRANS_TYPE_names + 8, 9}, 0 },
  { {TRANS_TYPE_names + 17, 10}, 4 },
  { {TRANS_TYPE_names + 27, 7}, 3 },
  { {TRANS_TYPE_names + 34, 6}, 2 },
  { {TRANS_TYPE_names + 40, 6}, 1 },
  { {TRANS_TYPE_names + 46, 10}, 7 },
  { {TRANS_TYPE_names + 56, 10}, 6 },
  { {TRANS_TYPE_names + 66, 8}, 8 },
};

static const int TRANS_TYPE_entries_by_number[] = {
  1, // 0 -> PB_CALTBL
  5, // 1 -> PB_LOG
  4, // 2 -> PB_LIN
  3, // 3 -> PB_FLIN
  2, // 4 -> PB_FASIGNH
  0, // 5 -> PB_BIEXP
  7, // 6 -> PB_LOGICLE
  6, // 7 -> PB_LOGGML2
  8, // 8 -> PB_SCALE
};

const std::string& TRANS_TYPE_Name(
    TRANS_TYPE value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TRANS_TYPE_entries,
          TRANS_TYPE_entries_by_number,
          9, TRANS_TYPE_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TRANS_TYPE_entries,
      TRANS_TYPE_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TRANS_TYPE_strings[idx].get();
}
bool TRANS_TYPE_Parse(
    const std::string& name, TRANS_TYPE* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TRANS_TYPE_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<TRANS_TYPE>(int_value);
  }
  return success;
}

// ===================================================================

void paramRange::InitAsDefaultInstance() {
}
class paramRange::_Internal {
 public:
  using HasBits = decltype(std::declval<paramRange>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

paramRange::paramRange()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.paramRange)
}
paramRange::paramRange(const paramRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&min_, &from.min_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&min_)) + sizeof(max_));
  // @@protoc_insertion_point(copy_constructor:pb.paramRange)
}

void paramRange::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_paramRange_GatingSet_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_) -
      reinterpret_cast<char*>(&min_)) + sizeof(max_));
}

paramRange::~paramRange() {
  // @@protoc_insertion_point(destructor:pb.paramRange)
  SharedDtor();
}

void paramRange::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void paramRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const paramRange& paramRange::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_paramRange_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void paramRange::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.paramRange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_) -
        reinterpret_cast<char*>(&min_)) + sizeof(max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* paramRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float min = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_min(&has_bits);
          min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_max(&has_bits);
          max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* paramRange::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.paramRange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required float min = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_min(), target);
  }

  // required float max = 3;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.paramRange)
  return target;
}

size_t paramRange::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.paramRange)
  size_t total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (has_min()) {
    // required float min = 2;
    total_size += 1 + 4;
  }

  if (has_max()) {
    // required float max = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t paramRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.paramRange)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required float min = 2;
    total_size += 1 + 4;

    // required float max = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void paramRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const paramRange*>(
      &from));
}

void paramRange::MergeFrom(const paramRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.paramRange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      min_ = from.min_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_ = from.max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void paramRange::CopyFrom(const paramRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.paramRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool paramRange::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void paramRange::InternalSwap(paramRange* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(min_, other->min_);
  swap(max_, other->max_);
}

std::string paramRange::GetTypeName() const {
  return "pb.paramRange";
}


// ===================================================================

void rangeGate::InitAsDefaultInstance() {
  ::pb::_rangeGate_default_instance_._instance.get_mutable()->param_ = const_cast< ::pb::paramRange*>(
      ::pb::paramRange::internal_default_instance());
}
class rangeGate::_Internal {
 public:
  using HasBits = decltype(std::declval<rangeGate>()._has_bits_);
  static const ::pb::paramRange& param(const rangeGate* msg);
  static void set_has_param(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::pb::paramRange&
rangeGate::_Internal::param(const rangeGate* msg) {
  return *msg->param_;
}
rangeGate::rangeGate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.rangeGate)
}
rangeGate::rangeGate(const rangeGate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_param()) {
    param_ = new ::pb::paramRange(*from.param_);
  } else {
    param_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pb.rangeGate)
}

void rangeGate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_rangeGate_GatingSet_2eproto.base);
  param_ = nullptr;
}

rangeGate::~rangeGate() {
  // @@protoc_insertion_point(destructor:pb.rangeGate)
  SharedDtor();
}

void rangeGate::SharedDtor() {
  if (this != internal_default_instance()) delete param_;
}

void rangeGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const rangeGate& rangeGate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_rangeGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void rangeGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.rangeGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(param_ != nullptr);
    param_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* rangeGate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .pb.paramRange param = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_param(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* rangeGate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.rangeGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pb.paramRange param = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::param(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.rangeGate)
  return target;
}

size_t rangeGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.rangeGate)
  size_t total_size = 0;

  // required .pb.paramRange param = 1;
  if (has_param()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *param_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void rangeGate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const rangeGate*>(
      &from));
}

void rangeGate::MergeFrom(const rangeGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.rangeGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_param()) {
    _internal_mutable_param()->::pb::paramRange::MergeFrom(from._internal_param());
  }
}

void rangeGate::CopyFrom(const rangeGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.rangeGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool rangeGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_param()) {
    if (!this->param_->IsInitialized()) return false;
  }
  return true;
}

void rangeGate::InternalSwap(rangeGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(param_, other->param_);
}

std::string rangeGate::GetTypeName() const {
  return "pb.rangeGate";
}


// ===================================================================

void paramPoly::InitAsDefaultInstance() {
}
class paramPoly::_Internal {
 public:
  using HasBits = decltype(std::declval<paramPoly>()._has_bits_);
};

paramPoly::paramPoly()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.paramPoly)
}
paramPoly::paramPoly(const paramPoly& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      params_(from.params_),
      vertices_(from.vertices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.paramPoly)
}

void paramPoly::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_paramPoly_GatingSet_2eproto.base);
}

paramPoly::~paramPoly() {
  // @@protoc_insertion_point(destructor:pb.paramPoly)
  SharedDtor();
}

void paramPoly::SharedDtor() {
}

void paramPoly::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const paramPoly& paramPoly::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_paramPoly_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void paramPoly::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.paramPoly)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  params_.Clear();
  vertices_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* paramPoly::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string params = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_params(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pb.coordinate vertices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vertices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* paramPoly::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.paramPoly)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string params = 1;
  for (int i = 0, n = this->_internal_params_size(); i < n; i++) {
    const auto& s = this->_internal_params(i);
    target = stream->WriteString(1, s, target);
  }

  // repeated .pb.coordinate vertices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_vertices_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(2, this->_internal_vertices(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.paramPoly)
  return target;
}

size_t paramPoly::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.paramPoly)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string params = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(params_.size());
  for (int i = 0, n = params_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      params_.Get(i));
  }

  // repeated .pb.coordinate vertices = 2;
  total_size += 1UL * this->_internal_vertices_size();
  for (const auto& msg : this->vertices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void paramPoly::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const paramPoly*>(
      &from));
}

void paramPoly::MergeFrom(const paramPoly& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.paramPoly)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  params_.MergeFrom(from.params_);
  vertices_.MergeFrom(from.vertices_);
}

void paramPoly::CopyFrom(const paramPoly& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.paramPoly)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool paramPoly::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->vertices())) return false;
  return true;
}

void paramPoly::InternalSwap(paramPoly* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  params_.InternalSwap(&other->params_);
  vertices_.InternalSwap(&other->vertices_);
}

std::string paramPoly::GetTypeName() const {
  return "pb.paramPoly";
}


// ===================================================================

void polygonGate::InitAsDefaultInstance() {
  ::pb::_polygonGate_default_instance_._instance.get_mutable()->param_ = const_cast< ::pb::paramPoly*>(
      ::pb::paramPoly::internal_default_instance());
  ::pb::_polygonGate_default_instance_._instance.get_mutable()->qg_ = const_cast< ::pb::quadGate*>(
      ::pb::quadGate::internal_default_instance());
}
class polygonGate::_Internal {
 public:
  using HasBits = decltype(std::declval<polygonGate>()._has_bits_);
  static const ::pb::paramPoly& param(const polygonGate* msg);
  static void set_has_param(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pb::quadGate& qg(const polygonGate* msg);
  static void set_has_qg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pb::paramPoly&
polygonGate::_Internal::param(const polygonGate* msg) {
  return *msg->param_;
}
const ::pb::quadGate&
polygonGate::_Internal::qg(const polygonGate* msg) {
  return *msg->qg_;
}
polygonGate::polygonGate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.polygonGate)
}
polygonGate::polygonGate(const polygonGate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_param()) {
    param_ = new ::pb::paramPoly(*from.param_);
  } else {
    param_ = nullptr;
  }
  if (from._internal_has_qg()) {
    qg_ = new ::pb::quadGate(*from.qg_);
  } else {
    qg_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pb.polygonGate)
}

void polygonGate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_polygonGate_GatingSet_2eproto.base);
  ::memset(&param_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&qg_) -
      reinterpret_cast<char*>(&param_)) + sizeof(qg_));
}

polygonGate::~polygonGate() {
  // @@protoc_insertion_point(destructor:pb.polygonGate)
  SharedDtor();
}

void polygonGate::SharedDtor() {
  if (this != internal_default_instance()) delete param_;
  if (this != internal_default_instance()) delete qg_;
}

void polygonGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const polygonGate& polygonGate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_polygonGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void polygonGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.polygonGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(param_ != nullptr);
      param_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(qg_ != nullptr);
      qg_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* polygonGate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .pb.paramPoly param = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_param(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.quadGate qg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_qg(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* polygonGate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.polygonGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pb.paramPoly param = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::param(this), target, stream);
  }

  // optional .pb.quadGate qg = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::qg(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.polygonGate)
  return target;
}

size_t polygonGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.polygonGate)
  size_t total_size = 0;

  // required .pb.paramPoly param = 1;
  if (has_param()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *param_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pb.quadGate qg = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *qg_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void polygonGate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const polygonGate*>(
      &from));
}

void polygonGate::MergeFrom(const polygonGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.polygonGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_param()->::pb::paramPoly::MergeFrom(from._internal_param());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_qg()->::pb::quadGate::MergeFrom(from._internal_qg());
    }
  }
}

void polygonGate::CopyFrom(const polygonGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.polygonGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool polygonGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_param()) {
    if (!this->param_->IsInitialized()) return false;
  }
  if (has_qg()) {
    if (!this->qg_->IsInitialized()) return false;
  }
  return true;
}

void polygonGate::InternalSwap(polygonGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(param_, other->param_);
  swap(qg_, other->qg_);
}

std::string polygonGate::GetTypeName() const {
  return "pb.polygonGate";
}


// ===================================================================

void coordinate::InitAsDefaultInstance() {
}
class coordinate::_Internal {
 public:
  using HasBits = decltype(std::declval<coordinate>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

coordinate::coordinate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.coordinate)
}
coordinate::coordinate(const coordinate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:pb.coordinate)
}

void coordinate::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

coordinate::~coordinate() {
  // @@protoc_insertion_point(destructor:pb.coordinate)
  SharedDtor();
}

void coordinate::SharedDtor() {
}

void coordinate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const coordinate& coordinate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_coordinate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void coordinate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.coordinate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* coordinate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* coordinate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.coordinate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.coordinate)
  return target;
}

size_t coordinate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.coordinate)
  size_t total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t coordinate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.coordinate)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void coordinate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const coordinate*>(
      &from));
}

void coordinate::MergeFrom(const coordinate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.coordinate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void coordinate::CopyFrom(const coordinate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.coordinate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool coordinate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void coordinate::InternalSwap(coordinate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
}

std::string coordinate::GetTypeName() const {
  return "pb.coordinate";
}


// ===================================================================

void ellipseGate::InitAsDefaultInstance() {
  ::pb::_ellipseGate_default_instance_._instance.get_mutable()->mu_ = const_cast< ::pb::coordinate*>(
      ::pb::coordinate::internal_default_instance());
}
class ellipseGate::_Internal {
 public:
  using HasBits = decltype(std::declval<ellipseGate>()._has_bits_);
  static const ::pb::coordinate& mu(const ellipseGate* msg);
  static void set_has_mu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dist(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pb::coordinate&
ellipseGate::_Internal::mu(const ellipseGate* msg) {
  return *msg->mu_;
}
ellipseGate::ellipseGate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ellipseGate)
}
ellipseGate::ellipseGate(const ellipseGate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      cov_(from.cov_),
      antipodal_vertices_(from.antipodal_vertices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_mu()) {
    mu_ = new ::pb::coordinate(*from.mu_);
  } else {
    mu_ = nullptr;
  }
  dist_ = from.dist_;
  // @@protoc_insertion_point(copy_constructor:pb.ellipseGate)
}

void ellipseGate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ellipseGate_GatingSet_2eproto.base);
  ::memset(&mu_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dist_) -
      reinterpret_cast<char*>(&mu_)) + sizeof(dist_));
}

ellipseGate::~ellipseGate() {
  // @@protoc_insertion_point(destructor:pb.ellipseGate)
  SharedDtor();
}

void ellipseGate::SharedDtor() {
  if (this != internal_default_instance()) delete mu_;
}

void ellipseGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ellipseGate& ellipseGate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ellipseGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void ellipseGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.ellipseGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cov_.Clear();
  antipodal_vertices_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(mu_ != nullptr);
    mu_->Clear();
  }
  dist_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ellipseGate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .pb.coordinate mu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mu(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pb.coordinate cov = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cov(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pb.coordinate antipodal_vertices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_antipodal_vertices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional float dist = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_dist(&has_bits);
          dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ellipseGate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.ellipseGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pb.coordinate mu = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::mu(this), target, stream);
  }

  // repeated .pb.coordinate cov = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cov_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(2, this->_internal_cov(i), target, stream);
  }

  // repeated .pb.coordinate antipodal_vertices = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_antipodal_vertices_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(3, this->_internal_antipodal_vertices(i), target, stream);
  }

  // optional float dist = 4;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_dist(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.ellipseGate)
  return target;
}

size_t ellipseGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.ellipseGate)
  size_t total_size = 0;

  // required .pb.coordinate mu = 1;
  if (has_mu()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mu_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.coordinate cov = 2;
  total_size += 1UL * this->_internal_cov_size();
  for (const auto& msg : this->cov_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pb.coordinate antipodal_vertices = 3;
  total_size += 1UL * this->_internal_antipodal_vertices_size();
  for (const auto& msg : this->antipodal_vertices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional float dist = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ellipseGate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ellipseGate*>(
      &from));
}

void ellipseGate::MergeFrom(const ellipseGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.ellipseGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cov_.MergeFrom(from.cov_);
  antipodal_vertices_.MergeFrom(from.antipodal_vertices_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_mu()->::pb::coordinate::MergeFrom(from._internal_mu());
    }
    if (cached_has_bits & 0x00000002u) {
      dist_ = from.dist_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ellipseGate::CopyFrom(const ellipseGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.ellipseGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ellipseGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->cov())) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->antipodal_vertices())) return false;
  if (has_mu()) {
    if (!this->mu_->IsInitialized()) return false;
  }
  return true;
}

void ellipseGate::InternalSwap(ellipseGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cov_.InternalSwap(&other->cov_);
  antipodal_vertices_.InternalSwap(&other->antipodal_vertices_);
  swap(mu_, other->mu_);
  swap(dist_, other->dist_);
}

std::string ellipseGate::GetTypeName() const {
  return "pb.ellipseGate";
}


// ===================================================================

void BOOL_GATE_OP::InitAsDefaultInstance() {
}
class BOOL_GATE_OP::_Internal {
 public:
  using HasBits = decltype(std::declval<BOOL_GATE_OP>()._has_bits_);
  static void set_has_op(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_isnot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BOOL_GATE_OP::BOOL_GATE_OP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.BOOL_GATE_OP)
}
BOOL_GATE_OP::BOOL_GATE_OP(const BOOL_GATE_OP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      path_(from.path_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&op_, &from.op_,
    static_cast<size_t>(reinterpret_cast<char*>(&isnot_) -
    reinterpret_cast<char*>(&op_)) + sizeof(isnot_));
  // @@protoc_insertion_point(copy_constructor:pb.BOOL_GATE_OP)
}

void BOOL_GATE_OP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BOOL_GATE_OP_GatingSet_2eproto.base);
  ::memset(&op_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isnot_) -
      reinterpret_cast<char*>(&op_)) + sizeof(isnot_));
}

BOOL_GATE_OP::~BOOL_GATE_OP() {
  // @@protoc_insertion_point(destructor:pb.BOOL_GATE_OP)
  SharedDtor();
}

void BOOL_GATE_OP::SharedDtor() {
}

void BOOL_GATE_OP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BOOL_GATE_OP& BOOL_GATE_OP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BOOL_GATE_OP_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void BOOL_GATE_OP::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.BOOL_GATE_OP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&op_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isnot_) -
        reinterpret_cast<char*>(&op_)) + sizeof(isnot_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* BOOL_GATE_OP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_path(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // required uint32 op = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_op(&has_bits);
          op_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool isNot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_isnot(&has_bits);
          isnot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BOOL_GATE_OP::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.BOOL_GATE_OP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string path = 1;
  for (int i = 0, n = this->_internal_path_size(); i < n; i++) {
    const auto& s = this->_internal_path(i);
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // required uint32 op = 2;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_op(), target);
  }

  // required bool isNot = 3;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isnot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.BOOL_GATE_OP)
  return target;
}

size_t BOOL_GATE_OP::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.BOOL_GATE_OP)
  size_t total_size = 0;

  if (has_op()) {
    // required uint32 op = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_op());
  }

  if (has_isnot()) {
    // required bool isNot = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t BOOL_GATE_OP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.BOOL_GATE_OP)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 op = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_op());

    // required bool isNot = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string path = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(path_.size());
  for (int i = 0, n = path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      path_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BOOL_GATE_OP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BOOL_GATE_OP*>(
      &from));
}

void BOOL_GATE_OP::MergeFrom(const BOOL_GATE_OP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.BOOL_GATE_OP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  path_.MergeFrom(from.path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      op_ = from.op_;
    }
    if (cached_has_bits & 0x00000002u) {
      isnot_ = from.isnot_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BOOL_GATE_OP::CopyFrom(const BOOL_GATE_OP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.BOOL_GATE_OP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BOOL_GATE_OP::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void BOOL_GATE_OP::InternalSwap(BOOL_GATE_OP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  path_.InternalSwap(&other->path_);
  swap(op_, other->op_);
  swap(isnot_, other->isnot_);
}

std::string BOOL_GATE_OP::GetTypeName() const {
  return "pb.BOOL_GATE_OP";
}


// ===================================================================

void boolGate::InitAsDefaultInstance() {
}
class boolGate::_Internal {
 public:
  using HasBits = decltype(std::declval<boolGate>()._has_bits_);
};

boolGate::boolGate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.boolGate)
}
boolGate::boolGate(const boolGate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      boolopspec_(from.boolopspec_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.boolGate)
}

void boolGate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_boolGate_GatingSet_2eproto.base);
}

boolGate::~boolGate() {
  // @@protoc_insertion_point(destructor:pb.boolGate)
  SharedDtor();
}

void boolGate::SharedDtor() {
}

void boolGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const boolGate& boolGate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_boolGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void boolGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.boolGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  boolopspec_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* boolGate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_boolopspec(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* boolGate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.boolGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_boolopspec_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(1, this->_internal_boolopspec(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.boolGate)
  return target;
}

size_t boolGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.boolGate)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
  total_size += 1UL * this->_internal_boolopspec_size();
  for (const auto& msg : this->boolopspec_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void boolGate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const boolGate*>(
      &from));
}

void boolGate::MergeFrom(const boolGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.boolGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  boolopspec_.MergeFrom(from.boolopspec_);
}

void boolGate::CopyFrom(const boolGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.boolGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool boolGate::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->boolopspec())) return false;
  return true;
}

void boolGate::InternalSwap(boolGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  boolopspec_.InternalSwap(&other->boolopspec_);
}

std::string boolGate::GetTypeName() const {
  return "pb.boolGate";
}


// ===================================================================

void clusterGate::InitAsDefaultInstance() {
}
class clusterGate::_Internal {
 public:
  using HasBits = decltype(std::declval<clusterGate>()._has_bits_);
  static void set_has_cluster_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

clusterGate::clusterGate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.clusterGate)
}
clusterGate::clusterGate(const clusterGate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cluster_method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_cluster_method()) {
    cluster_method_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cluster_method_);
  }
  // @@protoc_insertion_point(copy_constructor:pb.clusterGate)
}

void clusterGate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_clusterGate_GatingSet_2eproto.base);
  cluster_method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

clusterGate::~clusterGate() {
  // @@protoc_insertion_point(destructor:pb.clusterGate)
  SharedDtor();
}

void clusterGate::SharedDtor() {
  cluster_method_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void clusterGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const clusterGate& clusterGate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_clusterGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void clusterGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.clusterGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    cluster_method_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* clusterGate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string cluster_method = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_cluster_method(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* clusterGate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.clusterGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string cluster_method = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cluster_method(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.clusterGate)
  return target;
}

size_t clusterGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.clusterGate)
  size_t total_size = 0;

  // required string cluster_method = 1;
  if (has_cluster_method()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cluster_method());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void clusterGate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const clusterGate*>(
      &from));
}

void clusterGate::MergeFrom(const clusterGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.clusterGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cluster_method()) {
    _has_bits_[0] |= 0x00000001u;
    cluster_method_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cluster_method_);
  }
}

void clusterGate::CopyFrom(const clusterGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.clusterGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool clusterGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void clusterGate::InternalSwap(clusterGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cluster_method_.Swap(&other->cluster_method_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string clusterGate::GetTypeName() const {
  return "pb.clusterGate";
}


// ===================================================================

void quadGate::InitAsDefaultInstance() {
}
class quadGate::_Internal {
 public:
  using HasBits = decltype(std::declval<quadGate>()._has_bits_);
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_quadrant(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

quadGate::quadGate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.quadGate)
}
quadGate::quadGate(const quadGate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  uid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_uid()) {
    uid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.uid_);
  }
  quadrant_ = from.quadrant_;
  // @@protoc_insertion_point(copy_constructor:pb.quadGate)
}

void quadGate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_quadGate_GatingSet_2eproto.base);
  uid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  quadrant_ = 1;
}

quadGate::~quadGate() {
  // @@protoc_insertion_point(destructor:pb.quadGate)
  SharedDtor();
}

void quadGate::SharedDtor() {
  uid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void quadGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const quadGate& quadGate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_quadGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void quadGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.quadGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      uid_.ClearNonDefaultToEmptyNoArena();
    }
    quadrant_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* quadGate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_uid(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pb.QUADRANT quadrant = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pb::QUADRANT_IsValid(val))) {
            _internal_set_quadrant(static_cast<::pb::QUADRANT>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* quadGate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.quadGate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string uid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_uid(), target);
  }

  // required .pb.QUADRANT quadrant = 3;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_quadrant(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.quadGate)
  return target;
}

size_t quadGate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.quadGate)
  size_t total_size = 0;

  if (has_uid()) {
    // required string uid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uid());
  }

  if (has_quadrant()) {
    // required .pb.QUADRANT quadrant = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_quadrant());
  }

  return total_size;
}
size_t quadGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.quadGate)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string uid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uid());

    // required .pb.QUADRANT quadrant = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_quadrant());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void quadGate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const quadGate*>(
      &from));
}

void quadGate::MergeFrom(const quadGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.quadGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      uid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.uid_);
    }
    if (cached_has_bits & 0x00000002u) {
      quadrant_ = from.quadrant_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void quadGate::CopyFrom(const quadGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.quadGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool quadGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void quadGate::InternalSwap(quadGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uid_.Swap(&other->uid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(quadrant_, other->quadrant_);
}

std::string quadGate::GetTypeName() const {
  return "pb.quadGate";
}


// ===================================================================

void gate::InitAsDefaultInstance() {
  ::pb::_gate_default_instance_._instance.get_mutable()->rg_ = const_cast< ::pb::rangeGate*>(
      ::pb::rangeGate::internal_default_instance());
  ::pb::_gate_default_instance_._instance.get_mutable()->pg_ = const_cast< ::pb::polygonGate*>(
      ::pb::polygonGate::internal_default_instance());
  ::pb::_gate_default_instance_._instance.get_mutable()->eg_ = const_cast< ::pb::ellipseGate*>(
      ::pb::ellipseGate::internal_default_instance());
  ::pb::_gate_default_instance_._instance.get_mutable()->bg_ = const_cast< ::pb::boolGate*>(
      ::pb::boolGate::internal_default_instance());
  ::pb::_gate_default_instance_._instance.get_mutable()->cg_ = const_cast< ::pb::clusterGate*>(
      ::pb::clusterGate::internal_default_instance());
}
class gate::_Internal {
 public:
  using HasBits = decltype(std::declval<gate>()._has_bits_);
  static void set_has_neg(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_istransformed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_isgained(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::pb::rangeGate& rg(const gate* msg);
  static void set_has_rg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pb::polygonGate& pg(const gate* msg);
  static void set_has_pg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pb::ellipseGate& eg(const gate* msg);
  static void set_has_eg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pb::boolGate& bg(const gate* msg);
  static void set_has_bg(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pb::clusterGate& cg(const gate* msg);
  static void set_has_cg(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::pb::rangeGate&
gate::_Internal::rg(const gate* msg) {
  return *msg->rg_;
}
const ::pb::polygonGate&
gate::_Internal::pg(const gate* msg) {
  return *msg->pg_;
}
const ::pb::ellipseGate&
gate::_Internal::eg(const gate* msg) {
  return *msg->eg_;
}
const ::pb::boolGate&
gate::_Internal::bg(const gate* msg) {
  return *msg->bg_;
}
const ::pb::clusterGate&
gate::_Internal::cg(const gate* msg) {
  return *msg->cg_;
}
gate::gate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.gate)
}
gate::gate(const gate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_rg()) {
    rg_ = new ::pb::rangeGate(*from.rg_);
  } else {
    rg_ = nullptr;
  }
  if (from._internal_has_pg()) {
    pg_ = new ::pb::polygonGate(*from.pg_);
  } else {
    pg_ = nullptr;
  }
  if (from._internal_has_eg()) {
    eg_ = new ::pb::ellipseGate(*from.eg_);
  } else {
    eg_ = nullptr;
  }
  if (from._internal_has_bg()) {
    bg_ = new ::pb::boolGate(*from.bg_);
  } else {
    bg_ = nullptr;
  }
  if (from._internal_has_cg()) {
    cg_ = new ::pb::clusterGate(*from.cg_);
  } else {
    cg_ = nullptr;
  }
  ::memcpy(&neg_, &from.neg_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&neg_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:pb.gate)
}

void gate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_gate_GatingSet_2eproto.base);
  ::memset(&rg_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isgained_) -
      reinterpret_cast<char*>(&rg_)) + sizeof(isgained_));
  type_ = 1;
}

gate::~gate() {
  // @@protoc_insertion_point(destructor:pb.gate)
  SharedDtor();
}

void gate::SharedDtor() {
  if (this != internal_default_instance()) delete rg_;
  if (this != internal_default_instance()) delete pg_;
  if (this != internal_default_instance()) delete eg_;
  if (this != internal_default_instance()) delete bg_;
  if (this != internal_default_instance()) delete cg_;
}

void gate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const gate& gate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_gate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void gate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.gate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(rg_ != nullptr);
      rg_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pg_ != nullptr);
      pg_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(eg_ != nullptr);
      eg_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(bg_ != nullptr);
      bg_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(cg_ != nullptr);
      cg_->Clear();
    }
  }
  ::memset(&neg_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isgained_) -
      reinterpret_cast<char*>(&neg_)) + sizeof(isgained_));
  type_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* gate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool neg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_neg(&has_bits);
          neg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool isTransformed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_istransformed(&has_bits);
          istransformed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool isGained = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_isgained(&has_bits);
          isgained_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pb.GATE_TYPE type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pb::GATE_TYPE_IsValid(val))) {
            _internal_set_type(static_cast<::pb::GATE_TYPE>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .pb.rangeGate rg = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rg(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.polygonGate pg = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pg(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.ellipseGate eg = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_eg(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.boolGate bg = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_bg(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.clusterGate cg = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_cg(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* gate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.gate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool neg = 1;
  if (cached_has_bits & 0x00000020u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_neg(), target);
  }

  // required bool isTransformed = 2;
  if (cached_has_bits & 0x00000040u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_istransformed(), target);
  }

  // required bool isGained = 3;
  if (cached_has_bits & 0x00000080u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isgained(), target);
  }

  // required .pb.GATE_TYPE type = 4;
  if (cached_has_bits & 0x00000100u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // optional .pb.rangeGate rg = 5;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::rg(this), target, stream);
  }

  // optional .pb.polygonGate pg = 6;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::pg(this), target, stream);
  }

  // optional .pb.ellipseGate eg = 7;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::eg(this), target, stream);
  }

  // optional .pb.boolGate bg = 8;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, _Internal::bg(this), target, stream);
  }

  // optional .pb.clusterGate cg = 9;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, _Internal::cg(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.gate)
  return target;
}

size_t gate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.gate)
  size_t total_size = 0;

  if (has_neg()) {
    // required bool neg = 1;
    total_size += 1 + 1;
  }

  if (has_istransformed()) {
    // required bool isTransformed = 2;
    total_size += 1 + 1;
  }

  if (has_isgained()) {
    // required bool isGained = 3;
    total_size += 1 + 1;
  }

  if (has_type()) {
    // required .pb.GATE_TYPE type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t gate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.gate)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000001e0) ^ 0x000001e0) == 0) {  // All required fields are present.
    // required bool neg = 1;
    total_size += 1 + 1;

    // required bool isTransformed = 2;
    total_size += 1 + 1;

    // required bool isGained = 3;
    total_size += 1 + 1;

    // required .pb.GATE_TYPE type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .pb.rangeGate rg = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rg_);
    }

    // optional .pb.polygonGate pg = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pg_);
    }

    // optional .pb.ellipseGate eg = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *eg_);
    }

    // optional .pb.boolGate bg = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bg_);
    }

    // optional .pb.clusterGate cg = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cg_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void gate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const gate*>(
      &from));
}

void gate::MergeFrom(const gate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.gate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_rg()->::pb::rangeGate::MergeFrom(from._internal_rg());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_pg()->::pb::polygonGate::MergeFrom(from._internal_pg());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_eg()->::pb::ellipseGate::MergeFrom(from._internal_eg());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_bg()->::pb::boolGate::MergeFrom(from._internal_bg());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_cg()->::pb::clusterGate::MergeFrom(from._internal_cg());
    }
    if (cached_has_bits & 0x00000020u) {
      neg_ = from.neg_;
    }
    if (cached_has_bits & 0x00000040u) {
      istransformed_ = from.istransformed_;
    }
    if (cached_has_bits & 0x00000080u) {
      isgained_ = from.isgained_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_type(from._internal_type());
  }
}

void gate::CopyFrom(const gate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.gate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool gate::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001e0) != 0x000001e0) return false;
  if (has_rg()) {
    if (!this->rg_->IsInitialized()) return false;
  }
  if (has_pg()) {
    if (!this->pg_->IsInitialized()) return false;
  }
  if (has_eg()) {
    if (!this->eg_->IsInitialized()) return false;
  }
  if (has_bg()) {
    if (!this->bg_->IsInitialized()) return false;
  }
  if (has_cg()) {
    if (!this->cg_->IsInitialized()) return false;
  }
  return true;
}

void gate::InternalSwap(gate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(rg_, other->rg_);
  swap(pg_, other->pg_);
  swap(eg_, other->eg_);
  swap(bg_, other->bg_);
  swap(cg_, other->cg_);
  swap(neg_, other->neg_);
  swap(istransformed_, other->istransformed_);
  swap(isgained_, other->isgained_);
  swap(type_, other->type_);
}

std::string gate::GetTypeName() const {
  return "pb.gate";
}


// ===================================================================

void POPSTATS::InitAsDefaultInstance() {
}
class POPSTATS::_Internal {
 public:
  using HasBits = decltype(std::declval<POPSTATS>()._has_bits_);
  static void set_has_stattype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_statval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

POPSTATS::POPSTATS()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.POPSTATS)
}
POPSTATS::POPSTATS(const POPSTATS& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  stattype_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_stattype()) {
    stattype_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.stattype_);
  }
  statval_ = from.statval_;
  // @@protoc_insertion_point(copy_constructor:pb.POPSTATS)
}

void POPSTATS::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_POPSTATS_GatingSet_2eproto.base);
  stattype_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  statval_ = 0;
}

POPSTATS::~POPSTATS() {
  // @@protoc_insertion_point(destructor:pb.POPSTATS)
  SharedDtor();
}

void POPSTATS::SharedDtor() {
  stattype_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void POPSTATS::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const POPSTATS& POPSTATS::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_POPSTATS_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void POPSTATS::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.POPSTATS)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    stattype_.ClearNonDefaultToEmptyNoArena();
  }
  statval_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* POPSTATS::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string statType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_stattype(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float statVal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_statval(&has_bits);
          statval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* POPSTATS::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.POPSTATS)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string statType = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stattype(), target);
  }

  // required float statVal = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_statval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.POPSTATS)
  return target;
}

size_t POPSTATS::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.POPSTATS)
  size_t total_size = 0;

  if (has_stattype()) {
    // required string statType = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stattype());
  }

  if (has_statval()) {
    // required float statVal = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t POPSTATS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.POPSTATS)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string statType = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stattype());

    // required float statVal = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void POPSTATS::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const POPSTATS*>(
      &from));
}

void POPSTATS::MergeFrom(const POPSTATS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.POPSTATS)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      stattype_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.stattype_);
    }
    if (cached_has_bits & 0x00000002u) {
      statval_ = from.statval_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void POPSTATS::CopyFrom(const POPSTATS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.POPSTATS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool POPSTATS::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void POPSTATS::InternalSwap(POPSTATS* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  stattype_.Swap(&other->stattype_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(statval_, other->statval_);
}

std::string POPSTATS::GetTypeName() const {
  return "pb.POPSTATS";
}


// ===================================================================

void calibrationTable::InitAsDefaultInstance() {
}
class calibrationTable::_Internal {
 public:
  using HasBits = decltype(std::declval<calibrationTable>()._has_bits_);
  static void set_has_spline_method(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_caltype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

calibrationTable::calibrationTable()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.calibrationTable)
}
calibrationTable::calibrationTable(const calibrationTable& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      x_(from.x_),
      y_(from.y_),
      b_(from.b_),
      c_(from.c_),
      d_(from.d_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  caltype_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_caltype()) {
    caltype_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.caltype_);
  }
  ::memcpy(&spline_method_, &from.spline_method_,
    static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&spline_method_)) + sizeof(flag_));
  // @@protoc_insertion_point(copy_constructor:pb.calibrationTable)
}

void calibrationTable::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_calibrationTable_GatingSet_2eproto.base);
  caltype_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&spline_method_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flag_) -
      reinterpret_cast<char*>(&spline_method_)) + sizeof(flag_));
}

calibrationTable::~calibrationTable() {
  // @@protoc_insertion_point(destructor:pb.calibrationTable)
  SharedDtor();
}

void calibrationTable::SharedDtor() {
  caltype_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void calibrationTable::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const calibrationTable& calibrationTable::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_calibrationTable_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void calibrationTable::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.calibrationTable)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  x_.Clear();
  y_.Clear();
  b_.Clear();
  c_.Clear();
  d_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    caltype_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&spline_method_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flag_) -
        reinterpret_cast<char*>(&spline_method_)) + sizeof(flag_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* calibrationTable::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated float x = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_x(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13) {
          _internal_add_x(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated float y = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_y(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21) {
          _internal_add_y(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated float b = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_b(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29) {
          _internal_add_b(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated float c = 4 [packed = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_c(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37) {
          _internal_add_c(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated float d = 5 [packed = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_d(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45) {
          _internal_add_d(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 spline_method = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_spline_method(&has_bits);
          spline_method_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string caltype = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_caltype(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool flag = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_flag(&has_bits);
          flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* calibrationTable::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.calibrationTable)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float x = 1 [packed = true];
  if (this->_internal_x_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_x(), target);
  }

  // repeated float y = 2 [packed = true];
  if (this->_internal_y_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_y(), target);
  }

  // repeated float b = 3 [packed = true];
  if (this->_internal_b_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_b(), target);
  }

  // repeated float c = 4 [packed = true];
  if (this->_internal_c_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_c(), target);
  }

  // repeated float d = 5 [packed = true];
  if (this->_internal_d_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_d(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 spline_method = 6;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_spline_method(), target);
  }

  // optional string caltype = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_caltype(), target);
  }

  // optional bool flag = 8;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.calibrationTable)
  return target;
}

size_t calibrationTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.calibrationTable)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float x = 1 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_x_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _x_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float y = 2 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_y_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _y_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float b = 3 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_b_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _b_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float c = 4 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_c_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _c_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float d = 5 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_d_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _d_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string caltype = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_caltype());
    }

    // optional uint32 spline_method = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_spline_method());
    }

    // optional bool flag = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void calibrationTable::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const calibrationTable*>(
      &from));
}

void calibrationTable::MergeFrom(const calibrationTable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.calibrationTable)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  x_.MergeFrom(from.x_);
  y_.MergeFrom(from.y_);
  b_.MergeFrom(from.b_);
  c_.MergeFrom(from.c_);
  d_.MergeFrom(from.d_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      caltype_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.caltype_);
    }
    if (cached_has_bits & 0x00000002u) {
      spline_method_ = from.spline_method_;
    }
    if (cached_has_bits & 0x00000004u) {
      flag_ = from.flag_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void calibrationTable::CopyFrom(const calibrationTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.calibrationTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool calibrationTable::IsInitialized() const {
  return true;
}

void calibrationTable::InternalSwap(calibrationTable* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  x_.InternalSwap(&other->x_);
  y_.InternalSwap(&other->y_);
  b_.InternalSwap(&other->b_);
  c_.InternalSwap(&other->c_);
  d_.InternalSwap(&other->d_);
  caltype_.Swap(&other->caltype_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(spline_method_, other->spline_method_);
  swap(flag_, other->flag_);
}

std::string calibrationTable::GetTypeName() const {
  return "pb.calibrationTable";
}


// ===================================================================

void biexpTrans::InitAsDefaultInstance() {
}
class biexpTrans::_Internal {
 public:
  using HasBits = decltype(std::declval<biexpTrans>()._has_bits_);
  static void set_has_channelrange(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_neg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_widthbasis(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_maxvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

biexpTrans::biexpTrans()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.biexpTrans)
}
biexpTrans::biexpTrans(const biexpTrans& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&channelrange_, &from.channelrange_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&channelrange_)) + sizeof(maxvalue_));
  // @@protoc_insertion_point(copy_constructor:pb.biexpTrans)
}

void biexpTrans::SharedCtor() {
  ::memset(&channelrange_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxvalue_) -
      reinterpret_cast<char*>(&channelrange_)) + sizeof(maxvalue_));
}

biexpTrans::~biexpTrans() {
  // @@protoc_insertion_point(destructor:pb.biexpTrans)
  SharedDtor();
}

void biexpTrans::SharedDtor() {
}

void biexpTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const biexpTrans& biexpTrans::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_biexpTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void biexpTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.biexpTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&channelrange_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&maxvalue_) -
        reinterpret_cast<char*>(&channelrange_)) + sizeof(maxvalue_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* biexpTrans::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 channelRange = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_channelrange(&has_bits);
          channelrange_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float neg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_neg(&has_bits);
          neg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float widthBasis = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_widthbasis(&has_bits);
          widthbasis_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float maxValue = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_maxvalue(&has_bits);
          maxvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* biexpTrans::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.biexpTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 channelRange = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_channelrange(), target);
  }

  // optional float pos = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_pos(), target);
  }

  // optional float neg = 3;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_neg(), target);
  }

  // optional float widthBasis = 4;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_widthbasis(), target);
  }

  // optional float maxValue = 5;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_maxvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.biexpTrans)
  return target;
}

size_t biexpTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.biexpTrans)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 channelRange = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_channelrange());
    }

    // optional float pos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float neg = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float widthBasis = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float maxValue = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void biexpTrans::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const biexpTrans*>(
      &from));
}

void biexpTrans::MergeFrom(const biexpTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.biexpTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      channelrange_ = from.channelrange_;
    }
    if (cached_has_bits & 0x00000002u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000004u) {
      neg_ = from.neg_;
    }
    if (cached_has_bits & 0x00000008u) {
      widthbasis_ = from.widthbasis_;
    }
    if (cached_has_bits & 0x00000010u) {
      maxvalue_ = from.maxvalue_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void biexpTrans::CopyFrom(const biexpTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.biexpTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool biexpTrans::IsInitialized() const {
  return true;
}

void biexpTrans::InternalSwap(biexpTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(channelrange_, other->channelrange_);
  swap(pos_, other->pos_);
  swap(neg_, other->neg_);
  swap(widthbasis_, other->widthbasis_);
  swap(maxvalue_, other->maxvalue_);
}

std::string biexpTrans::GetTypeName() const {
  return "pb.biexpTrans";
}


// ===================================================================

void fasinhTrans::InitAsDefaultInstance() {
}
class fasinhTrans::_Internal {
 public:
  using HasBits = decltype(std::declval<fasinhTrans>()._has_bits_);
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maxrange(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_t(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_a(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

fasinhTrans::fasinhTrans()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.fasinhTrans)
}
fasinhTrans::fasinhTrans(const fasinhTrans& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&length_, &from.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_) -
    reinterpret_cast<char*>(&length_)) + sizeof(m_));
  // @@protoc_insertion_point(copy_constructor:pb.fasinhTrans)
}

void fasinhTrans::SharedCtor() {
  ::memset(&length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_) -
      reinterpret_cast<char*>(&length_)) + sizeof(m_));
}

fasinhTrans::~fasinhTrans() {
  // @@protoc_insertion_point(destructor:pb.fasinhTrans)
  SharedDtor();
}

void fasinhTrans::SharedDtor() {
}

void fasinhTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const fasinhTrans& fasinhTrans::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_fasinhTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void fasinhTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.fasinhTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&m_) -
        reinterpret_cast<char*>(&length_)) + sizeof(m_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* fasinhTrans::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float maxRange = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_maxrange(&has_bits);
          maxrange_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float T = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_t(&has_bits);
          t_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float A = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_a(&has_bits);
          a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float M = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_m(&has_bits);
          m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* fasinhTrans::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.fasinhTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float length = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_length(), target);
  }

  // optional float maxRange = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_maxrange(), target);
  }

  // optional float T = 3;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_t(), target);
  }

  // optional float A = 4;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_a(), target);
  }

  // optional float M = 5;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_m(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.fasinhTrans)
  return target;
}

size_t fasinhTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.fasinhTrans)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float length = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float maxRange = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float T = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float A = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float M = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void fasinhTrans::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const fasinhTrans*>(
      &from));
}

void fasinhTrans::MergeFrom(const fasinhTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.fasinhTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000002u) {
      maxrange_ = from.maxrange_;
    }
    if (cached_has_bits & 0x00000004u) {
      t_ = from.t_;
    }
    if (cached_has_bits & 0x00000008u) {
      a_ = from.a_;
    }
    if (cached_has_bits & 0x00000010u) {
      m_ = from.m_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void fasinhTrans::CopyFrom(const fasinhTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.fasinhTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool fasinhTrans::IsInitialized() const {
  return true;
}

void fasinhTrans::InternalSwap(fasinhTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(length_, other->length_);
  swap(maxrange_, other->maxrange_);
  swap(t_, other->t_);
  swap(a_, other->a_);
  swap(m_, other->m_);
}

std::string fasinhTrans::GetTypeName() const {
  return "pb.fasinhTrans";
}


// ===================================================================

void scaleTrans::InitAsDefaultInstance() {
}
class scaleTrans::_Internal {
 public:
  using HasBits = decltype(std::declval<scaleTrans>()._has_bits_);
  static void set_has_scale_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_t_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_r_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

scaleTrans::scaleTrans()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.scaleTrans)
}
scaleTrans::scaleTrans(const scaleTrans& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&scale_factor_, &from.scale_factor_,
    static_cast<size_t>(reinterpret_cast<char*>(&r_scale_) -
    reinterpret_cast<char*>(&scale_factor_)) + sizeof(r_scale_));
  // @@protoc_insertion_point(copy_constructor:pb.scaleTrans)
}

void scaleTrans::SharedCtor() {
  ::memset(&scale_factor_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&r_scale_) -
      reinterpret_cast<char*>(&scale_factor_)) + sizeof(r_scale_));
}

scaleTrans::~scaleTrans() {
  // @@protoc_insertion_point(destructor:pb.scaleTrans)
  SharedDtor();
}

void scaleTrans::SharedDtor() {
}

void scaleTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const scaleTrans& scaleTrans::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_scaleTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void scaleTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.scaleTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&scale_factor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&r_scale_) -
        reinterpret_cast<char*>(&scale_factor_)) + sizeof(r_scale_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* scaleTrans::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float scale_factor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_scale_factor(&has_bits);
          scale_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float t_scale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_t_scale(&has_bits);
          t_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float r_scale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_r_scale(&has_bits);
          r_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* scaleTrans::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.scaleTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float scale_factor = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_scale_factor(), target);
  }

  // optional float t_scale = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_t_scale(), target);
  }

  // optional float r_scale = 3;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_r_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.scaleTrans)
  return target;
}

size_t scaleTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.scaleTrans)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float scale_factor = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float t_scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float r_scale = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void scaleTrans::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const scaleTrans*>(
      &from));
}

void scaleTrans::MergeFrom(const scaleTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.scaleTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      scale_factor_ = from.scale_factor_;
    }
    if (cached_has_bits & 0x00000002u) {
      t_scale_ = from.t_scale_;
    }
    if (cached_has_bits & 0x00000004u) {
      r_scale_ = from.r_scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void scaleTrans::CopyFrom(const scaleTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.scaleTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool scaleTrans::IsInitialized() const {
  return true;
}

void scaleTrans::InternalSwap(scaleTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(scale_factor_, other->scale_factor_);
  swap(t_scale_, other->t_scale_);
  swap(r_scale_, other->r_scale_);
}

std::string scaleTrans::GetTypeName() const {
  return "pb.scaleTrans";
}


// ===================================================================

void flinTrans::InitAsDefaultInstance() {
}
class flinTrans::_Internal {
 public:
  using HasBits = decltype(std::declval<flinTrans>()._has_bits_);
  static void set_has_min(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

flinTrans::flinTrans()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.flinTrans)
}
flinTrans::flinTrans(const flinTrans& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&min_, &from.min_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&min_)) + sizeof(max_));
  // @@protoc_insertion_point(copy_constructor:pb.flinTrans)
}

void flinTrans::SharedCtor() {
  ::memset(&min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_) -
      reinterpret_cast<char*>(&min_)) + sizeof(max_));
}

flinTrans::~flinTrans() {
  // @@protoc_insertion_point(destructor:pb.flinTrans)
  SharedDtor();
}

void flinTrans::SharedDtor() {
}

void flinTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const flinTrans& flinTrans::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_flinTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void flinTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.flinTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_) -
        reinterpret_cast<char*>(&min_)) + sizeof(max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* flinTrans::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float min = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_min(&has_bits);
          min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_max(&has_bits);
          max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* flinTrans::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.flinTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float min = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_min(), target);
  }

  // optional float max = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.flinTrans)
  return target;
}

size_t flinTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.flinTrans)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float min = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float max = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void flinTrans::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const flinTrans*>(
      &from));
}

void flinTrans::MergeFrom(const flinTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.flinTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      min_ = from.min_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_ = from.max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void flinTrans::CopyFrom(const flinTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.flinTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool flinTrans::IsInitialized() const {
  return true;
}

void flinTrans::InternalSwap(flinTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(min_, other->min_);
  swap(max_, other->max_);
}

std::string flinTrans::GetTypeName() const {
  return "pb.flinTrans";
}


// ===================================================================

void logTrans::InitAsDefaultInstance() {
}
class logTrans::_Internal {
 public:
  using HasBits = decltype(std::declval<logTrans>()._has_bits_);
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_decade(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_t(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

logTrans::logTrans()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.logTrans)
}
logTrans::logTrans(const logTrans& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(scale_));
  // @@protoc_insertion_point(copy_constructor:pb.logTrans)
}

void logTrans::SharedCtor() {
  ::memset(&offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&scale_) -
      reinterpret_cast<char*>(&offset_)) + sizeof(scale_));
}

logTrans::~logTrans() {
  // @@protoc_insertion_point(destructor:pb.logTrans)
  SharedDtor();
}

void logTrans::SharedDtor() {
}

void logTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const logTrans& logTrans::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_logTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void logTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.logTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scale_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(scale_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* logTrans::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float offset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float decade = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_decade(&has_bits);
          decade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float T = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_t(&has_bits);
          t_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float scale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* logTrans::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.logTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float offset = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_offset(), target);
  }

  // optional float decade = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_decade(), target);
  }

  // optional float T = 3;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_t(), target);
  }

  // optional float scale = 4;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.logTrans)
  return target;
}

size_t logTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.logTrans)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional float offset = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float decade = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float T = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float scale = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void logTrans::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const logTrans*>(
      &from));
}

void logTrans::MergeFrom(const logTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.logTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000002u) {
      decade_ = from.decade_;
    }
    if (cached_has_bits & 0x00000004u) {
      t_ = from.t_;
    }
    if (cached_has_bits & 0x00000008u) {
      scale_ = from.scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void logTrans::CopyFrom(const logTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.logTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool logTrans::IsInitialized() const {
  return true;
}

void logTrans::InternalSwap(logTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(offset_, other->offset_);
  swap(decade_, other->decade_);
  swap(t_, other->t_);
  swap(scale_, other->scale_);
}

std::string logTrans::GetTypeName() const {
  return "pb.logTrans";
}


// ===================================================================

void logGML2Trans::InitAsDefaultInstance() {
}
class logGML2Trans::_Internal {
 public:
  using HasBits = decltype(std::declval<logGML2Trans>()._has_bits_);
  static void set_has_t(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

logGML2Trans::logGML2Trans()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.logGML2Trans)
}
logGML2Trans::logGML2Trans(const logGML2Trans& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&t_, &from.t_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_) -
    reinterpret_cast<char*>(&t_)) + sizeof(m_));
  // @@protoc_insertion_point(copy_constructor:pb.logGML2Trans)
}

void logGML2Trans::SharedCtor() {
  ::memset(&t_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_) -
      reinterpret_cast<char*>(&t_)) + sizeof(m_));
}

logGML2Trans::~logGML2Trans() {
  // @@protoc_insertion_point(destructor:pb.logGML2Trans)
  SharedDtor();
}

void logGML2Trans::SharedDtor() {
}

void logGML2Trans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const logGML2Trans& logGML2Trans::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_logGML2Trans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void logGML2Trans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.logGML2Trans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&t_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&m_) -
        reinterpret_cast<char*>(&t_)) + sizeof(m_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* logGML2Trans::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float T = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_t(&has_bits);
          t_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float M = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_m(&has_bits);
          m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* logGML2Trans::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.logGML2Trans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float T = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_t(), target);
  }

  // optional float M = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_m(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.logGML2Trans)
  return target;
}

size_t logGML2Trans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.logGML2Trans)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float T = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float M = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void logGML2Trans::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const logGML2Trans*>(
      &from));
}

void logGML2Trans::MergeFrom(const logGML2Trans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.logGML2Trans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      t_ = from.t_;
    }
    if (cached_has_bits & 0x00000002u) {
      m_ = from.m_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void logGML2Trans::CopyFrom(const logGML2Trans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.logGML2Trans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool logGML2Trans::IsInitialized() const {
  return true;
}

void logGML2Trans::InternalSwap(logGML2Trans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(t_, other->t_);
  swap(m_, other->m_);
}

std::string logGML2Trans::GetTypeName() const {
  return "pb.logGML2Trans";
}


// ===================================================================

void logicleTrans::InitAsDefaultInstance() {
}
class logicleTrans::_Internal {
 public:
  using HasBits = decltype(std::declval<logicleTrans>()._has_bits_);
  static void set_has_t(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_a(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bins(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_isgml2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_isinverse(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

logicleTrans::logicleTrans()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.logicleTrans)
}
logicleTrans::logicleTrans(const logicleTrans& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&t_, &from.t_,
    static_cast<size_t>(reinterpret_cast<char*>(&isinverse_) -
    reinterpret_cast<char*>(&t_)) + sizeof(isinverse_));
  // @@protoc_insertion_point(copy_constructor:pb.logicleTrans)
}

void logicleTrans::SharedCtor() {
  ::memset(&t_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isinverse_) -
      reinterpret_cast<char*>(&t_)) + sizeof(isinverse_));
}

logicleTrans::~logicleTrans() {
  // @@protoc_insertion_point(destructor:pb.logicleTrans)
  SharedDtor();
}

void logicleTrans::SharedDtor() {
}

void logicleTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const logicleTrans& logicleTrans::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_logicleTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void logicleTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.logicleTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&t_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isinverse_) -
        reinterpret_cast<char*>(&t_)) + sizeof(isinverse_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* logicleTrans::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float T = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_t(&has_bits);
          t_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float W = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_w(&has_bits);
          w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float M = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_m(&has_bits);
          m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float A = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_a(&has_bits);
          a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float bins = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_bins(&has_bits);
          bins_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool isGml2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_isgml2(&has_bits);
          isgml2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool isInverse = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_isinverse(&has_bits);
          isinverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* logicleTrans::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.logicleTrans)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float T = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_t(), target);
  }

  // optional float W = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_w(), target);
  }

  // optional float M = 3;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_m(), target);
  }

  // optional float A = 4;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_a(), target);
  }

  // optional float bins = 5;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_bins(), target);
  }

  // optional bool isGml2 = 6;
  if (cached_has_bits & 0x00000020u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_isgml2(), target);
  }

  // optional bool isInverse = 7;
  if (cached_has_bits & 0x00000040u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_isinverse(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.logicleTrans)
  return target;
}

size_t logicleTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.logicleTrans)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional float T = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float W = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float M = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float A = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float bins = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool isGml2 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool isInverse = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void logicleTrans::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const logicleTrans*>(
      &from));
}

void logicleTrans::MergeFrom(const logicleTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.logicleTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      t_ = from.t_;
    }
    if (cached_has_bits & 0x00000002u) {
      w_ = from.w_;
    }
    if (cached_has_bits & 0x00000004u) {
      m_ = from.m_;
    }
    if (cached_has_bits & 0x00000008u) {
      a_ = from.a_;
    }
    if (cached_has_bits & 0x00000010u) {
      bins_ = from.bins_;
    }
    if (cached_has_bits & 0x00000020u) {
      isgml2_ = from.isgml2_;
    }
    if (cached_has_bits & 0x00000040u) {
      isinverse_ = from.isinverse_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void logicleTrans::CopyFrom(const logicleTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.logicleTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool logicleTrans::IsInitialized() const {
  return true;
}

void logicleTrans::InternalSwap(logicleTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(t_, other->t_);
  swap(w_, other->w_);
  swap(m_, other->m_);
  swap(a_, other->a_);
  swap(bins_, other->bins_);
  swap(isgml2_, other->isgml2_);
  swap(isinverse_, other->isinverse_);
}

std::string logicleTrans::GetTypeName() const {
  return "pb.logicleTrans";
}


// ===================================================================

void transformation::InitAsDefaultInstance() {
  ::pb::_transformation_default_instance_._instance.get_mutable()->caltbl_ = const_cast< ::pb::calibrationTable*>(
      ::pb::calibrationTable::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->bt_ = const_cast< ::pb::biexpTrans*>(
      ::pb::biexpTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->lt_ = const_cast< ::pb::logTrans*>(
      ::pb::logTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->flt_ = const_cast< ::pb::flinTrans*>(
      ::pb::flinTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->st_ = const_cast< ::pb::scaleTrans*>(
      ::pb::scaleTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->ft_ = const_cast< ::pb::fasinhTrans*>(
      ::pb::fasinhTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->lgt_ = const_cast< ::pb::logicleTrans*>(
      ::pb::logicleTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->lgml2t_ = const_cast< ::pb::logGML2Trans*>(
      ::pb::logGML2Trans::internal_default_instance());
}
class transformation::_Internal {
 public:
  using HasBits = decltype(std::declval<transformation>()._has_bits_);
  static const ::pb::calibrationTable& caltbl(const transformation* msg);
  static void set_has_caltbl(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_isgateonly(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_iscomputed(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_trans_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::pb::biexpTrans& bt(const transformation* msg);
  static void set_has_bt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pb::logTrans& lt(const transformation* msg);
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::pb::flinTrans& flt(const transformation* msg);
  static void set_has_flt(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::pb::scaleTrans& st(const transformation* msg);
  static void set_has_st(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::pb::fasinhTrans& ft(const transformation* msg);
  static void set_has_ft(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::pb::logicleTrans& lgt(const transformation* msg);
  static void set_has_lgt(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::pb::logGML2Trans& lgml2t(const transformation* msg);
  static void set_has_lgml2t(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::pb::calibrationTable&
transformation::_Internal::caltbl(const transformation* msg) {
  return *msg->caltbl_;
}
const ::pb::biexpTrans&
transformation::_Internal::bt(const transformation* msg) {
  return *msg->bt_;
}
const ::pb::logTrans&
transformation::_Internal::lt(const transformation* msg) {
  return *msg->lt_;
}
const ::pb::flinTrans&
transformation::_Internal::flt(const transformation* msg) {
  return *msg->flt_;
}
const ::pb::scaleTrans&
transformation::_Internal::st(const transformation* msg) {
  return *msg->st_;
}
const ::pb::fasinhTrans&
transformation::_Internal::ft(const transformation* msg) {
  return *msg->ft_;
}
const ::pb::logicleTrans&
transformation::_Internal::lgt(const transformation* msg) {
  return *msg->lgt_;
}
const ::pb::logGML2Trans&
transformation::_Internal::lgml2t(const transformation* msg) {
  return *msg->lgml2t_;
}
transformation::transformation()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.transformation)
}
transformation::transformation(const transformation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  channel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_channel()) {
    channel_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.channel_);
  }
  if (from._internal_has_caltbl()) {
    caltbl_ = new ::pb::calibrationTable(*from.caltbl_);
  } else {
    caltbl_ = nullptr;
  }
  if (from._internal_has_bt()) {
    bt_ = new ::pb::biexpTrans(*from.bt_);
  } else {
    bt_ = nullptr;
  }
  if (from._internal_has_lt()) {
    lt_ = new ::pb::logTrans(*from.lt_);
  } else {
    lt_ = nullptr;
  }
  if (from._internal_has_flt()) {
    flt_ = new ::pb::flinTrans(*from.flt_);
  } else {
    flt_ = nullptr;
  }
  if (from._internal_has_st()) {
    st_ = new ::pb::scaleTrans(*from.st_);
  } else {
    st_ = nullptr;
  }
  if (from._internal_has_ft()) {
    ft_ = new ::pb::fasinhTrans(*from.ft_);
  } else {
    ft_ = nullptr;
  }
  if (from._internal_has_lgt()) {
    lgt_ = new ::pb::logicleTrans(*from.lgt_);
  } else {
    lgt_ = nullptr;
  }
  if (from._internal_has_lgml2t()) {
    lgml2t_ = new ::pb::logGML2Trans(*from.lgml2t_);
  } else {
    lgml2t_ = nullptr;
  }
  ::memcpy(&trans_type_, &from.trans_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&trans_type_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:pb.transformation)
}

void transformation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_transformation_GatingSet_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  channel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&caltbl_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&caltbl_)) + sizeof(type_));
}

transformation::~transformation() {
  // @@protoc_insertion_point(destructor:pb.transformation)
  SharedDtor();
}

void transformation::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  channel_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete caltbl_;
  if (this != internal_default_instance()) delete bt_;
  if (this != internal_default_instance()) delete lt_;
  if (this != internal_default_instance()) delete flt_;
  if (this != internal_default_instance()) delete st_;
  if (this != internal_default_instance()) delete ft_;
  if (this != internal_default_instance()) delete lgt_;
  if (this != internal_default_instance()) delete lgml2t_;
}

void transformation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const transformation& transformation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_transformation_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void transformation::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.transformation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      channel_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(caltbl_ != nullptr);
      caltbl_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(bt_ != nullptr);
      bt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(lt_ != nullptr);
      lt_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(flt_ != nullptr);
      flt_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(st_ != nullptr);
      st_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(ft_ != nullptr);
      ft_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(lgt_ != nullptr);
      lgt_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(lgml2t_ != nullptr);
      lgml2t_->Clear();
    }
  }
  if (cached_has_bits & 0x00003c00u) {
    ::memset(&trans_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&trans_type_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* transformation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pb.calibrationTable calTbl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_caltbl(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool isGateOnly = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_isgateonly(&has_bits);
          isgateonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.TRANS_TYPE trans_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pb::TRANS_TYPE_IsValid(val))) {
            _internal_set_trans_type(static_cast<::pb::TRANS_TYPE>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string channel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_channel(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool isComputed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_iscomputed(&has_bits);
          iscomputed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.biexpTrans bt = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_bt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.logTrans lt = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_lt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.flinTrans flt = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_flt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.scaleTrans st = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_st(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.fasinhTrans ft = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_ft(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 type = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.logicleTrans lgt = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_lgt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.logGML2Trans lgml2t = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_lgml2t(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* transformation::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.transformation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pb.calibrationTable calTbl = 1;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::caltbl(this), target, stream);
  }

  // optional bool isGateOnly = 2;
  if (cached_has_bits & 0x00000800u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_isgateonly(), target);
  }

  // optional .pb.TRANS_TYPE trans_type = 3;
  if (cached_has_bits & 0x00000400u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_trans_type(), target);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // optional string channel = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_channel(), target);
  }

  // optional bool isComputed = 6;
  if (cached_has_bits & 0x00001000u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_iscomputed(), target);
  }

  // optional .pb.biexpTrans bt = 7;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::bt(this), target, stream);
  }

  // optional .pb.logTrans lt = 8;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, _Internal::lt(this), target, stream);
  }

  // optional .pb.flinTrans flt = 9;
  if (cached_has_bits & 0x00000020u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, _Internal::flt(this), target, stream);
  }

  // optional .pb.scaleTrans st = 10;
  if (cached_has_bits & 0x00000040u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, _Internal::st(this), target, stream);
  }

  // optional .pb.fasinhTrans ft = 11;
  if (cached_has_bits & 0x00000080u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, _Internal::ft(this), target, stream);
  }

  // optional uint32 type = 12;
  if (cached_has_bits & 0x00002000u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_type(), target);
  }

  // optional .pb.logicleTrans lgt = 13;
  if (cached_has_bits & 0x00000100u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        13, _Internal::lgt(this), target, stream);
  }

  // optional .pb.logGML2Trans lgml2t = 14;
  if (cached_has_bits & 0x00000200u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        14, _Internal::lgml2t(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.transformation)
  return target;
}

size_t transformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.transformation)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string channel = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_channel());
    }

    // optional .pb.calibrationTable calTbl = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *caltbl_);
    }

    // optional .pb.biexpTrans bt = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bt_);
    }

    // optional .pb.logTrans lt = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lt_);
    }

    // optional .pb.flinTrans flt = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *flt_);
    }

    // optional .pb.scaleTrans st = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *st_);
    }

    // optional .pb.fasinhTrans ft = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ft_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional .pb.logicleTrans lgt = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lgt_);
    }

    // optional .pb.logGML2Trans lgml2t = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lgml2t_);
    }

    // optional .pb.TRANS_TYPE trans_type = 3;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_trans_type());
    }

    // optional bool isGateOnly = 2;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool isComputed = 6;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional uint32 type = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void transformation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const transformation*>(
      &from));
}

void transformation::MergeFrom(const transformation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.transformation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      channel_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.channel_);
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_caltbl()->::pb::calibrationTable::MergeFrom(from._internal_caltbl());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_bt()->::pb::biexpTrans::MergeFrom(from._internal_bt());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_lt()->::pb::logTrans::MergeFrom(from._internal_lt());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_flt()->::pb::flinTrans::MergeFrom(from._internal_flt());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_st()->::pb::scaleTrans::MergeFrom(from._internal_st());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_ft()->::pb::fasinhTrans::MergeFrom(from._internal_ft());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_lgt()->::pb::logicleTrans::MergeFrom(from._internal_lgt());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_lgml2t()->::pb::logGML2Trans::MergeFrom(from._internal_lgml2t());
    }
    if (cached_has_bits & 0x00000400u) {
      trans_type_ = from.trans_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      isgateonly_ = from.isgateonly_;
    }
    if (cached_has_bits & 0x00001000u) {
      iscomputed_ = from.iscomputed_;
    }
    if (cached_has_bits & 0x00002000u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void transformation::CopyFrom(const transformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.transformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool transformation::IsInitialized() const {
  return true;
}

void transformation::InternalSwap(transformation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  channel_.Swap(&other->channel_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(caltbl_, other->caltbl_);
  swap(bt_, other->bt_);
  swap(lt_, other->lt_);
  swap(flt_, other->flt_);
  swap(st_, other->st_);
  swap(ft_, other->ft_);
  swap(lgt_, other->lgt_);
  swap(lgml2t_, other->lgml2t_);
  swap(trans_type_, other->trans_type_);
  swap(isgateonly_, other->isgateonly_);
  swap(iscomputed_, other->iscomputed_);
  swap(type_, other->type_);
}

std::string transformation::GetTypeName() const {
  return "pb.transformation";
}


// ===================================================================

void trans_pair::InitAsDefaultInstance() {
  ::pb::_trans_pair_default_instance_._instance.get_mutable()->trans_ = const_cast< ::pb::transformation*>(
      ::pb::transformation::internal_default_instance());
}
class trans_pair::_Internal {
 public:
  using HasBits = decltype(std::declval<trans_pair>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trans_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pb::transformation& trans(const trans_pair* msg);
  static void set_has_trans(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pb::transformation&
trans_pair::_Internal::trans(const trans_pair* msg) {
  return *msg->trans_;
}
trans_pair::trans_pair()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.trans_pair)
}
trans_pair::trans_pair(const trans_pair& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from._internal_has_trans()) {
    trans_ = new ::pb::transformation(*from.trans_);
  } else {
    trans_ = nullptr;
  }
  trans_address_ = from.trans_address_;
  // @@protoc_insertion_point(copy_constructor:pb.trans_pair)
}

void trans_pair::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_trans_pair_GatingSet_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&trans_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&trans_address_) -
      reinterpret_cast<char*>(&trans_)) + sizeof(trans_address_));
}

trans_pair::~trans_pair() {
  // @@protoc_insertion_point(destructor:pb.trans_pair)
  SharedDtor();
}

void trans_pair::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete trans_;
}

void trans_pair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const trans_pair& trans_pair::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_trans_pair_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void trans_pair::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.trans_pair)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(trans_ != nullptr);
      trans_->Clear();
    }
  }
  trans_address_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* trans_pair::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 trans_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_trans_address(&has_bits);
          trans_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.transformation trans = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_trans(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* trans_pair::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.trans_pair)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint64 trans_address = 2;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_trans_address(), target);
  }

  // optional .pb.transformation trans = 3;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::trans(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.trans_pair)
  return target;
}

size_t trans_pair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.trans_pair)
  size_t total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .pb.transformation trans = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trans_);
    }

    // optional uint64 trans_address = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_trans_address());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void trans_pair::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const trans_pair*>(
      &from));
}

void trans_pair::MergeFrom(const trans_pair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.trans_pair)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_trans()->::pb::transformation::MergeFrom(from._internal_trans());
    }
    if (cached_has_bits & 0x00000004u) {
      trans_address_ = from.trans_address_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void trans_pair::CopyFrom(const trans_pair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.trans_pair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trans_pair::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void trans_pair::InternalSwap(trans_pair* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(trans_, other->trans_);
  swap(trans_address_, other->trans_address_);
}

std::string trans_pair::GetTypeName() const {
  return "pb.trans_pair";
}


// ===================================================================

void trans_local::InitAsDefaultInstance() {
}
class trans_local::_Internal {
 public:
  using HasBits = decltype(std::declval<trans_local>()._has_bits_);
  static void set_has_groupname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

trans_local::trans_local()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.trans_local)
}
trans_local::trans_local(const trans_local& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      tp_(from.tp_),
      sampleids_(from.sampleids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  groupname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_groupname()) {
    groupname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.groupname_);
  }
  // @@protoc_insertion_point(copy_constructor:pb.trans_local)
}

void trans_local::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_trans_local_GatingSet_2eproto.base);
  groupname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

trans_local::~trans_local() {
  // @@protoc_insertion_point(destructor:pb.trans_local)
  SharedDtor();
}

void trans_local::SharedDtor() {
  groupname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void trans_local::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const trans_local& trans_local::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_trans_local_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void trans_local::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.trans_local)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tp_.Clear();
  sampleids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    groupname_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* trans_local::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .pb.trans_pair tp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tp(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string groupName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_groupname(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 sampleIDs = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_sampleids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24) {
          _internal_add_sampleids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* trans_local::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.trans_local)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.trans_pair tp = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_tp_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(1, this->_internal_tp(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string groupName = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_groupname(), target);
  }

  // repeated uint32 sampleIDs = 3 [packed = true];
  {
    int byte_size = _sampleids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_sampleids(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.trans_local)
  return target;
}

size_t trans_local::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.trans_local)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.trans_pair tp = 1;
  total_size += 1UL * this->_internal_tp_size();
  for (const auto& msg : this->tp_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 sampleIDs = 3 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->sampleids_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _sampleids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional string groupName = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_groupname());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void trans_local::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const trans_local*>(
      &from));
}

void trans_local::MergeFrom(const trans_local& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.trans_local)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  tp_.MergeFrom(from.tp_);
  sampleids_.MergeFrom(from.sampleids_);
  if (from._internal_has_groupname()) {
    _has_bits_[0] |= 0x00000001u;
    groupname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.groupname_);
  }
}

void trans_local::CopyFrom(const trans_local& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.trans_local)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trans_local::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->tp())) return false;
  return true;
}

void trans_local::InternalSwap(trans_local* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tp_.InternalSwap(&other->tp_);
  sampleids_.InternalSwap(&other->sampleids_);
  groupname_.Swap(&other->groupname_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string trans_local::GetTypeName() const {
  return "pb.trans_local";
}


// ===================================================================

void POPINDICES::InitAsDefaultInstance() {
}
class POPINDICES::_Internal {
 public:
  using HasBits = decltype(std::declval<POPINDICES>()._has_bits_);
  static void set_has_nevents(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_indtype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bind(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

POPINDICES::POPINDICES()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.POPINDICES)
}
POPINDICES::POPINDICES(const POPINDICES& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      iind_(from.iind_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  bind_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_bind()) {
    bind_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.bind_);
  }
  ::memcpy(&nevents_, &from.nevents_,
    static_cast<size_t>(reinterpret_cast<char*>(&indtype_) -
    reinterpret_cast<char*>(&nevents_)) + sizeof(indtype_));
  // @@protoc_insertion_point(copy_constructor:pb.POPINDICES)
}

void POPINDICES::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_POPINDICES_GatingSet_2eproto.base);
  bind_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&nevents_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&indtype_) -
      reinterpret_cast<char*>(&nevents_)) + sizeof(indtype_));
}

POPINDICES::~POPINDICES() {
  // @@protoc_insertion_point(destructor:pb.POPINDICES)
  SharedDtor();
}

void POPINDICES::SharedDtor() {
  bind_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void POPINDICES::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const POPINDICES& POPINDICES::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_POPINDICES_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void POPINDICES::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.POPINDICES)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  iind_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    bind_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&nevents_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&indtype_) -
        reinterpret_cast<char*>(&nevents_)) + sizeof(indtype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* POPINDICES::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 nEvents = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_nevents(&has_bits);
          nevents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pb.ind_type indtype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pb::ind_type_IsValid(val))) {
            _internal_set_indtype(static_cast<::pb::ind_type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated uint32 iInd = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_iind(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24) {
          _internal_add_iind(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes bInd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_bind(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* POPINDICES::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.POPINDICES)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 nEvents = 1;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_nevents(), target);
  }

  // required .pb.ind_type indtype = 2;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_indtype(), target);
  }

  // repeated uint32 iInd = 3 [packed = true];
  {
    int byte_size = _iind_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_iind(), byte_size, target);
    }
  }

  // optional bytes bInd = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_bind(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.POPINDICES)
  return target;
}

size_t POPINDICES::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.POPINDICES)
  size_t total_size = 0;

  if (has_nevents()) {
    // required uint32 nEvents = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_nevents());
  }

  if (has_indtype()) {
    // required .pb.ind_type indtype = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_indtype());
  }

  return total_size;
}
size_t POPINDICES::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.POPINDICES)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 nEvents = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_nevents());

    // required .pb.ind_type indtype = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_indtype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 iInd = 3 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->iind_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _iind_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional bytes bInd = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_bind());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void POPINDICES::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const POPINDICES*>(
      &from));
}

void POPINDICES::MergeFrom(const POPINDICES& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.POPINDICES)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  iind_.MergeFrom(from.iind_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      bind_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.bind_);
    }
    if (cached_has_bits & 0x00000002u) {
      nevents_ = from.nevents_;
    }
    if (cached_has_bits & 0x00000004u) {
      indtype_ = from.indtype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void POPINDICES::CopyFrom(const POPINDICES& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.POPINDICES)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool POPINDICES::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  return true;
}

void POPINDICES::InternalSwap(POPINDICES* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  iind_.InternalSwap(&other->iind_);
  bind_.Swap(&other->bind_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(nevents_, other->nevents_);
  swap(indtype_, other->indtype_);
}

std::string POPINDICES::GetTypeName() const {
  return "pb.POPINDICES";
}


// ===================================================================

void nodeProperties::InitAsDefaultInstance() {
  ::pb::_nodeProperties_default_instance_._instance.get_mutable()->indices_ = const_cast< ::pb::POPINDICES*>(
      ::pb::POPINDICES::internal_default_instance());
  ::pb::_nodeProperties_default_instance_._instance.get_mutable()->thisgate_ = const_cast< ::pb::gate*>(
      ::pb::gate::internal_default_instance());
}
class nodeProperties::_Internal {
 public:
  using HasBits = decltype(std::declval<nodeProperties>()._has_bits_);
  static void set_has_thisname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pb::POPINDICES& indices(const nodeProperties* msg);
  static void set_has_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pb::gate& thisgate(const nodeProperties* msg);
  static void set_has_thisgate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::pb::POPINDICES&
nodeProperties::_Internal::indices(const nodeProperties* msg) {
  return *msg->indices_;
}
const ::pb::gate&
nodeProperties::_Internal::thisgate(const nodeProperties* msg) {
  return *msg->thisgate_;
}
nodeProperties::nodeProperties()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.nodeProperties)
}
nodeProperties::nodeProperties(const nodeProperties& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      fjstats_(from.fjstats_),
      fcstats_(from.fcstats_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  thisname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_thisname()) {
    thisname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.thisname_);
  }
  if (from._internal_has_indices()) {
    indices_ = new ::pb::POPINDICES(*from.indices_);
  } else {
    indices_ = nullptr;
  }
  if (from._internal_has_thisgate()) {
    thisgate_ = new ::pb::gate(*from.thisgate_);
  } else {
    thisgate_ = nullptr;
  }
  hidden_ = from.hidden_;
  // @@protoc_insertion_point(copy_constructor:pb.nodeProperties)
}

void nodeProperties::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_nodeProperties_GatingSet_2eproto.base);
  thisname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&indices_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hidden_) -
      reinterpret_cast<char*>(&indices_)) + sizeof(hidden_));
}

nodeProperties::~nodeProperties() {
  // @@protoc_insertion_point(destructor:pb.nodeProperties)
  SharedDtor();
}

void nodeProperties::SharedDtor() {
  thisname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete indices_;
  if (this != internal_default_instance()) delete thisgate_;
}

void nodeProperties::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const nodeProperties& nodeProperties::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_nodeProperties_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void nodeProperties::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.nodeProperties)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fjstats_.Clear();
  fcstats_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      thisname_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(indices_ != nullptr);
      indices_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(thisgate_ != nullptr);
      thisgate_->Clear();
    }
  }
  hidden_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* nodeProperties::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string thisName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_thisname(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pb.POPSTATS fjStats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fjstats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pb.POPSTATS fcStats = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fcstats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // required bool hidden = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_hidden(&has_bits);
          hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.POPINDICES indices = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_indices(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.gate thisGate = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_thisgate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* nodeProperties::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.nodeProperties)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string thisName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_thisname(), target);
  }

  // repeated .pb.POPSTATS fjStats = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fjstats_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(2, this->_internal_fjstats(i), target, stream);
  }

  // repeated .pb.POPSTATS fcStats = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fcstats_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(3, this->_internal_fcstats(i), target, stream);
  }

  // required bool hidden = 4;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_hidden(), target);
  }

  // optional .pb.POPINDICES indices = 5;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::indices(this), target, stream);
  }

  // optional .pb.gate thisGate = 6;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::thisgate(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.nodeProperties)
  return target;
}

size_t nodeProperties::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.nodeProperties)
  size_t total_size = 0;

  if (has_thisname()) {
    // required string thisName = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_thisname());
  }

  if (has_hidden()) {
    // required bool hidden = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t nodeProperties::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.nodeProperties)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required string thisName = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_thisname());

    // required bool hidden = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.POPSTATS fjStats = 2;
  total_size += 1UL * this->_internal_fjstats_size();
  for (const auto& msg : this->fjstats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pb.POPSTATS fcStats = 3;
  total_size += 1UL * this->_internal_fcstats_size();
  for (const auto& msg : this->fcstats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .pb.POPINDICES indices = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *indices_);
    }

    // optional .pb.gate thisGate = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *thisgate_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void nodeProperties::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const nodeProperties*>(
      &from));
}

void nodeProperties::MergeFrom(const nodeProperties& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.nodeProperties)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  fjstats_.MergeFrom(from.fjstats_);
  fcstats_.MergeFrom(from.fcstats_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      thisname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.thisname_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_indices()->::pb::POPINDICES::MergeFrom(from._internal_indices());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_thisgate()->::pb::gate::MergeFrom(from._internal_thisgate());
    }
    if (cached_has_bits & 0x00000008u) {
      hidden_ = from.hidden_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void nodeProperties::CopyFrom(const nodeProperties& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.nodeProperties)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool nodeProperties::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->fjstats())) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->fcstats())) return false;
  if (has_indices()) {
    if (!this->indices_->IsInitialized()) return false;
  }
  if (has_thisgate()) {
    if (!this->thisgate_->IsInitialized()) return false;
  }
  return true;
}

void nodeProperties::InternalSwap(nodeProperties* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fjstats_.InternalSwap(&other->fjstats_);
  fcstats_.InternalSwap(&other->fcstats_);
  thisname_.Swap(&other->thisname_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(indices_, other->indices_);
  swap(thisgate_, other->thisgate_);
  swap(hidden_, other->hidden_);
}

std::string nodeProperties::GetTypeName() const {
  return "pb.nodeProperties";
}


// ===================================================================

void treeNodes::InitAsDefaultInstance() {
  ::pb::_treeNodes_default_instance_._instance.get_mutable()->node_ = const_cast< ::pb::nodeProperties*>(
      ::pb::nodeProperties::internal_default_instance());
}
class treeNodes::_Internal {
 public:
  using HasBits = decltype(std::declval<treeNodes>()._has_bits_);
  static const ::pb::nodeProperties& node(const treeNodes* msg);
  static void set_has_node(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pb::nodeProperties&
treeNodes::_Internal::node(const treeNodes* msg) {
  return *msg->node_;
}
treeNodes::treeNodes()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.treeNodes)
}
treeNodes::treeNodes(const treeNodes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_node()) {
    node_ = new ::pb::nodeProperties(*from.node_);
  } else {
    node_ = nullptr;
  }
  parent_ = from.parent_;
  // @@protoc_insertion_point(copy_constructor:pb.treeNodes)
}

void treeNodes::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_treeNodes_GatingSet_2eproto.base);
  ::memset(&node_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&parent_) -
      reinterpret_cast<char*>(&node_)) + sizeof(parent_));
}

treeNodes::~treeNodes() {
  // @@protoc_insertion_point(destructor:pb.treeNodes)
  SharedDtor();
}

void treeNodes::SharedDtor() {
  if (this != internal_default_instance()) delete node_;
}

void treeNodes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const treeNodes& treeNodes::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_treeNodes_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void treeNodes::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.treeNodes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(node_ != nullptr);
    node_->Clear();
  }
  parent_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* treeNodes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .pb.nodeProperties node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_node(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_parent(&has_bits);
          parent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* treeNodes::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.treeNodes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pb.nodeProperties node = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::node(this), target, stream);
  }

  // optional uint32 parent = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_parent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.treeNodes)
  return target;
}

size_t treeNodes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.treeNodes)
  size_t total_size = 0;

  // required .pb.nodeProperties node = 1;
  if (has_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *node_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 parent = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_parent());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void treeNodes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const treeNodes*>(
      &from));
}

void treeNodes::MergeFrom(const treeNodes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.treeNodes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_node()->::pb::nodeProperties::MergeFrom(from._internal_node());
    }
    if (cached_has_bits & 0x00000002u) {
      parent_ = from.parent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void treeNodes::CopyFrom(const treeNodes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.treeNodes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool treeNodes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void treeNodes::InternalSwap(treeNodes* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(node_, other->node_);
  swap(parent_, other->parent_);
}

std::string treeNodes::GetTypeName() const {
  return "pb.treeNodes";
}


// ===================================================================

void populationTree::InitAsDefaultInstance() {
}
class populationTree::_Internal {
 public:
  using HasBits = decltype(std::declval<populationTree>()._has_bits_);
};

populationTree::populationTree()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.populationTree)
}
populationTree::populationTree(const populationTree& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      node_(from.node_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.populationTree)
}

void populationTree::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_populationTree_GatingSet_2eproto.base);
}

populationTree::~populationTree() {
  // @@protoc_insertion_point(destructor:pb.populationTree)
  SharedDtor();
}

void populationTree::SharedDtor() {
}

void populationTree::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const populationTree& populationTree::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_populationTree_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void populationTree::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.populationTree)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  node_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* populationTree::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .pb.treeNodes node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* populationTree::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.populationTree)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.treeNodes node = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_node_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(1, this->_internal_node(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.populationTree)
  return target;
}

size_t populationTree::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.populationTree)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.treeNodes node = 1;
  total_size += 1UL * this->_internal_node_size();
  for (const auto& msg : this->node_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void populationTree::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const populationTree*>(
      &from));
}

void populationTree::MergeFrom(const populationTree& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.populationTree)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  node_.MergeFrom(from.node_);
}

void populationTree::CopyFrom(const populationTree& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.populationTree)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool populationTree::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->node())) return false;
  return true;
}

void populationTree::InternalSwap(populationTree* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  node_.InternalSwap(&other->node_);
}

std::string populationTree::GetTypeName() const {
  return "pb.populationTree";
}


// ===================================================================

void COMP::InitAsDefaultInstance() {
}
class COMP::_Internal {
 public:
  using HasBits = decltype(std::declval<COMP>()._has_bits_);
  static void set_has_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

COMP::COMP()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.COMP)
}
COMP::COMP(const COMP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      marker_(from.marker_),
      spillover_(from.spillover_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_cid()) {
    cid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cid_);
  }
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_prefix()) {
    prefix_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.prefix_);
  }
  suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_suffix()) {
    suffix_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.suffix_);
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  comment_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_comment()) {
    comment_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comment_);
  }
  // @@protoc_insertion_point(copy_constructor:pb.COMP)
}

void COMP::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_COMP_GatingSet_2eproto.base);
  cid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  comment_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

COMP::~COMP() {
  // @@protoc_insertion_point(destructor:pb.COMP)
  SharedDtor();
}

void COMP::SharedDtor() {
  cid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suffix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void COMP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const COMP& COMP::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_COMP_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void COMP::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.COMP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  marker_.Clear();
  spillover_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      cid_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      prefix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      suffix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      comment_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* COMP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string cid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_cid(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string prefix = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_prefix(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string suffix = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_suffix(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string comment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_comment(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string marker = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_marker(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated float spillOver = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_spillover(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_spillover(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* COMP::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.COMP)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string cid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cid(), target);
  }

  // optional string prefix = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_prefix(), target);
  }

  // optional string suffix = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_suffix(), target);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // optional string comment = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_comment(), target);
  }

  // repeated string marker = 6;
  for (int i = 0, n = this->_internal_marker_size(); i < n; i++) {
    const auto& s = this->_internal_marker(i);
    target = stream->WriteString(6, s, target);
  }

  // repeated float spillOver = 7;
  for (int i = 0, n = this->_internal_spillover_size(); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_spillover(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.COMP)
  return target;
}

size_t COMP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.COMP)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string marker = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(marker_.size());
  for (int i = 0, n = marker_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      marker_.Get(i));
  }

  // repeated float spillOver = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_spillover_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_spillover_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string cid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cid());
    }

    // optional string prefix = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prefix());
    }

    // optional string suffix = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_suffix());
    }

    // optional string name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string comment = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comment());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void COMP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const COMP*>(
      &from));
}

void COMP::MergeFrom(const COMP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.COMP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  marker_.MergeFrom(from.marker_);
  spillover_.MergeFrom(from.spillover_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      cid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cid_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      prefix_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.prefix_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      suffix_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.suffix_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      comment_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
  }
}

void COMP::CopyFrom(const COMP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.COMP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool COMP::IsInitialized() const {
  return true;
}

void COMP::InternalSwap(COMP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  marker_.InternalSwap(&other->marker_);
  spillover_.InternalSwap(&other->spillover_);
  cid_.Swap(&other->cid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  prefix_.Swap(&other->prefix_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  suffix_.Swap(&other->suffix_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  comment_.Swap(&other->comment_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string COMP::GetTypeName() const {
  return "pb.COMP";
}


// ===================================================================

void PARAM::InitAsDefaultInstance() {
}
class PARAM::_Internal {
 public:
  using HasBits = decltype(std::declval<PARAM>()._has_bits_);
  static void set_has_param(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_log(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_range(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_highvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_calibrationindex(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

PARAM::PARAM()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.PARAM)
}
PARAM::PARAM(const PARAM& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  param_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_param()) {
    param_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.param_);
  }
  ::memcpy(&log_, &from.log_,
    static_cast<size_t>(reinterpret_cast<char*>(&calibrationindex_) -
    reinterpret_cast<char*>(&log_)) + sizeof(calibrationindex_));
  // @@protoc_insertion_point(copy_constructor:pb.PARAM)
}

void PARAM::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PARAM_GatingSet_2eproto.base);
  param_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&log_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&calibrationindex_) -
      reinterpret_cast<char*>(&log_)) + sizeof(calibrationindex_));
}

PARAM::~PARAM() {
  // @@protoc_insertion_point(destructor:pb.PARAM)
  SharedDtor();
}

void PARAM::SharedDtor() {
  param_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PARAM::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PARAM& PARAM::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PARAM_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void PARAM::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.PARAM)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    param_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&log_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&calibrationindex_) -
        reinterpret_cast<char*>(&log_)) + sizeof(calibrationindex_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* PARAM::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string param = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_param(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool log = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_log(&has_bits);
          log_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 range = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_range(&has_bits);
          range_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 highValue = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_highvalue(&has_bits);
          highvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 calibrationIndex = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_calibrationindex(&has_bits);
          calibrationindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PARAM::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.PARAM)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string param = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_param(), target);
  }

  // optional bool log = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_log(), target);
  }

  // optional uint32 range = 3;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_range(), target);
  }

  // optional uint32 highValue = 4;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_highvalue(), target);
  }

  // optional uint32 calibrationIndex = 5;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_calibrationindex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.PARAM)
  return target;
}

size_t PARAM::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.PARAM)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string param = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_param());
    }

    // optional bool log = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 range = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_range());
    }

    // optional uint32 highValue = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_highvalue());
    }

    // optional uint32 calibrationIndex = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_calibrationindex());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PARAM::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PARAM*>(
      &from));
}

void PARAM::MergeFrom(const PARAM& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.PARAM)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      param_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.param_);
    }
    if (cached_has_bits & 0x00000002u) {
      log_ = from.log_;
    }
    if (cached_has_bits & 0x00000004u) {
      range_ = from.range_;
    }
    if (cached_has_bits & 0x00000008u) {
      highvalue_ = from.highvalue_;
    }
    if (cached_has_bits & 0x00000010u) {
      calibrationindex_ = from.calibrationindex_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PARAM::CopyFrom(const PARAM& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.PARAM)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PARAM::IsInitialized() const {
  return true;
}

void PARAM::InternalSwap(PARAM* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  param_.Swap(&other->param_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(log_, other->log_);
  swap(range_, other->range_);
  swap(highvalue_, other->highvalue_);
  swap(calibrationindex_, other->calibrationindex_);
}

std::string PARAM::GetTypeName() const {
  return "pb.PARAM";
}


// ===================================================================

void GatingHierarchy::InitAsDefaultInstance() {
  ::pb::_GatingHierarchy_default_instance_._instance.get_mutable()->tree_ = const_cast< ::pb::populationTree*>(
      ::pb::populationTree::internal_default_instance());
  ::pb::_GatingHierarchy_default_instance_._instance.get_mutable()->comp_ = const_cast< ::pb::COMP*>(
      ::pb::COMP::internal_default_instance());
  ::pb::_GatingHierarchy_default_instance_._instance.get_mutable()->trans_ = const_cast< ::pb::trans_local*>(
      ::pb::trans_local::internal_default_instance());
  ::pb::_GatingHierarchy_default_instance_._instance.get_mutable()->frame_ = const_cast< ::pb::CytoFrame*>(
      ::pb::CytoFrame::internal_default_instance());
}
class GatingHierarchy::_Internal {
 public:
  using HasBits = decltype(std::declval<GatingHierarchy>()._has_bits_);
  static const ::pb::populationTree& tree(const GatingHierarchy* msg);
  static void set_has_tree(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pb::COMP& comp(const GatingHierarchy* msg);
  static void set_has_comp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_isloaded(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::pb::trans_local& trans(const GatingHierarchy* msg);
  static void set_has_trans(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pb::CytoFrame& frame(const GatingHierarchy* msg);
  static void set_has_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::pb::populationTree&
GatingHierarchy::_Internal::tree(const GatingHierarchy* msg) {
  return *msg->tree_;
}
const ::pb::COMP&
GatingHierarchy::_Internal::comp(const GatingHierarchy* msg) {
  return *msg->comp_;
}
const ::pb::trans_local&
GatingHierarchy::_Internal::trans(const GatingHierarchy* msg) {
  return *msg->trans_;
}
const ::pb::CytoFrame&
GatingHierarchy::_Internal::frame(const GatingHierarchy* msg) {
  return *msg->frame_;
}
GatingHierarchy::GatingHierarchy()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.GatingHierarchy)
}
GatingHierarchy::GatingHierarchy(const GatingHierarchy& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      transflag_(from.transflag_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_comp()) {
    comp_ = new ::pb::COMP(*from.comp_);
  } else {
    comp_ = nullptr;
  }
  if (from._internal_has_tree()) {
    tree_ = new ::pb::populationTree(*from.tree_);
  } else {
    tree_ = nullptr;
  }
  if (from._internal_has_trans()) {
    trans_ = new ::pb::trans_local(*from.trans_);
  } else {
    trans_ = nullptr;
  }
  if (from._internal_has_frame()) {
    frame_ = new ::pb::CytoFrame(*from.frame_);
  } else {
    frame_ = nullptr;
  }
  isloaded_ = from.isloaded_;
  // @@protoc_insertion_point(copy_constructor:pb.GatingHierarchy)
}

void GatingHierarchy::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GatingHierarchy_GatingSet_2eproto.base);
  ::memset(&comp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isloaded_) -
      reinterpret_cast<char*>(&comp_)) + sizeof(isloaded_));
}

GatingHierarchy::~GatingHierarchy() {
  // @@protoc_insertion_point(destructor:pb.GatingHierarchy)
  SharedDtor();
}

void GatingHierarchy::SharedDtor() {
  if (this != internal_default_instance()) delete comp_;
  if (this != internal_default_instance()) delete tree_;
  if (this != internal_default_instance()) delete trans_;
  if (this != internal_default_instance()) delete frame_;
}

void GatingHierarchy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GatingHierarchy& GatingHierarchy::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GatingHierarchy_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void GatingHierarchy::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GatingHierarchy)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  transflag_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(comp_ != nullptr);
      comp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(tree_ != nullptr);
      tree_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(trans_ != nullptr);
      trans_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(frame_ != nullptr);
      frame_->Clear();
    }
  }
  isloaded_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* GatingHierarchy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pb.COMP comp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_comp(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pb.populationTree tree = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tree(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool isLoaded = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_isloaded(&has_bits);
          isloaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pb.PARAM transFlag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transflag(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .pb.trans_local trans = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_trans(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.CytoFrame frame = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GatingHierarchy::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GatingHierarchy)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pb.COMP comp = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::comp(this), target, stream);
  }

  // required .pb.populationTree tree = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::tree(this), target, stream);
  }

  // optional bool isLoaded = 3;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isloaded(), target);
  }

  // repeated .pb.PARAM transFlag = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_transflag_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(4, this->_internal_transflag(i), target, stream);
  }

  // optional .pb.trans_local trans = 5;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::trans(this), target, stream);
  }

  // optional .pb.CytoFrame frame = 6;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::frame(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GatingHierarchy)
  return target;
}

size_t GatingHierarchy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GatingHierarchy)
  size_t total_size = 0;

  // required .pb.populationTree tree = 2;
  if (has_tree()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *tree_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.PARAM transFlag = 4;
  total_size += 1UL * this->_internal_transflag_size();
  for (const auto& msg : this->transflag_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .pb.COMP comp = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *comp_);
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional .pb.trans_local trans = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trans_);
    }

    // optional .pb.CytoFrame frame = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *frame_);
    }

    // optional bool isLoaded = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GatingHierarchy::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GatingHierarchy*>(
      &from));
}

void GatingHierarchy::MergeFrom(const GatingHierarchy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.GatingHierarchy)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  transflag_.MergeFrom(from.transflag_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_comp()->::pb::COMP::MergeFrom(from._internal_comp());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_tree()->::pb::populationTree::MergeFrom(from._internal_tree());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_trans()->::pb::trans_local::MergeFrom(from._internal_trans());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_frame()->::pb::CytoFrame::MergeFrom(from._internal_frame());
    }
    if (cached_has_bits & 0x00000010u) {
      isloaded_ = from.isloaded_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GatingHierarchy::CopyFrom(const GatingHierarchy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GatingHierarchy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GatingHierarchy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_tree()) {
    if (!this->tree_->IsInitialized()) return false;
  }
  if (has_trans()) {
    if (!this->trans_->IsInitialized()) return false;
  }
  if (has_frame()) {
    if (!this->frame_->IsInitialized()) return false;
  }
  return true;
}

void GatingHierarchy::InternalSwap(GatingHierarchy* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  transflag_.InternalSwap(&other->transflag_);
  swap(comp_, other->comp_);
  swap(tree_, other->tree_);
  swap(trans_, other->trans_);
  swap(frame_, other->frame_);
  swap(isloaded_, other->isloaded_);
}

std::string GatingHierarchy::GetTypeName() const {
  return "pb.GatingHierarchy";
}


// ===================================================================

void CytoFrame::InitAsDefaultInstance() {
}
class CytoFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<CytoFrame>()._has_bits_);
  static void set_has_is_h5(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CytoFrame::CytoFrame()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.CytoFrame)
}
CytoFrame::CytoFrame(const CytoFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  is_h5_ = from.is_h5_;
  // @@protoc_insertion_point(copy_constructor:pb.CytoFrame)
}

void CytoFrame::SharedCtor() {
  is_h5_ = false;
}

CytoFrame::~CytoFrame() {
  // @@protoc_insertion_point(destructor:pb.CytoFrame)
  SharedDtor();
}

void CytoFrame::SharedDtor() {
}

void CytoFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CytoFrame& CytoFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CytoFrame_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void CytoFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.CytoFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  is_h5_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* CytoFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool is_h5 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_is_h5(&has_bits);
          is_h5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CytoFrame::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.CytoFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool is_h5 = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_h5(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.CytoFrame)
  return target;
}

size_t CytoFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.CytoFrame)
  size_t total_size = 0;

  // required bool is_h5 = 1;
  if (has_is_h5()) {
    total_size += 1 + 1;
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CytoFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CytoFrame*>(
      &from));
}

void CytoFrame::MergeFrom(const CytoFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.CytoFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_is_h5()) {
    _internal_set_is_h5(from._internal_is_h5());
  }
}

void CytoFrame::CopyFrom(const CytoFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.CytoFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CytoFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void CytoFrame::InternalSwap(CytoFrame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(is_h5_, other->is_h5_);
}

std::string CytoFrame::GetTypeName() const {
  return "pb.CytoFrame";
}


// ===================================================================

void TRANS_TBL::InitAsDefaultInstance() {
  ::pb::_TRANS_TBL_default_instance_._instance.get_mutable()->trans_ = const_cast< ::pb::transformation*>(
      ::pb::transformation::internal_default_instance());
}
class TRANS_TBL::_Internal {
 public:
  using HasBits = decltype(std::declval<TRANS_TBL>()._has_bits_);
  static void set_has_trans_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pb::transformation& trans(const TRANS_TBL* msg);
  static void set_has_trans(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::pb::transformation&
TRANS_TBL::_Internal::trans(const TRANS_TBL* msg) {
  return *msg->trans_;
}
TRANS_TBL::TRANS_TBL()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.TRANS_TBL)
}
TRANS_TBL::TRANS_TBL(const TRANS_TBL& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_trans()) {
    trans_ = new ::pb::transformation(*from.trans_);
  } else {
    trans_ = nullptr;
  }
  trans_address_ = from.trans_address_;
  // @@protoc_insertion_point(copy_constructor:pb.TRANS_TBL)
}

void TRANS_TBL::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TRANS_TBL_GatingSet_2eproto.base);
  ::memset(&trans_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&trans_address_) -
      reinterpret_cast<char*>(&trans_)) + sizeof(trans_address_));
}

TRANS_TBL::~TRANS_TBL() {
  // @@protoc_insertion_point(destructor:pb.TRANS_TBL)
  SharedDtor();
}

void TRANS_TBL::SharedDtor() {
  if (this != internal_default_instance()) delete trans_;
}

void TRANS_TBL::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TRANS_TBL& TRANS_TBL::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TRANS_TBL_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void TRANS_TBL::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.TRANS_TBL)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(trans_ != nullptr);
    trans_->Clear();
  }
  trans_address_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* TRANS_TBL::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 trans_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_trans_address(&has_bits);
          trans_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pb.transformation trans = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_trans(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TRANS_TBL::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.TRANS_TBL)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 trans_address = 1;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_trans_address(), target);
  }

  // optional .pb.transformation trans = 2;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::trans(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.TRANS_TBL)
  return target;
}

size_t TRANS_TBL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.TRANS_TBL)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .pb.transformation trans = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trans_);
    }

    // optional uint64 trans_address = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_trans_address());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TRANS_TBL::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TRANS_TBL*>(
      &from));
}

void TRANS_TBL::MergeFrom(const TRANS_TBL& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.TRANS_TBL)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_trans()->::pb::transformation::MergeFrom(from._internal_trans());
    }
    if (cached_has_bits & 0x00000002u) {
      trans_address_ = from.trans_address_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TRANS_TBL::CopyFrom(const TRANS_TBL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.TRANS_TBL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TRANS_TBL::IsInitialized() const {
  return true;
}

void TRANS_TBL::InternalSwap(TRANS_TBL* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(trans_, other->trans_);
  swap(trans_address_, other->trans_address_);
}

std::string TRANS_TBL::GetTypeName() const {
  return "pb.TRANS_TBL";
}


// ===================================================================

void GatingSet::InitAsDefaultInstance() {
}
class GatingSet::_Internal {
 public:
  using HasBits = decltype(std::declval<GatingSet>()._has_bits_);
  static void set_has_globalbiexptrans(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_globallintrans(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cytolib_verion(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pb_verion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_h5_verion(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

GatingSet::GatingSet()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.GatingSet)
}
GatingSet::GatingSet(const GatingSet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      samplename_(from.samplename_),
      trans_tbl_(from.trans_tbl_),
      gtrans_(from.gtrans_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_guid()) {
    guid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.guid_);
  }
  cytolib_verion_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_cytolib_verion()) {
    cytolib_verion_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cytolib_verion_);
  }
  pb_verion_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_pb_verion()) {
    pb_verion_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.pb_verion_);
  }
  h5_verion_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_h5_verion()) {
    h5_verion_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.h5_verion_);
  }
  ::memcpy(&globalbiexptrans_, &from.globalbiexptrans_,
    static_cast<size_t>(reinterpret_cast<char*>(&globallintrans_) -
    reinterpret_cast<char*>(&globalbiexptrans_)) + sizeof(globallintrans_));
  // @@protoc_insertion_point(copy_constructor:pb.GatingSet)
}

void GatingSet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GatingSet_GatingSet_2eproto.base);
  guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cytolib_verion_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pb_verion_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  h5_verion_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&globalbiexptrans_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&globallintrans_) -
      reinterpret_cast<char*>(&globalbiexptrans_)) + sizeof(globallintrans_));
}

GatingSet::~GatingSet() {
  // @@protoc_insertion_point(destructor:pb.GatingSet)
  SharedDtor();
}

void GatingSet::SharedDtor() {
  guid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cytolib_verion_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pb_verion_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  h5_verion_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GatingSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GatingSet& GatingSet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GatingSet_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void GatingSet::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GatingSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  samplename_.Clear();
  trans_tbl_.Clear();
  gtrans_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      guid_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      cytolib_verion_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      pb_verion_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      h5_verion_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&globalbiexptrans_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&globallintrans_) -
        reinterpret_cast<char*>(&globalbiexptrans_)) + sizeof(globallintrans_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* GatingSet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string sampleName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_samplename(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pb.TRANS_TBL trans_tbl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trans_tbl(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 globalBiExpTrans = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_globalbiexptrans(&has_bits);
          globalbiexptrans_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 globalLinTrans = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_globallintrans(&has_bits);
          globallintrans_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pb.trans_local gTrans = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gtrans(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string guid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_guid(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cytolib_verion = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_cytolib_verion(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string pb_verion = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_pb_verion(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string h5_verion = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_h5_verion(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GatingSet::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GatingSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string sampleName = 1;
  for (int i = 0, n = this->_internal_samplename_size(); i < n; i++) {
    const auto& s = this->_internal_samplename(i);
    target = stream->WriteString(1, s, target);
  }

  // repeated .pb.TRANS_TBL trans_tbl = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trans_tbl_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(2, this->_internal_trans_tbl(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint64 globalBiExpTrans = 3;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_globalbiexptrans(), target);
  }

  // optional uint64 globalLinTrans = 4;
  if (cached_has_bits & 0x00000020u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_globallintrans(), target);
  }

  // repeated .pb.trans_local gTrans = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_gtrans_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(5, this->_internal_gtrans(i), target, stream);
  }

  // optional string guid = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_guid(), target);
  }

  // optional string cytolib_verion = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_cytolib_verion(), target);
  }

  // optional string pb_verion = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_pb_verion(), target);
  }

  // optional string h5_verion = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_h5_verion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GatingSet)
  return target;
}

size_t GatingSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GatingSet)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string sampleName = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(samplename_.size());
  for (int i = 0, n = samplename_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      samplename_.Get(i));
  }

  // repeated .pb.TRANS_TBL trans_tbl = 2;
  total_size += 1UL * this->_internal_trans_tbl_size();
  for (const auto& msg : this->trans_tbl_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pb.trans_local gTrans = 5;
  total_size += 1UL * this->_internal_gtrans_size();
  for (const auto& msg : this->gtrans_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string guid = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_guid());
    }

    // optional string cytolib_verion = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cytolib_verion());
    }

    // optional string pb_verion = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pb_verion());
    }

    // optional string h5_verion = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_h5_verion());
    }

    // optional uint64 globalBiExpTrans = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_globalbiexptrans());
    }

    // optional uint64 globalLinTrans = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_globallintrans());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GatingSet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GatingSet*>(
      &from));
}

void GatingSet::MergeFrom(const GatingSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.GatingSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  samplename_.MergeFrom(from.samplename_);
  trans_tbl_.MergeFrom(from.trans_tbl_);
  gtrans_.MergeFrom(from.gtrans_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      guid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.guid_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      cytolib_verion_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cytolib_verion_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      pb_verion_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.pb_verion_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      h5_verion_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.h5_verion_);
    }
    if (cached_has_bits & 0x00000010u) {
      globalbiexptrans_ = from.globalbiexptrans_;
    }
    if (cached_has_bits & 0x00000020u) {
      globallintrans_ = from.globallintrans_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GatingSet::CopyFrom(const GatingSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GatingSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GatingSet::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->gtrans())) return false;
  return true;
}

void GatingSet::InternalSwap(GatingSet* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  samplename_.InternalSwap(&other->samplename_);
  trans_tbl_.InternalSwap(&other->trans_tbl_);
  gtrans_.InternalSwap(&other->gtrans_);
  guid_.Swap(&other->guid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  cytolib_verion_.Swap(&other->cytolib_verion_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  pb_verion_.Swap(&other->pb_verion_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  h5_verion_.Swap(&other->h5_verion_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(globalbiexptrans_, other->globalbiexptrans_);
  swap(globallintrans_, other->globallintrans_);
}

std::string GatingSet::GetTypeName() const {
  return "pb.GatingSet";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pb::paramRange* Arena::CreateMaybeMessage< ::pb::paramRange >(Arena* arena) {
  return Arena::CreateInternal< ::pb::paramRange >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::rangeGate* Arena::CreateMaybeMessage< ::pb::rangeGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::rangeGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::paramPoly* Arena::CreateMaybeMessage< ::pb::paramPoly >(Arena* arena) {
  return Arena::CreateInternal< ::pb::paramPoly >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::polygonGate* Arena::CreateMaybeMessage< ::pb::polygonGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::polygonGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::coordinate* Arena::CreateMaybeMessage< ::pb::coordinate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::coordinate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::ellipseGate* Arena::CreateMaybeMessage< ::pb::ellipseGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::ellipseGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::BOOL_GATE_OP* Arena::CreateMaybeMessage< ::pb::BOOL_GATE_OP >(Arena* arena) {
  return Arena::CreateInternal< ::pb::BOOL_GATE_OP >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::boolGate* Arena::CreateMaybeMessage< ::pb::boolGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::boolGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::clusterGate* Arena::CreateMaybeMessage< ::pb::clusterGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::clusterGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::quadGate* Arena::CreateMaybeMessage< ::pb::quadGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::quadGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::gate* Arena::CreateMaybeMessage< ::pb::gate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::gate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::POPSTATS* Arena::CreateMaybeMessage< ::pb::POPSTATS >(Arena* arena) {
  return Arena::CreateInternal< ::pb::POPSTATS >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::calibrationTable* Arena::CreateMaybeMessage< ::pb::calibrationTable >(Arena* arena) {
  return Arena::CreateInternal< ::pb::calibrationTable >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::biexpTrans* Arena::CreateMaybeMessage< ::pb::biexpTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::biexpTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::fasinhTrans* Arena::CreateMaybeMessage< ::pb::fasinhTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::fasinhTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::scaleTrans* Arena::CreateMaybeMessage< ::pb::scaleTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::scaleTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::flinTrans* Arena::CreateMaybeMessage< ::pb::flinTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::flinTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::logTrans* Arena::CreateMaybeMessage< ::pb::logTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::logTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::logGML2Trans* Arena::CreateMaybeMessage< ::pb::logGML2Trans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::logGML2Trans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::logicleTrans* Arena::CreateMaybeMessage< ::pb::logicleTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::logicleTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::transformation* Arena::CreateMaybeMessage< ::pb::transformation >(Arena* arena) {
  return Arena::CreateInternal< ::pb::transformation >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::trans_pair* Arena::CreateMaybeMessage< ::pb::trans_pair >(Arena* arena) {
  return Arena::CreateInternal< ::pb::trans_pair >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::trans_local* Arena::CreateMaybeMessage< ::pb::trans_local >(Arena* arena) {
  return Arena::CreateInternal< ::pb::trans_local >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::POPINDICES* Arena::CreateMaybeMessage< ::pb::POPINDICES >(Arena* arena) {
  return Arena::CreateInternal< ::pb::POPINDICES >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::nodeProperties* Arena::CreateMaybeMessage< ::pb::nodeProperties >(Arena* arena) {
  return Arena::CreateInternal< ::pb::nodeProperties >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::treeNodes* Arena::CreateMaybeMessage< ::pb::treeNodes >(Arena* arena) {
  return Arena::CreateInternal< ::pb::treeNodes >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::populationTree* Arena::CreateMaybeMessage< ::pb::populationTree >(Arena* arena) {
  return Arena::CreateInternal< ::pb::populationTree >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::COMP* Arena::CreateMaybeMessage< ::pb::COMP >(Arena* arena) {
  return Arena::CreateInternal< ::pb::COMP >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::PARAM* Arena::CreateMaybeMessage< ::pb::PARAM >(Arena* arena) {
  return Arena::CreateInternal< ::pb::PARAM >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GatingHierarchy* Arena::CreateMaybeMessage< ::pb::GatingHierarchy >(Arena* arena) {
  return Arena::CreateInternal< ::pb::GatingHierarchy >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::CytoFrame* Arena::CreateMaybeMessage< ::pb::CytoFrame >(Arena* arena) {
  return Arena::CreateInternal< ::pb::CytoFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::TRANS_TBL* Arena::CreateMaybeMessage< ::pb::TRANS_TBL >(Arena* arena) {
  return Arena::CreateInternal< ::pb::TRANS_TBL >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GatingSet* Arena::CreateMaybeMessage< ::pb::GatingSet >(Arena* arena) {
  return Arena::CreateInternal< ::pb::GatingSet >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
