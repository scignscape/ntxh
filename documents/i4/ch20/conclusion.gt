
`section.Conclusion`
`p.
This chapter has briefly touched on several 
disparate themes in the realm 
of software engineering, themes which 
will be further examined, to varying 
degrees, over the next three chapters.  
In particular, domains such as 
Geographic Information Systems and 
Building Information Management 
present use-cases for multi-application  
data sharing through intermediaries such as a 
`GIS; database; for the juxtaposition of 
spatial (e.g. geospatial, image-space, 
or `ThreeD;/`CAD; designs, or some combination 
thereof) and functional structures, with spatial 
and functional facets analyzed and visualized 
side-by-side; and for application-front-end 
event-handling pipelines, discussed here 
in the context of users interacting 
with digital `GIS; maps.  Each of these 
contexts present engineering complications 
that software components need to manage 
%-- these are the sort of implementational 
tangles that can, in the absence of 
well-constructed code libraries and design 
patterns, inhibit our ability to 
engineer applications in a timely and 
cost-effective manner.
`p`

`p.
Situations such as 
Ukraine reconstruction point to how 
software-development inertia has 
real-world consequences: ideally, 
a variety of special-purpose applications 
will come on board soon after an 
envisaged Russian cease-fire, helping 
the international community to 
rebuild Ukrainian cities and facilities 
in short order.  The more user-friendly 
and feature-provisioned this custom 
software, the more effectively 
civil engineers can leverage the 
sheer scale of needed reconstruction 
to implement `q.smart city` technologies.     
`p`


`p.
For each of these three themes (decentralized/mediated 
data-sharing, spatial/functional 
data juxtaposition, and event-processing) we may 
identify specific concerns that add layers 
of complexity and engineering requirements 
to the respective classes of applications.  
In terms of data sharing, programmers 
should identify how to package domain-specific 
data in formats that can be stored in a 
domain-neutral setting (like a `GIS; database) 
and then reconstituted by other applications 
with sufficiently overlapping capabilities, 
a problem which involves both how 
future applications will query for the 
specific information they need and how 
they will build in-memory 
structures (in their own coding environment) 
which are properly aligned with and 
behaviorally replicate the objects 
originally deposited.  Programmers can 
certainly use object-oriented techniques 
(for example) to encapsulate the properties 
and behaviors of specific object-classes, 
but it requires extra layers of design 
to build object-systems which 
are sufficiently semantically explicit 
to orchestrate cross-application 
interoperability.  In the context 
of event-handling, applications 
should engineer a centralized protocol 
for documenting event signals 
and response-routines.  It is one 
thing to code event-handling procedures 
(e.g., via `Qt; signals and slots); 
situations such as `GIS; front-ends 
demonstrate however that applications 
require a further dimension of structural 
coherence, insofar as a code base needs 
not only to provide procedures responding 
to user-events, but to allow the 
total system of event signals and responders 
to be documented, queried, and augmented 
in an orderly manner.  Frameworks 
like `Qt; provision support for the 
base-level implementations, but 
other paradigms are necessary to 
architect the overall system in this 
kind of logical manner.   
`p`



`p.
And, finally, with respect to 
spatial/functional organization, 
applications need to construct data-packages 
encapsulating system-functional 
details which can be keyed to 
locations such that 
spatial coordinates serve as 
indices and handles to extra 
data layers (again, `q.space` here 
can have different or multiple 
meanings: geographic extent, image-space, 
the virtual space of `CAD; designs, etc.).  
At one level, associations between 
spatial points and data objects 
might be covered by a straightforward 
key-value mapping, with locations 
as keys and object-identifiers as 
values.  But the larger problems 
of integrating spatial and functional 
data are more complex: how should 
`GUI; displays targeted at spatial 
arrangement (`GIS; maps in the geospatial 
context, say, or floorplan blueprints 
in architectural `CAD;) be extended 
to include icons or signal-generators 
such that users can access data 
(or access functionality leveraging 
data) handled by functional-analytic 
plugins/components coexisting with the 
spatial displays?  How should 
underlying `q.spatial` data stores 
(such as `GIS; databases) support the 
depositing, querying, and retrieval 
of objects that are largely opaque to the 
stores themselves (as in non-`GIS; data 
integrated with `GIS; databases)?
`p`

`p.  
To appreciate the 
full scope of these issues we should 
consider the problem-domain from the 
perspective of a programmer intending 
to support analytics concerning 
functional organization in an 
environment where data is 
predominantly organized in a 
spatial context (for some 
notion of `q.space`/).  In 
`GIS;, for instance, imagine 
the perspective of a developer 
building an application tracking 
data structures (consider water 
systems, as in the above examples) 
where functional units have 
geospatial coordinates but also 
many parameters 
which do not measure 
`GIS; magnitudes or attributes.  
Ultimately, such data must be 
encapsulated into persistable 
units and linked to `GIS; locations, 
so that peer applications can pull 
the relevant objects from a 
database via (say) latitude/longitude.  
How would engineers know that the 
full range of parameters is properly 
reconstructed by external applications 
so that their computations or simulations 
are consistent with the originating 
applications' models?
`p`

`p.
It would be 
one thing if external software 
was simply cloning the 
original program's full data sets, with 
some guarantee that the later computing 
environment is sufficiently 
analogous to the former that 
both copies of the data will be 
behaviorally equivalent.  However, 
working through a `GIS; intermediary 
occludes this synchronization: we assume 
that later applications are obtaining 
data piecemeal from specific 
`GIS; locations or areas, rather than 
getting a full-scale replica of 
an original information space 
(in the context of large-scale data sets, 
such as a hydrological survey of an 
entire country, cloning the data 
`i.tout court` could well be impossible; 
even for smaller-scale data sets, 
however, working with partial samples 
rather than full copies of original 
data might be more consistent with the 
later application's requirements).  
How can originating applications 
guarantee data integrity and analytic 
accuracy under the 
assumption that external software will 
run analyses over parts rather than 
full copies of their data sets?  
How can these applications identify 
the `q.operational closure` of 
any given sample within their 
data sets such that these 
integrity validations are guaranteed?      
`p`


`p.
Current `IFC; standards are a good 
illustration of how these issues 
play out in practice.  Seen as a 
design-model, `CAD; systems compose 
`IFC; elements as building-blocks 
which piece together to define an 
integrated data space through which 
architectural plans may be 
visualized, in various formats 
(blueprints, `ThreeD; models, 
`q.artist rendering` style `TwoD; 
images).  At the same time, the 
structural network evinced by 
interlinked `IFC; data can also 
be queried as a foundation for 
simulations involving buildings as 
functionally organized systems 
(with respect to energy consumption, 
fire safety, internal temperature 
dynamics, and so forth).  Structured 
chains of `IFC; objects thereby serve as 
a multi-faceted foundation from which, 
on the one hand,  
spatially and visually oriented 
resources might be constructed 
(such as floor plans) and, on the 
other hand, data needed for 
functional simulations can be 
initialized.  Such integration between 
spatial and functional structures 
is driven by the coexistence of 
parameters within `IFC; objects that 
address concerns related to 
buildings' functional-systematic 
profiles (energy efficiency, for 
example) as well as those related 
to `CAD; model-space.  These facets 
of the `IFC; data model could potentially 
serve as an inspiration for analogous 
standardization of information classes 
within other domains where spatial and 
functional networks co-exist, such as 
`GIS; or %-- in the sense of 
visual object-recognition alongside 
structured environment-models %-- robotics 
and Computer Vision.
`p`


`p.
Setting aside the specific details of `IFC;, 
however, the issues of spatial/functional 
juxtaposition, event-handling, 
and mediated multi-application data sharing 
point to software-engineering challenges 
that %-- one could reasonably claim 
%-- point toward next-generation 
software-development environments.  Existing 
programming tools and design patterns 
arguably do a relatively poor 
job of addressing such concerns 
effectively, measured by how readily 
developers have tools at hand to 
implement code which manages the 
relevant complexity in a rigorous 
manner (so that applications can be 
deployed more quickly, and maintained 
for a longer or more productive life-span).
These are the kind of practical 
challenges which call for new 
ideas in Software Language Engineering, 
to circle back to the discussion 
at the start of this chapter.  
In the next chapter `IauNC; will focus in specifically 
on one such paradigm, namely hypergraph 
models of computing processes, query 
evaluation, and data interoperability.
`p`



`p.

`p`


