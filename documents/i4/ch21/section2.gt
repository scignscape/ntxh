
`section.Semantic Interpretation of Syntagmatic Graphs`

`p.
Assuming we remain within the context of applicative structures 
proper, the point of these formations is to represent 
the idea of functions (in some sense) which take input 
values.  Notating this process via variable-symbols 
allows function composition (and arity-reducing projections) 
to be described; thus we have `q.substitution,` 
replacing variable-symbols with concrete values.  When 
all free variables in an expression describing 
(potentially nested) function-applications are 
thus substituted, we have sufficient information to 
evaluate the function, or %-- in the sense of 
lambda-calculus `q.beta` reduction %-- reduce 
(or `q.collapse`/) the 
aggregate expression to a single resulting value.  
This is the central dynamic figured by applicative 
structures in their simpler, classical sense 
%-- input parameters yield applications which 
`q.reduce` the inputs to a single output value, 
that may in turn be input to other functions.  
Chaining inputs and outputs in this sense 
engenders a model of computations as graphs, 
where edges encode how values travel 
between applications, with multiple inputs 
potentially each being outputs from 
multiple precursor function-applications.
`p`



`p.
The semantic interpretation `IauNC; adopt here for `q.syntagmatic` 
graphs is noticeably different than this model 
(`IauNC; have analyzed the specific differences in 
`cite<[page 150]NeusteinChristen>;).  
Rather than taking input/output as a fundamental 
divide within function-parameters, `IauNC; consider 
more general channel systems here.  Note that in 
contrast to (more typical) graph-representations 
of computation where outputs are marked by 
directed edges `i.away from` procedure nodes, 
in Syntagmatic Graphs (hereafter `SG;s) all edges point `i.into` 
procedure-nodes, including those embodying 
`q.outputs` (`cite<[section 9.2]NeusteinChristen>; has some comments 
about why this can make sense).  More elaborate 
rationales for the notational and interpretive 
differences between `SG;s and 
other procedure-models is tangential to the 
current chapter, so `IauNC;'ll focus instead 
on outlining the semantic interpretation itself.`footnote.
Some of this terminology is derived from Petri nets 
`cite<RobertGold>;, `cite<PettitGomaa>;,
`cite<SergeyPOrlov>;, `cite<AnilSawhney>;, 
`cite<NadeemAkhtar>;, `cite<FeiLiu>;, 
`cite<RadekKoci>;, `cite<KohlerRolke>;.
`footnote` 

`anondefin.
Call a `i.marking` of a Syntagmatic 
Graph to be an association between 
some of its nodes and a collection of typed 
values, against some type system.  Markings 
might be context-dependent; that is, a 
graph could be subject to multiple 
markings concurrently, each restricted 
to one context.  `IauNCpl;'ll say that values
are `i.bound to` nodes, but indirectly, 
as explained in the following.
`anondefin`

`anondefin.
Syntagmatic Graph nodes can be associated with 
`i.types` and `i.states`/.  For the present, 
`IauNC; will not rigorously define `q.types,` but 
`IauNC;'ll comment that types are introduced 
`visavis; nodes `i.through` states.  
For any type, each possible instance of that type 
is a potential `i.state` for Syntagmatic Graph nodes, 
the state of being `q.occupied` by that specific 
value.  However, not every node-state need correspond 
to a type.  In particular, nodes can have a state 
corresponding to a `q.void` or lack-of-value.
`anondefin`

That is, `IauNC; approach the notion of `q.void` as a `i.state` 
possibly evinced by nodes, rather than through type 
systems themselves.  That is, we do not need 
a `q.bottom` or `q.nothing` type with some 
special value selected (essentially by fiat) 
to represent non-initialization or pre-initialization.  
`IauNCpl; find it more semantically coherent to
express such `q.nothing` states as the 
state of `i.having no value`/, rather than 
as the presence of a construed `q.nothing` value 
(and nothing-type which it instantiates).`footnote.
Note that in type theory we can also define 
`q.bottom` types via constructions that preclude 
bottom from ever being instantiated at 
all (e.g., by stipulating that bottom is 
a subtype of any other type, i.e., the 
subtype relation between that and any 
type is defined to be true).  A type system 
may have an uninhabitable type insofar as 
predicates on intertype relations 
(such as subtype-of) can be non-paradoxically defined on the 
full collection of types, including uninhabited 
ones.  A bottom type does then have a 
reasonable correspondence with uninitialized 
code-symbols because this is the only type 
that correctly characterizes the state 
of such symbols prior to their being assigned a 
value (without a value, there is no inhabited 
type where we can say the symbol's value is 
an instance of that type).  Still, the purpose 
of assigning a type to symbols in practice 
is to constrain how symbols can be used 
(when passed to procedures, in particular), 
and for these purposes it is arguably 
misleading to use type-attributions 
`i.per se` to model value lifetimes.  
For this reason it seems better to 
capture the fact of pre-initialization 
via a `i.state` characterizing the 
symbol itself rather than a `i.type` 
attributed to its value.     
`footnote`
`p`


`p.
Against this background, the semantics of procedure-calls 
can be expressed via before-and-after states 
for each argument-node incident to a procedure-node.  
The procedure's semantics is, as such, 
the cumulative state-changes, or `i.change in marking state`/, 
effectuated by the procedure.  In a general case, 
some of these changes will be void (no-value state) nodes 
transitioning to having a value; these would 
typically correspond to `q.output` nodes in 
classical applicative models.  However 
%-- accommodating scenarios like mutable references 
%-- nodes with the state of binding to some value 
could migrate to the state of binding to a `i.different` 
value.  In general, notions such as input-versus-output 
are expressed in this system `q.semantically` as a 
manifestation of state-changes, rather than 
`q.syntactically` as edge-direction or arrows assigning 
different directions to inputs versus outputs.
`p`


`p.
Roughly as an analog to `q.beta` reduction, `IauNC; propose 
the term `i.digamma` reduction to express 
marking-state changes due to a procedure-call.  
A digamma reduction is the cumulative state-change 
in all nodes affected by the procedure (or, seen 
syntactically, all nodes adjacent to the procedure-node).  
For multi- (channelized) neighborhood `SG;s, 
digamma reduction happens in multiple stages, each 
contextualized to a single neighborhood.  Note 
that `IauNC; like the term `q.digamma reduction` partly 
as an oblique reference to `q.sigma` calculus 
(an object-oriented extension to lambda calculus, 
and the Greek digamma numeric symbol looks like a enlarged 
lower-case sigma) and partly because `q.gamma` is a common 
symbol for graphs, so `q.digamma` suggests `q.two graphs,` 
or a computational interaction between one graph 
assembling a procedure-call and one graph implementing it.      
`p`


`p.
Semantically, then, `SG;s model digamma 
reductions `i.in sequence`/, each localized to 
individual channelized neighborhoods.  This 
idea can then be extended to sequences of 
`SG;s in turn.  We are getting closer 
to representing actual computer code; one further 
step might then be incorporating something like 
`q.stack frames.`  Assume that `SG;s 
are represented `i.in sequence` and moreover 
that such sequences occur in the context 
of a `i.symbol scope`/, or an environment 
where string labels can serve as `q.carriers` 
for typed values; `IauNC;'ll sometimes refer to `q.`SG;-scopes,` 
scopes contextualizing `SG; sequences wherein symbols 
designate carriers which (when in an initialized 
state) hold concrete values.  In particular, assume that 
carriers can reveal `q.carrier states` 
reciprocating the states defined 
on nodes earlier: for any type there is a 
spectrum of states equivalent to each type-instance, 
but there are also states involving 
`i.lack` of typed values (the generic example 
of such a state `IauNC;'ll call `i.pre-initialized`/).  
The states available for carriers could be called 
`q.type-based` in that they are organized around 
typed values but include non-type states as well.
`SG; nodes may then take on states 
by associating with carriers such that 
carrier-state propagates to the nodes.  
Nodes are in `q.shared supplication` if 
their carriers are synchronized to be 
perpetually in the same state (this can be 
considered a refinement of the earlier definition).
Symbols in `SG;-scopes might derive from multiple 
sources: assume that scopes' symbol-list can be 
grouped into `i.declared` symbols internal to the 
scope, `i.argument` symbols bound to 
procedures' signatures, and (potentially) `i.global`/,
or perhaps `q.ambient` symbols 
shared among multiple scopes (`IauNC;'ll use 
`q.ambient` for the general case and `q.global` 
for analogs to `q.global variables` in 
typical programming language).  

`internewline;

`defin -> Tripartite Scope ->  `IauNCpl;'ll call `SG; scopes
`i.tripartite` in that they are mappings from symbol-names 
to carriers (or groups of state-synchronized carriers) 
with type-based states, and symbols can be 
classified as `i.declared`/, `i.argument`/, 
or `i.ambient`/.  The semantics of these groupings 
will be clarified below. ;;

`anondefin.
`IauNCpl; will say an `q.SG-described procedure`
(or just `q.procedure` when the `SG; topic is obvious) 
is an `SG;-sequence unfolding in a tripartite scope 
where argument-symbols are bound to values 
held by carriers in a `i.different` procedure (or, 
recursively, the same procedure in a different context, 
viz., different symbol-bindings).  Such 
interactions between `SG;-described procedures 
model the semantics of procedure calls.  
Of course, procedure-calls in turn are modeled by 
channelized neighborhoods in individual `SG;s.  
Specifically, channelized neighborhoods embody 
procedure-calls wherein peripheral nodes' 
carrier-states in the `i.calling` neighborhood 
become the basis for initializing carriers 
in the called procedure; specifically, 
the carriers bound to argument symbols in the 
latter's tripartite scope.  The switch 
in execution context from the calling to the 
called graph is analogous to binding symbols 
to values in process calculi, or beta-substitution 
in lambda calculus, except that carriers' 
connections (via their argument nodes) to 
procedure-nodes is organized via channels, 
which can affect procedure-call semantics.  
For example, it may be stipulated that 
carriers in channels modeling `q.outputs` are 
understood to be in pre-initialized state 
for the duration of called procedures' 
execution, and attempting to utilize 
(e.g., read values from) such carriers 
`i.within` the procedure is a logical error.  
There are various ways of enforcing this 
kind of restriction, of course, 
but channels offer a convenient 
representation of the relevant 
constraints viewed under a semantic interpretation.
`anondefin`
`p`


`p.
We now have a semantic interpretation of channelized 
neighborhoods: each such neighborhood embodies a 
procedure-call, which entails binding call-site 
carriers to procedures' argument symbols and 
then carrying through other procedure 
calls notated via `SG;s associated with 
the `i.called` procedures.  When they are 
finished, the original carriers will (potentially) 
be in a modified state, so the called 
procedure effectuates a `q.digamma reduction` 
on carriers around the calling site.  
State-changes then propagate across 
channelized neighborhoods insofar as 
values from output-like channels 
in one neighborhood are handed off 
to input-like channels in later-executed 
neighborhoods.  Each `SG; has a 
`q.top-level` neighborhood which is the 
last to `q.execute` (viz., compel a 
procedure-call) or, from a different 
perspective, the root of a directed acyclic 
graph showing carrier hand-offs and shared 
supplication across channelized neighborhoods.  
Note that output channels on the 
top-level neighborhood cannot be 
connected to other neighborhoods 
in the form of procedure outputs become 
inputs to a subsequent procedure 
(there is none) %-- so either 
top-level procedure-calls are 
useful solely for their side-effects 
or the carriers in their output-like 
channels are bound to symbols in the 
current scope.  In the general case, 
`IauNC;'ll say that an `SG; is `i.anchored` 
by one or more symbols if those 
symbols (strictly, the carriers 
associated with them) acquire values 
from the `SG;s top-level neighborhood 
(particularly from the channels 
there which obey output-like semantics).  
`p`

`p.
The mechanism just described constitutes 
how `i.declared` symbols in an 
`SG; tripartite scope can acquire values; 
they become initialized from procedure-calls 
enacted `i.in` the procedure, rather than 
from arguments passed `i.to` the procedure 
(or from an ambient space of values 
visible from multiple scopes).  Once initialized, 
declared symbols can then supply values 
for procedures called `i.inside` a procedure 
%--that is, an argument-symbol in one 
procedure can derived from a declared symbol 
in a calling procedure.  It is reasonable 
to assume in the typical case that all procedure-symbols 
(whether declared, argument, or ambient) hold 
values which originate from a `i.declared` symbol 
somewhere, so the anchoring-points 
where declared symbols are first initialized 
represent precisely the points in any holistic 
collection of `SG;-described procedures where 
new values are `q.introduced` into the system.
`p`


`p.
This last point has implications for how we 
theorize `i.typed values` as well.  Implicitly 
here `IauNC; have assumed that we are operating in a 
strongly-typed system where types and 
values are interconnected: any value is 
`i.typed` (an instantiation of a type) and 
types exists by virtue of their possible values.  
`IauNCpl; assume that in the general case types are
not equivalent to their `i.extensions`/, 
that is, to any fixed set of values.  
There are indeed some types whose extensions 
are fully `q.enumerable,` so we can specify 
exactly how many possible instances a type has: 
the type corresponding to signed one-byte 
integers, for example, denotes precisely 
the set of numbers at least -128 and at most 127 
(the analogous range for `i.unsigned` bytes 
is 0-255).  However, for types such as 
`i.lists` of integers, the extension cannot 
be specified `i.a priori`/, in the sense that 
it is impossible to know from a specific 
computing environment (at a specific moment 
in time) whether or not a particular 
value (here, a particular list of integers) 
which logically fits the type's criteria 
can in fact be represented.  The size of a list 
which may be instantiated is limited by 
factors such as the computer's available 
memory; in theory, the extent of a collection-type 
like `q.list of integers` is infinitely large, 
because there is no rule to group 
all potential such lists into a finite set 
(if there were, take the longest list, an 
an integer to the end, yielding a new 
list which has no reason not to be included in the 
first place).  `IauNCpl; assume moreover that
we are working in a `i.non-constructive` type 
environment where we cannot consider types' 
extensions as a logical construction abstracted 
from computational feasibility in concrete 
computing environments.  We can discuss 
types' `i.hypothetical` extension, which may indeed 
be infinite, but `IauNC; assume we need some 
other mechanism to manage uncertainties 
regarding types `i.actual` extension (in 
some contexts, such as lazy-evaluated lists 
or ranges, working directly with a logical 
model abstracted from actual realizability 
is appropriate, but in contrast to 
functional-programming theory, for example, 
`IauNC; do not take such `q.constructive` formalizations 
as an essential aspect to the relevant 
type systems).`footnote.
See `cite<NeusteinChristen>;, chapter 4, for a more 
extensive analysis of non-constructive 
type systems and why assuming 
that types are non-constructive in general 
(rather than the opposite) is practically appropriate. 
`footnote`
`p`


`p.
So as to give a rigorous semantics to `i.non-constructive` 
types, instead, `IauNC; leverage the interconnections 
between types, symbols, and `SG;-nodes insofar as 
we are working in an `SG; context.  Recall the 
heuristic that all symbols acquire values  
originating from declared symbols, which in turn 
have a specific initialization-point 
(although some symbols might be initialized 
by non-constant reference, passed into a 
procedure for initialization rather than 
being bound to a procedure-result, the 
values they are bound `i.to` in this 
case will itself be determined 
by an anchoring-initialization, either 
in that procedure itself or some 
other procedure called in turn; so, 
even if not all declared symbols 
receive their values via anchoring, 
all declared symbols receive values 
which `i.originate` from an anchoring 
somewhere).  In other words, when we say 
that a symbol has some type value, 
we mean that a symbol's value is 
derived from an initialization from anchoring 
point, where a declared symbol's value 
was set via digamma reduction at an anchoring 
point %-- the symbol was associated with a node 
which transitioned from a pre-initialized to a 
type-bound state as a result of binding to nodes 
in an output-like channel.  Symbols may be 
`q.re-anchored,` initialized to new values 
due to anchoring points, but (assume we 
work in a fixed-type environment) symbols 
and carriers retain the same types 
once they are initialized, so long as they 
remain in an initialized state.  Types 
themselves, then, can be construed 
in terms of continuities in carrier-state: once 
a carrier is initialized to be in a 
state determined by a type-instance, it will 
remain in states determined by the same type 
so long as it is initialized at all; and 
all initializations can be traced to 
anchoring-points, together with 
synchronization among states of distinct 
carriers.  We do not need to theorize types' logical 
extensions in general, because we aren't concerned 
with the totality of a type's possible 
values, only with the states directly 
associated with the type at specific 
anchoring-initialization sites. 
`p`



`p.
Many programming languages distinguish between `i.constructors`/, 
which are intrinsic to a type's definition, from other 
procedures that return values of a given type.  
To the degree that this distinction is in effect, 
any value can be traced back specifically to a 
`i.constructor` for its type.  To be sure, 
a value might be bound to the output of a 
`i.non`/-constructor procedure, but in 
that case this return value will have 
been formed initially by a constructor 
proper called in that procedure, or perhaps 
in a procedure it in turn calls, iteratively.  
In a channel system we can leverage a comparable 
distinction be defining a special kind of 
channel, which functions like a normal 
output except that procedures whose signature 
includes such a channel are considered 
to be constructors, or analogous to constructors 
(in `cite<NathanielChristenCyberphysical>; 
`IauNC; used the term `q.co-constructor` 
to suggest allowing procedures being analyzed as if 
they were constructors even in programming 
contexts where, for technical reasons, they 
would not be classified as such according to 
a programming language whose code is being analyzed).  
For generality `IauNC;'ll call procedures with 
constructor channels `q.co-constructors` with the 
assumption that different environments may be more 
or less lenient in conditions where co-constructors 
may be declared (only in code specifically 
defining a type, say, in contexts where a narrower 
policy is warranted, but without imposing restrictions 
along these lines `i.a priori`/).
`p`


`p.
The significance of co-constructor channels 
is that they allow us to pinpoint the 
specific anchorings where new typed values 
are assigned `i.ab initio`/.  Assuming an 
`SG; system uses co-constructors, 
for any carrier in a type-bound state 
we can be sure that the value traces back 
to a digamma reduction on a carrier 
specifically situated in a co-constructor 
channel.  As such, our semantics 
for types may not give a set-theoretic 
account of types' extensions, but we 
do have a mechanism for locating the 
origination point for all 
typed values.  In particular, values 
are acquired via carrier state 
changes localized to co-constructor 
channels; such a change only occurs 
when a procedure has completed with an 
initialized value in that channel 
available to be bound to its 
eventual symbol.  Any value 
therefore witnesses the fact that 
a procedure with a co-constructor 
channel completed and 
triggered a state-change accordingly.  
If a type system is designed to 
recognize types as (associated with) 
certain contracts, such that 
a type being instantiated 
confirms certain properties 
about the value thereby 
manifest, we can recognize 
such contracts in an `SG;-style 
system so long as co-constructors 
adhere to type-specific contracts 
in the course of depositing 
values in a co-constructor channel.
`p`

`p.
Once a carrier with a given type is initialized, 
its value can of course be handed off to other 
carriers assigned the same type (or potentially 
a supertype thereof, or some other 
related type wherein casting is possible).  
Channel systems and `SG; representations 
do not preclude polymorphism %-- 
specifically, the labels assigned to procedure-nodes 
need not uniquely identify one single 
procedure available to be called, but may 
instead provide a premise from which to 
select one of numerous available 
procedures, each with the same name %-- 
so type resolution may come into effect: 
if there are multiple candidate procedures, 
the one whose signature best matches 
the procedure-call's argument types is 
selected.  In the context of channels, 
such disambiguation extends to recognize 
different channel-kinds, which become 
part of a function's signature.  In 
effect, each node in a channelized 
neighborhood has a type (based on 
its carrier-state) that might be 
matched against candidate procedures' 
signatures.  Types therefore are 
consequential primarily in 
the context of overload-resolution.  
The issue here is not types' extension 
`i.per se` (two types having the same extension 
would have no bearing on their 
appropriateness for matching 
call-site neighborhoods to procedure 
signatures; and co-extensive types 
are not interconvertible unless such 
casts are implicitly declared according 
to the same conventions as casts between 
types with different extensions).  However, 
since successfully matching call-sites 
to signatures implies that all 
affected carriers' types are suitably 
aligned, whatever guarantees on 
carrier-states are implicit in 
type-bound states becomes transferred from 
the calling to the called procedure, insofar as 
the formers' carrier-states carry over to 
the latter's argument nodes.  Therefore, 
carrier-states associated with being initialized 
according to a given type propagate 
from co-constructor anchorings across all 
subsequent procedure-calls, with type-specific 
guarantees propagated alongside.
`p`

`p.  
In effect, types' semantics in such a framework 
is based on the premise that once there 
is an `i.originating` initialization 
via digamma reduction in a co-constructor 
channel then there is one specific carrier 
whose state is thereby changed, and 
subsequently (presumably) a series of 
further procedure-calls where that 
originating carrier's state become 
synchronized with subsequent carriers 
in subsequent procedure-calls.  
Each type is essentially a premise 
warranting the propagation of 
this shared carrier-state: the type's 
presence as a condition on procedure-signatures 
or on declared symbols indicates that a 
carrier whose state is synchronized in 
accordance with such propagation would 
be in a valid state according to the 
expectations of the procedure 
which uses the corresponding value.  
For the sake of discussion, `IauNC;'ll 
refer to this approach to the 
issue of type-semantics as a 
`i.propagation semantics`/, in contrast 
to a `i.set-theoretic` semantics 
which would construe types' semantic 
interpretations in terms of their 
extensions, or a `i.constructive` 
semantics which would read type 
semantics through the logic of 
constructive patterns that could give 
rise to values of a given type.   
The essential point about 
propagation semantics is that 
type contracts would be checked 
at origination points (to the degree 
that they are in effect) and  
presumed to have been enforced whenever 
there is an originating digamma reduction 
in the first place, and that subsequently 
any use of a type as a polymorphism-disambiguating 
device should proceed under the assumption that 
any carrier-state inherited as synchronized 
with the state of an originating carrier 
in this sense should be deemed a valid 
state for the called procedure's purposes. 
`p`


`p.
This discussion regarding type semantics has passed 
over some non-trivial details, such as issues 
of type casting and inheritance, which `IauNC; will 
briefly address in the next subsection.
`p`


`subsection.Distinguishing Non-Constructive from Extensional 
Type Semantics`
`p.
A plausible objection to the above presentation is 
that it is burdened with special terminology and representational 
conventions to define constructions which are 
not radically different from traditional 
notions of, say, stack frames and lambda-abstraction.  
Beyond just expanding from inputs and outputs 
to more flexible `q.channel` systems, `IauNC; have 
constructed a semantic interpretation for 
these systems based on formulations such as 
type-based states and channelized neighborhoods, 
without clarifying the theoretical merits of 
this overall semantic presentation.  My contention 
is that the full semantic details (not just, say, 
extending applicative structures to richer 
channel systems) become valuable in the 
context of Virtual Machines.  `IauNCpl; will
attempt to warrant this claim by addressing 
`VM; implementation, in particular.
`p`

`p.
`IauNCpl; suggest the idea of digamma reduction and
propagation-from-constructors to 
replace extensional and/or constructive semantics 
for type theory.  Implicitly, then, `IauNC; 
propose that (what `IauNC; here call) `q.propagation` 
semantics can displace two other 
paradigms for type theory, `i.extensional` and 
`i.constructive`/.  `IauNCpl; will try to defend the idea
first that this is a reasonable three-fold 
division in options for type `q.semantics` 
and second that there are formal or theoretical 
merits to the `q.propagation` approach.
`p`

`p.
An extensional semantics would 
essentially proceed by grounding the semantics 
of any specific type in the set of its 
possible inhabitants.  To attribute a type to 
a value is thereby to assert that the value 
belongs to the type's extension-set.  
This paradigm has certain benefits, to be 
sure, such as providing an elegant 
approach to functions defined on a type 
which have different behaviors for different 
parts of the extension.  As a canonical 
example, a procedure operating on list-like 
types may require one implementation when 
the lists are empty and a different one 
when they are non-empty.  Writing functions 
with distinct code-bodies for different 
extensional alternatives (another example 
would be types with possible `q.null` values, 
such as `b.Maybe` in Haskell or pointers 
in `C;/`Cpp;) is a widespread practice 
in functional programming.  Extensional 
semantics gives a concise reading to this 
coding style: insofar as types semantically 
are effectively equivalent to their 
extensions, any function defined over a 
covering collection of extension-parts 
is equivalent to a function defined over 
the type as a whole. 
`p`


`p.
On the other hand, we can model extension-partitions 
and the prospect of quantifying over them as a 
feature for procedural implementation 
without actually equating types with extensions; 
we merely need to posit that types 
can be `i.associated` with extensions in such a 
way that extension-partitions are well-founded.  
Even where types have nondeterministic extensions, 
such associations work so long as 
code using their partitions tolerates 
similar nondeterminism at the partition level.  
For example, the nondeterministic facet 
of list-like types lies with non-empty types, 
because there is no way to know how large 
instances can be (in practice), so this 
uncertainty translates to the part of their 
extension including non-empty instances.  
But code working with such types has to 
accept uncertainty anyhow (for instance, 
by recognizing that extending a list's size 
might fail), so the proper accommodations 
need merely be accepted in code narrowed 
to an extension-part that would be present 
in code without extension-alternation. 
`p`

`p.
A larger issue is perhaps `i.how` extension-partition 
alternatives should work; in particular, whether 
mapping a value to one partition or another 
is a compile-time or runtime operation.  
The code-over-alternatives paradigm isn't 
only a notational convenience; it manifests 
benefits of functional languages' type system 
which allows questions like whether lists are 
empty to be resolved at compile time (at least 
more often than other languages).  If we have a 
function written so that the code branches 
differently for empty and non-empty lists 
(or, say, for valid and null pointers) the 
relevant programming language might treat this 
as an alternative to be resolved at compile 
time or as something deferred to runtime 
(so that the alternatives exist more or 
less like if-then execution paths), or some combination.  
Ideally, it seems, a language engine would 
compile-time optimize when possible but 
allow decisions to be deferred to runtime 
when necessary (rather than insisting on 
compile-time uncertainty renders code 
non-compilable at all).  By analogy, a 
compiler might reasonably stipulate 
that type-attribution ambiguity 
(as when procedures have two equally 
valid overloads, say) is a logic error 
such that offending code should not compile 
(unless types are deliberately chosen 
for pre-runtime ambiguity as with 
`q.variant` types, such as `b.boost::any`/) but 
ambiguity in how to map values to 
types' extensional `i.partitions` should 
not necessarily foreclose compilation 
in the same manner.
`p`

`p.
These, however, are issues in the context 
of tracking compile- and runtime information 
about values, and quality of a language's 
support for managing value-partition 
mapping is an orthogonal matter to 
the semantic interpretation of partitions.  
In general, languages can take advantage
of extension-based reasoning without 
embracing the theory that types are 
semantically derived from their extensions. 
`p`


`p.
Moreover, we can similarly distinguish 
types' semantics from construction-sequences, 
in that constructive type theory 
essentially works by using construction patterns 
as a model for type-extensions, so that 
the extension embodied by that model 
fixes the type's semantics.  Every non-empty list, 
say, may be derived from a smaller-by-one list 
by appending a specific value to its end; 
so for any list there is a specific construction-sequence 
which terminates at that list, and we can take the 
set of those sequences as a model for the 
list-type's extension.  Extension partitions 
can then be defined over distinct construction-patterns.  
In the case of lists, non-empty list derivation 
via smaller-by-one instances is analogous to 
marking values which can be constructed according 
to a specific pattern (involving a different list 
and an `b.append` operation), so the 
non-empty part of the extension is precisely 
the set of instances constructible via that 
pattern.  This is the rationale for 
functional programming languages branching 
over construction patterns. 
`p`


`p.
Constructing lists from their smaller-by-one 
kin actually leverages two facets of 
`q.constructive` types: first, that for any 
given value of a given type we can identify 
a constructor which produces that value; 
and, second, that construction-sequences 
are isomorphic to the type's extension and 
therefore `q.model` the type, in the manner 
that sets endowed with specific operations 
model `q.theories` (i.e., axiom-combinations) 
in symbolic logic.  Unless we consider these 
notions only as logical abstractions, however, in 
concrete programming they are often wrong, 
or at least misleading.  If a procedure is supplied 
a pointer to a list (any list-like type) there is no 
way to determine a construction-sequence for that 
value short of examining each item in the list one 
at a time %-- especially if the pointer 
is derived from a binary stream supplied by 
some external component, along the lines 
of cross-application interop discussed in Chapter 
20. There isn't even a guarantee that 
we can learn the `i.length` of the list without 
similarly scanning the whole value.  The presence 
of a `b.size()` like procedure depends on the 
public interface, and there are scenarios (such as `b.stacks` 
and `b.queues`/) where the type may only provide 
`b.push`//`b.pop` (or `b.enqueue`//`b.dequeue`/) 
access to the collection's state, and no size-related 
(public) functions apart from a test for `b.empty()`/.  
In these cases functional-programming idioms 
related to treating each value as a destructured 
head/tail pairing have no optimization value 
compared to procedural if...then branching 
(although a language could still support these 
idioms as `q.syntactic sugar`/).
`p`

`p. 
Of course, collections types `i.could` be engineered 
so that destructuring becomes convenient.  If resizable 
lists are stored via multiple inverted arrays 
(so that the list-head always has smaller memory 
addresses than its preceding elements) then obtaining a 
reference to the smaller-by-one `q.tail` becomes  
just pointer arithmetic (we use multiple 
array-allocations rather than one single array 
to ensure that elements never have to be moved 
in memory, which would invalidate pointers/iterators, 
if the list's size grows beyond the memory 
initially requested for it).  In general, then, 
the idea of `q.constructive` types %-- seen not as a 
theoretical issue of type semantics but as a tool 
modeled in source code %-- depends on how types 
themselves are engineered, their memory-management 
protocols and public interface.  Similar comments 
could be made about extension-partitions.  
Rather than a logical paradigm, we can 
treat `i.extensional` and (or and/or) `i.constructive` 
semantics as `i.design patterns` which may 
guide `i.some` types' implementations (in the 
sense of code libraries that realize types via 
providing implementations of their needed procedures).             
`p`


`p.
Again, though, the fact that some types 
can be associated with extension-partitions 
defined via construction-patterns need 
not signal the semantic equivalence of 
types and type extensions (or type-extensions 
and construction-sequences).  While 
recognizing extensional reasoning as 
a useful tool for language implementation, 
`IauNC; believe that it is more conceptually 
accurate to model types' semantics 
instead via `q.non-constructive` notions `IauNC; discuss 
here, such as digamma reduction, co-constructor 
channels, and carrier-state propagation.  
In other words, `IauNC; believe that this 
latter group of formulations better 
capture how people reason about 
computer code and design patterns 
`i.in the general case`/, only switching 
to the alternative semantics when 
types' explicit designs warrant as much.
`p`

`p.
This argument, however, is localized to the 
question of defining semantics for 
type systems, which is arguably a philosophical 
issue more than a directly 
practical one.  `IauNCpl; intend to refine the
discussion by considering how the 
semantic notions hereby sketched out 
could yield practical benefits.  
In this context `IauNC; will focus 
on the hypergraph structure of 
computer code (within the framework 
of `q.syntagmatic` graphs) and 
the use of channels as structuring 
vehicles.
`p`

`subsection.Syntagmatic Graph Sequences as a Virtual Machine Protocol`
`p.
`IauNCpl; `amNC; representing Syntagmatic Graphs as hypergraphs,
in two senses: partly, for one, 
because `i.channels` embody a grouping 
operation (gathering multiple edges, by analogous 
to hypernodes being sets of nodes %-- although 
channels are not identical to hyper`i.edges`/, 
wherein `i.one` edge spans multiple nodes).  
Second, `IauNC; also leave open the possibility of `SG; nodes 
having internal structure (i.e., becoming hypernodes).  
However, such hypergraph representation is 
mostly heuristic; technically, `IauNC; consider 
hypergraphs to be essentially a visual shorthand 
for `i.virtual machine` constructions.  Here `IauNC; appeal 
to comments `IauNC; made in Chapter 20: a hypergraph 
(or, in essence, any structured representation) 
iconifies the series of steps 
needed to construct it in its precise state.  
For example, focusing on channelized neighborhoods, 
the elements of such structures %-- procedure nodes, 
peripheral nodes, and channels %-- correlate with 
operations setting out these details sequentially 
(identifying a procedure node, e.g., by label; 
identifying a channel-kind to serve as a 
context for subsequent peripheral nodes; initializing 
the latter nodes; switching to a different channel-kind 
as needed; and so on).  This outline could be 
expanded to Syntagmatic Graphs in general by aggregating 
multiple channelized neighborhoods and then 
asserting where carrier handoffs (via cross-neighorhood 
edges) occur, to `SG;-sequences by constructing 
multiple `SG;s along with their respective anchorings; 
and finally to procedure-descriptions by enumerating 
declared, argument, and ambient symbols in a 
tripartite scope.  From this perspective, 
`SG; procedures can be seen as compact representations 
summarizing sequences of `VM; operations, or 
perhaps as configurations which guide the construction of 
`VM; procedures by defining and end-goal toward which 
`VM; operations approach incrementally.        
`p`


`p.
Ordinary `VM;s, of course, depend on such concepts as 
stack frames and procedure calls; one of the fundamental 
operations (or sequences thereof) typical `VM;s 
carry out involves push input values onto a stack 
and then redirecting to the address of a procedure 
which uses them, at least insofar as the `VM; in 
question emulates assembly code to provide a 
runtime for higher-level programming languages.  
Modeling procedure-calls via hypergraphs, and 
in particular `i.channels` (in the sense `IauNC; propose here) 
adds representational parameters to this model, 
by analogy to how hypergraphs present a richer 
expressive tableau than other metamodels for 
encoding data structures.  The benefits of added 
metamodeling detailing the procedure-call 
context actually help illustrate why 
expressivity pays dividends with respect to 
data structures (e.g., in query evaluation) as well. 
`p`


`p.
The primary rationale for `VM;s is to execute code, of course 
(whether scripts, queries, or some other programming 
category that does not feat neatly into one or the 
other, such as workflows, or one or both ends of 
remote-service functionality).  Secondarily, `VM; compilation 
can support static code analysis even if the 
intermediate code is not actually run.  Code analysis factors into 
execution as well, at least to the degree that a 
`VM; can internally support runtime checks and 
guarantees %-- insert debugging breaks where certain 
conditions are met, preventing code from running 
in certain circumstances, allowing procedures 
to make contract-like assumptions (stronger than 
type-checks alone could enforce), and so on.  
For example, stipulations that values should fit 
within a fixed range (narrower than theoretically 
possible via their types) could potentially 
be verified or implemented by weaving 
`q.gatekeeping` code into `VM; operation-sequences.  
In short, `VM;s acquire more flexible capabilities 
%-- they present opportunities to implement Requirements 
Engineering style features, even if only via 
add-ons %-- to the degree that they present 
op-sets and data models configured for static 
and dynamic/runtime analysis.  These 
observations motivate `myNC; proposals to augment
the modeling parameters for `VM;s (in procedure-call 
contexts) via formulations such as 
channels and carrier-state.  
`p`


`p.
To be sure, a suite of static-analysis capabilities 
is endemic to traditional (e.g., stack-based) 
`VM;s as well (reachability, control paths, initialization 
guarantees, etc.).  `IauNCpl; would suggest, however, that
future generations of `VM; technology will seek 
a broader scope `visavis; contexts where code analysis 
is applied, considering `GUI; programming, 
Cyber-Physical Systems, multi-modal front-ends, 
`AI; integration, and other capabilities that 
may be unified under the rubric of `q.Industry 4.0.`  
Future `VM; architecture may be optimized 
for the `i.intersection` of such User-Experience and 
multi-modality concerns with traditional 
static analysis and Requirements Engineering. 
`p`


`p.
Consider the case of Channel Systems.  According 
to the `SG; model `IauNC; have outlined here, 
procedure-calls are represented via channelized 
neighborhoods, and in such neighborhoods 
all edges incident to a central (`q.procedure`/) 
node lie within a channel.  In `VM; translation, 
this configuration implies that procedural 
stack frames are split up into multiple channels, 
so that whenever an argument is `q.pushed` as a 
parameter for some near-future call this 
action occurs in the context of a specific 
channel-kind.  As a result, argument-push 
operations may be analyzed in terms of semantic 
protocols specific to the currently active 
channel.  For example, `VM;s might want to 
add extra information in the 
context of channels representing `q.message receivers` 
in Object-Oriented contexts (which 
`IauNC; have earlier alluded to as `q.sigma` channels, essentially 
the `b.this` or `b.self` of languages like `Cpp;, `Java;, 
`Rust;, etc.), particularly when such channels 
contain more than one node (insofar as most languages 
providing kernel functions accessed from a `VM; 
do not allow multiple `b.this` objects: the 
demo code for this part's chapters has examples of 
how to emulate multi-sigma calls in `Cpp;, but 
in general it would presumably take extra 
effort to map multi-sigma `VM; calls to the underlying 
native functions).  Moreover, channel-specific 
semantics can be implemented on an extensible 
basis, allowing the `VM;s to be augmented 
with special-purpose channel kinds which supply their 
own functionality for managing (in effect) stack 
frames when such channels are active.
`p`

`p.
Furthermore, channels can act as a grouping mechanism 
tieing together procedure arguments which are logically 
interconnected (to a greater degree than merely co-existing 
as arguments).  An example would be unit/scale-decorated 
types: suppose a function calculates a formula which 
requires two arguments with the same dimension and measurement 
units (kilometers, say) plus a third argument which 
is just a scalar; evidently the first two arguments are 
mutually constrained in a fashion distinct from the third.  
Or consider a calculation with a scalar plus two mathematical vectors 
which should have the same length %-- the latter condition 
might be modeled with a dependent-type construction on the second 
vector, or some runtime check for the two vectors together, 
in either case demarcating the vectors as paired arguments 
distinct from the scalar.  One strategy to satisfy these 
runtime use-cases would be to implement channel semantics
where special guarantees (finer than type-checking alone) 
are enforced while the channels are being populated.`footnote.
In this case the one-channel-kind-per-neighborhood restriction 
might be relaxed, since mutual connections could exist 
between (say) some input parameters and not others; or 
one could adopt something like `q.subchannels` which 
semantically refine the channels around them.
`footnote`
`p`

`p.
Doubtless, some of the features enabled by channels 
could be achieved via other means.`footnote.
For example, 
aggregating input parameters as mentioned last paragraph 
might be achieved alternatively via explicit 
dependent typing or via smashing tuples into 
single (aggregate) arguments.  However, dependent 
types are notoriously difficult to implement 
in the context of Software Language Engineering, 
and the latter alternative could be syntactically 
unwieldy (if done explicitly in source code) 
or complex in its own right to implement 
(if done behind the scenes).
`footnote`  Channels, 
however, present a convenient interface for 
organizing the range of functionality 
entailed by the relevant channel semantics.  
Insofar as every argument-node in an `SG; 
occurs in the context of a channel, before 
any such nodes are set in place the `VM; 
would first construct a channel of the 
relevant kind; that is, there is a specific 
operation to `q.open` a channel given its 
kind.  This operation is therefore an `VM;-site 
(for static or dynamic analysis) that 
can be targeted by extension code enforcing or 
examining channel semantics.  Once channels 
are opened, operations exist to 
indicate the type and value-source for nodes 
added to the channel.  Because these latter 
operations always occur in the context of a 
specific channel-kind, they can be filtered or 
re-implemented based on the channel kind 
in effect, so extensions could modify the 
treatment of certain channels while preserving 
the underlying `VM; implementation in most 
cases.  For example, a `VM; extension could 
modify exception-handling protocols by 
re-implementing operations for inserting 
nodes into (or, on the call side, initializing 
carriers in) special `q.exception` channels, 
which are partitioned from `q.ordinary` 
output channels (given the obvious behavioral contrast 
between exiting via exceptions versus normal 
returns).  Procedures typically involve multiple 
channels, so there are `VM; operations 
for `q.closing` one channel and opening another 
of a different kind, which results in subsequent 
operations occurring in the context of a 
different semantics.  Explicitly introducing 
channels as part of the underlying `VM; machinery 
allows variegated channel-semantic protocols 
to be implemented in an organized and extensible manner. 
`p`


`p.
Last paragraph's 
discussion regarding (for instance) special-purpose 
channel semantics perhaps does not obviously 
connect the idiosyncratic constructions endemic 
to `SG; representation with concerns in the 
latter sense, so `IauNC;'ll try to present a case 
more concretely.  Consider first the 
issue of `q.reactive programming` in `GUI; 
contexts.  Analysis of procedures as a series 
of calls to other procedures %-- what `IauNC; `amNC;
calling `SG;-sequence descriptions %-- fails 
to directly address how call-sequences 
in this sense fit into over application execution 
(`IauNC; touched on this theme at the 
start of Chapter 20, as well).  
In general, an application is not a one-dimensional 
`i.program` which simply executes some sequence of 
operations and then terminates.  Instead, applications 
construct a graphical and runtime environment 
and then wait for user-initiated actions, 
responding accordingly, and resetting to a 
passive state awaiting further user actions.  
Users signal their intention for applications 
to take specific steps via interactions 
which can generically be called 
`i.gestures` (e.g., typing something 
via a keypad, or clicking somewhere via 
a mouse).  Gestures in turn are presented 
to application code as `i.signals` that 
are `i.handled` by implemented procedures.  
The overall programming model entailed 
by composing applications as collections 
of procedures poised to handle signals 
%-- rather than fixed operation-sequences 
designed in advanced %-- is generically 
called `i.reactive` or (with some 
additional technical specifications) 
`i.functional-reactive` 
programming `cite<SchusterFlanagan>;, 
`cite<PaulHudak>;, `cite<BerndFinkbeiner>;, 
`cite<KoheiSuzuki>;, `cite<SamVandenVonder>;,
`cite<PerezNilsson>;.  Such a 
programming model introduces a variety of 
issues for `VM; implementation, at least for 
`VM;s which model/analyze 
or execute reactive procedures.
`p`


`p.
In particular, the central idea of reactive 
programming is that certain procedures 
are called (or initiated) in response 
to signals (typically those 
due to user gestures, though certain 
signals may be prompted by non-user 
changes to the current environment 
which might be relevant for applications, 
such as a sudden loss or gain of 
internet connectivity).`footnote.
More precisely %-- because there are not 
necessarily signals which actually 
notify applications about, say, 
network-connection changes %-- a dropped 
connection would implicitly `i.cause` 
signals to be emitted.  For example, 
an object representing a web request 
could emit a network-error signal 
rather than a usual `q.finished` signal. 
`footnote`  Procedures 
in this sense are not called `i.from other 
procedures`/, so the normal analysis of 
procedure-calls in terms of stack frames 
being transferred from one site to another 
has to be modified.  A canonical approach to 
reactive programming involves `i.signals` 
and `i.slots`/, with the idea that 
instead of one procedure directly calling 
calling another, procedures instead emit 
`q.signals` that are `i.connected` to 
other procedures, which in such contexts 
become `q.slots.`  Unlike hard-coded 
procedure-calls, signal-to-slot connections 
can be dynamically altered, created, or 
suspended.  Such a mechanism depends on a 
centralized routing component 
to observe when a signal has been emitted 
(for instance, added on to an `q.event queue`/) 
and transfer control to one or more 
slots registered as connected to that signal.  
Insofar as a centralized processor in this 
sense is active, it can also (in typical 
application-runtime frameworks) 
receive signals originating `i.outside` 
the application, i.e., resulting from 
external conditions apart from one 
`i.procedure` emitting a signals.  Typically, 
such external signals would result from 
user-generated events, such as clicking a 
mouse button or moving the mouse.      
`p`


`p.
In effect, application code based on signals and 
slots includes some procedures which are 
called because they are registered as `q.slots` 
whose signatures match signals that 
may arise from `i.outside` the application 
property.  These procedures serve as `q.entry points` 
where operations specific to the application 
originate.  In other words, applications 
are environments which, after an initial setup, 
wait in suspension until external signals 
initiate a chain of actions in response.  
The details of such signals cannot be known 
ahead of time %-- for example, one cannot 
say which user gestures will occur (whether 
the user first types something, or moves 
the mouse, or clicks the mouse, etc.) nor 
their specific details (which keyboard keys 
are pressed, which mouse buttons are clicked, 
where on-screen the mouse-cursor is located 
in the latter event, etc.).  Application 
code therefore needs to prepare for 
multiple forms of external signals, 
and to analyze their properties to respond 
correctly (in accord with user intentions 
and/or design requirements).  A left mouse click 
with the cursor hovering over one `GUI; 
element typically signifies a different user 
intent than a right-mouse click over a 
different element, for example.
`p`


`p.
The unique characteristics of reactive programming 
have numerous consequences for `VM; design.  
First, note that applications typically 
implement many procedures so as to possess 
requisite capabilities to handle user actions.  
When and whether a given procedure is called 
depends on user pragmatics; for instance, a 
procedure involved in saving a file (at least a 
file users know about, as opposed to, 
e.g., a database-related file storing configuration 
information) would only 
be called in circumstances where users signal 
their desire to save files they are 
currently working on.  A well-organized code base 
will specify which procedures could 
potentially be called as the `i.initial` handler 
responding to external signals.  This information 
makes it possible to factor in external 
signaling conditions during code-analysis.  
For example, suppose file-saving is disabled 
for some reason (e.g., the current user does not 
have permission to modify the local file system).  
In that case, procedures which are `i.only` called 
within a call-chain leading from external 
signals specific to saving files would become 
effectively unreachable.  Notions such as 
reachability and execution paths have 
to be evaluated in the context of 
procedures registered as external signal-handlers.
`p`


`p.
Consider a scenario where an application, being upgraded, 
is redesigned to support two different file-handling 
models: one for local filesystems and one for cloud 
storage.  Certain procedures (e.g., one to check 
whether the file has been modified since the time 
of last save) may be relevant for both scenarios; 
others would only be active in contexts where 
cloud-saving is possible (an open internet connection, say) 
or, respectively, local file-system access.  Introducing 
new procedures to manage the cloud-storage case 
alters the applications inter-procedural `q.connectivity,` 
potentially requiring analyses to be updated 
with respect to conditions wherein a certain 
procedure might be called (or might be 
unreachable).  The fact that such information 
`i.about` applications is subject to change 
(insofar as applications are continually 
refined or redesigned) indicates that information 
`i.about` application code should be managed in a 
systematic fashion.  This might be 
done through `VM; representations directly, 
or at least source code and/or documentation 
`i.available` to `VM; compilers can draw 
meta-data from such sources.  In other words, 
we can assume that applications are engineered 
in coding environments where information 
(including, for example, which procedures 
play the role of external signal-handlers) 
is detailed with enough rigor to be 
read by `VM; compilers and/or runtimes.  
For example, `VM; code could then internally 
incorporate representations related 
to reactive control flow and `GUI; objects 
which iconify pragmas for initiating 
application actions from users' points of view. 
`p`


`p.
Analogous to `q.co-constructor channels` as 
special-purpose sites notating the 
origination of typed `i.values`/, a 
channel-based `VM; could similarly support 
special-purpose `i.input` channels 
which carry external-signal data 
(we might call these `q.reactive` channels).  
In the same way that `q.co-constructors` 
are declared by providing co-constructor 
channels, external-signal handlers could 
then be identified through the presence 
of reactive channels.  This makes it 
easy to identify all execution points 
where external signals could 
trigger procedure-chains: simply observe 
for whenever a reactive channel is `q.opened` 
during the course of building a 
channelized neighborhood.     
`p`


`p.
Functional-Reactive Programming (`FRP;) has engendered 
various strategies and analyses for extending 
type systems to incorporate signal/slot 
signature (how should signals a slots 
be assigned functional types, because 
they are different from ordinary 
procedures)?  Channel systems offer 
one solution to this problem, because 
channel-semantics and carrier-state 
are available as modeling parameters 
orthogonal to types themselves.  
For instance, slot-procedures 
and the signals they specifically 
respond to would not need to be notated 
with special type variants 
(like `q.World` environments or 
`q.discrete time` or other constructions 
endemic to `FRP;); instead, we could 
stipulate that idiosyncratic 
`i.channel kinds` designate specific 
procedures as signals or slots; carriers 
`i.in` those channels would hold 
normal typed values.
`p`


`p.
External signals (as initiators of procedure-chains 
that disrupt applications' passive `q.event-loop` 
states) offer one example of how reactive programming 
and `VM; design intersect, but there are 
related scenarios that could also be mentioned.  
For example, applications' `GUI;s are typically 
seen as a `TwoD; visual extent populated with 
viewable objects that are simultaneously 
spaces to represent pieces of information to 
users (e.g., text, via readable characters; 
or numbers, via printed characters or indicators 
like dials and sliders; or graphics, via image 
or `ThreeD; displays) and origination-points 
for user gestures (e.g., scrolling on a slider 
to increase/decrease a value).  My above comments 
touched on the latter capabilities, but 
interpreting user gestures depends on the 
information currently presented through the 
relevant `GUI; control.  As such, it is 
useful to track systematically how 
`GUI;s are populated with data.  A useful 
maxim is that each class representing 
distinct `GUI; controls should be 
paired with a separate class representing 
the data which is visible within 
such controls.  This is straightforward 
if a control (or in general a `GUI; `q.gadget`/) 
indicates one simple quantity (consider a slider 
that adjusts the zoom-level for viewing an image), 
but even more complex `GUI; areas whose display 
is spread over multiple subcontrols can be associated 
with a multi-field datatype (these sorts 
of correlations are analyzed further 
in Chapter 24).  Two datatypes 
are then closely interconnected: one represents 
some data-aggregate from a computational 
perspective (ensuring that all fields are properly 
initialized, packaging the data for persistence 
or serialization, and so forth) while the 
other translates the same information into 
visual indicators for user interaction.  
To the degree that `GUI; and application-level 
datatypes are closely aligned, `VM; code 
can be annotated to mark and leverage such 
alignment.      
`p`


`p.
In general %-- continuing these `GUI;-related 
examples %-- inter-connections between `GUI; 
components, user actions, and the datatypes 
shown and affected by either tend to appear 
in multiple contexts.  Consider (as above) 
an image zoom level, indicated (and adjusted) 
by a slider-control.  It is not uncommon for 
zooming (in and out) also to be initiated by 
small arrows adjacent to a slider, or by 
context-menu options on image-displays themselves, 
or by keystroke sequences like control-plus either 
plus or minus (holding the `q.control` key and 
tapping the `q.plus` or `q.minus` keys to increase 
or decrease zoom).  Presumably, altering zoom levels 
via these other gestures should cause the 
zoom-slider to be adjusted proportionately.  
There are, then, potentially five different 
gestures which might affect zoom levels, each associated 
with `GUI; controls in different ways: directly 
interacting with either a slider or arrow buttons, 
or via a context menu (within an image-display), plus 
via keyboard actions.  Such interrelationships 
should be tracked with some degree of rigor to 
maintain a consistent `q.User Experience.`
`p`

`p.
Continuing this example, a common pattern in `GUI; programming 
is top implement `q.tool tips,` or floating text 
blurbs that appear when users hover over `GUI; controls, 
explaining the purpose and pragmatics associated 
with the control itself.  Insofar as multiple controls 
can be used for image-zoom, each should be 
provided tool-tip text accordingly; it would 
be useful to confirm that policies along these 
links are sustained in an application code-base, 
ideally via static code-analysis.  Important 
gesture/feature connections need be programmed 
in multiple contexts, apart from the underlying 
signal-handlers themselves, including tool-tips, 
help-menu information, documentation, application 
history and undo/redo capabilities, 
notifications (e.g., small labels sometimes 
displayed near the bottom of application
windows clarifying recent actions, such as a 
string confirming that an image was zoom to a particular 
percentage) and unit or integration testing.     
`p`


`p.
Or, consider again issues with application upgrades.  
In the example `IauNC; suggested `visavis; cloud versus 
filesystem saves, there may be multiple controls 
and data types associated with the cloud 
functionality, including windows where 
users register credentials to access a cloud 
service and strings giving a remote path 
for files on cloud servers %-- each of the 
`GUI; elements presenting the corresponding strings 
(path names, users names, passwords, etc.) are 
logically interconnected by their common utility 
in the guise of cloud file backup.  Meanwhile, the 
`q.image zoom` case can likewise be extended to 
hypothetical `q.upgrade` examples: consider the 
fact that some image displays use modified 
`i.mouse gestures` for zooms, such as cursor up/down 
with a key pressed, often the shift key (these 
pragmas are borrowed from `ThreeD; displays, which try 
to fit the 6 or 12 degrees of freedom in `ThreeD; graphics 
to conventional mouse and keyboard gestures 
%-- rotations; zoom; and translations, i.e. moving 
parallel to x, y, or z axes; each of which can 
occur within the model or within the `q.camera` %-- using 
the keyboard to compensate for mouse-move gestures 
have only `i.two` degrees of freedom).  Consider an 
application which decides to support this latter 
`ThreeD;-style zoom gesture added on to prior 
functionality; this decision would propagate to 
concerns such as those itemized at the end 
of last paragraph (test suites, documentation, 
help menus, undo/redo, etc.).  Applications
which tend to be intuitive and responsive 
from a User Experience point of view 
%-- where it is easy for users to understand 
how to initiate their desired actions 
by interacting with the software, and 
to learn the requisite steps when they 
do not know the pragmas ahead to time 
%-- consistently model the full 
network of interconnections between 
application-level capabilities, 
`GUI; display elements, and user pragmatics.
`p`


`p.
It is also worth pointing out that such 
goals overlap with database engineering.  
Controls to set zoom levels may be 
factored in to a database profile 
insofar as the optimal (or most recent) 
zoom level for viewing an image might 
be stored as one metadata-point in an 
image database.  Similarly, a file's 
cloud-hosted save-path would be a relevant 
piece of information to track in a database 
for which that file is an external resource-object.  
Cyber-Physical networks belong in the 
discussion as well: `CPS; devices, for 
example, tend to have quantitative 
profiles (data ranges and measurement units) 
which would be relevant both for database 
persistence and for `GUI; admin controls.  
When a `GUI; indicator models 
`CPS; sensor readings or actuator settings 
(a thermostat's temperature level, say) the 
relevant value-range and units 
(e.g., Fahrenheit or Celsius) should 
be explicated in `GUI; code (obviously, an 
indicator needs to know how each value to 
be displayed compares to valid minima/maxima, 
and should identify and clarify for 
the user, perhaps supporting alternation between, 
Fahrenheit/Celsius, or metric/imperial, and so forth).
`p`



