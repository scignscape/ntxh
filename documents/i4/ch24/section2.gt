`section.GUIs, Robots, and Environments`
`p.
Current paradigms in desktop-style `GUI; engineering 
have stayed relatively consistent since 
roughly the start of the century.  The heyday of 
`GUI; applications (often called `q.rich client` 
or `q.thick client` interfaces, to distinguish 
them from web applications %-- `q.thin` clients %-- which need to 
run in an internet browser) largely coincided 
with a period in programming methods where 
Object Oriented techniques were predominant.  
Neither Object-Orientation (`OO;) nor desktop-style 
software is canonical to the same degree 
as two decades ago, given the emergence of 
popular programming language which 
de-emphasize `OO; structures on the one 
hand, and web or smart-phone apps as an alternative 
to desktop environments on the other.  
However, for many categories of 
software %-- for instance, Scientific Computing, 
or for that matter the `IDE;s (Integrated 
Development Environments) that programmers 
use to write other programs (of all 
varieties) %-- desktop technology 
remains the only feasible option.  It is impractical 
to engineer applications that work in web 
browsers or within the limited screen-size of a 
smart phone, once applications get past a 
certain threshold of functional and 
presentational complexity.  For this discussion, then, 
I will refer to `GUI; applications as canonically 
native-compiled software components that run on a 
desktop computer or a similar environment 
(as opposed, for example, to web applications 
which are viewed in a browser and run by 
code interpreted through the browser rather 
than compiled to native machine instructions).        
`p`


`p.
Object-Oriented techniques remain the predominant 
method for `GUI; development in this sense, 
largely withstanding the familiar criticisms  
leveled against the `OO; paradigm in other contexts 
(such as database or server-side programming).  It is reasonable 
to conclude that `OO; is an effective 
modeling tool for `GUI; functionality, one 
which cannot readily be replicated by functional 
programming (`FP;) langauges, for example 
(to prove the point, consider that `FP; bindings to 
`GUI; software libraries, particularly cross-platform 
ones %-- i.e., intermediate libraries that 
allow `FP; code to construct and manipulate 
`GUI;s %-- are notoriously buggy, poorly maintained, 
and/or difficult to use; for example, compiling and 
merging these libraries with an application's 
overall code base tends to be more difficult 
with `FP; bindings than using `OO; libaries 
written in native languages, such as `Cpp;, directly). 
So, again narrowing the focus of the current 
discussion, we may consider general-purpose models 
of `GUI; elements and structures to be 
preeminently Object-Oriented.   
`p`


`p.
Accordingly, `GUI; elements are canonically 
objects with state (`FP; langauges often 
are designed around `q.stateless` values, but 
in the `GUI; context recognizing 
mutable state appears to be the 
most natural digital encoding of the 
phenomenon being programmed, namely 
visible windows and parts thereof 
wherein applications present information 
to users).  There are several different 
facets of `GUI; object-state, which may 
be grouped into three overall categories:

`description,

`item ->> Visual Style ;;  Effective 
`GUI; design often depends on conscientious 
choices for colors and other visual details.  
This is particularly true because the 
visual appearance of `GUI; elements includes 
not only how they appear in their `q.normal` 
state, but also how their appearance is 
subtely modified as a cue to users trying 
to orient themselves `visavis; applications' 
interactive features.  For example, 
`GUI; buttons and clickable spans of text 
almost always provide some visual 
indication that these are not only 
static elements, but can respond to 
user events, such as clicking the 
mouse while the cursor hovers over a button.  
To help guide users, buttons (and text, when 
appropriate, plus other clickable `GUI; controls) 
take on a different style, usually with 
a variant color scheme, when the cursor 
`q.hovers` over the element (sometimes called a 
`q.mouseover` or `q.rollover` state) %-- this visual cue 
shows that the control is indeed clickable 
and that the mouse is currently positioned 
on the item, so that clicking the mouse 
(via a physical mouse-button) is understood 
to be an action for `q.clicking` the 
(virtual) `GUI; button/control.  Once a button 
`i.is` clicked and while the reponse is 
progressing, a button may appear in a 
`q.down` state, which has a style distinct 
from both normal and rollover.

`pseudoIndent;  Alternatively, 
some buttons (or other controls, such as 
checkboxes) are not primarily designed 
for requesting a specific action, but 
rather to set some flag or indicator 
(e.g., a checkbox in a `GUI; area related 
to text-searching would be set when users 
want to do a case-sensitive match %-- in 
which a capitalized word for instance 
would not be considered a match of a 
lower-case search phrase %-- whereas the 
default setting, indicated by an 
unchecked box, would be case-insensitive).  
In these contexts there would be a 
visible contrast between 
`q.up` (or `q.unchecked`/) and 
`q.down`/`q.checked` states.

`pseudoIndent; Moreover, buttons and other `GUI; elements 
can sometimes be `q.disabled`/, meaning 
that one cannot interact with them 
according to normal patterns because 
(given present application-state) 
their associated actions would 
be impossible or illogical.  For instance, 
a button which saves a file (i.e., 
signals the application to enact that  
functionality upon being clicked) 
would not make sense if there were no 
file open.  
In that case, a disabled state and its 
style would indicate to the user 
that the button is not presently 
able to accept interactions 
(it is common to use gray 
colors to cue such states), but 
the styling of these states 
should not obscure the control's 
primary purpose when it `i.is` 
enabled.  A disabled 
`q.save` button, say, should not be 
given a style where it is 
difficult to read the `q.save` 
label (or whatever icon 
replaces it). 

`pseudoIndent; As illustrated by button-states, 
most `GUI; controls have multiple different 
visual states and their changes are intended 
to cue users on how the controls may 
be utilized interactively.  For this reason 
graphic styles have to be designed attentively, 
because each control-state should be visually 
distinguished from others, but also the 
styles should not intefere with the 
control's primary functions.  For example, a 
button's descriptive label/text (and/or 
its icon) must remain visible even while its 
background and/or outline color (or other 
style-state effects, such as a color-gradient) 
changes.  Style rules for `GUI; elements in 
general need to adopt color schemes in which 
coloring is relatively nonobtrusive 
(colors should not be overly dark or high-contrast) 
but still allows components to show a variety of 
different states.

`pseudoIndent; Many applications do not use a single 
style-scheme, but rather allow their styles to 
be adapted for different users and/or different 
platforms.  Most Operating Systems have 
preferred stylistic concepts, so that 
applications on a Mac tend to follow different 
conventions than those on Windows, or Linux.  
Consistent visual patterns from one application 
to another help users familiar with one program 
to learn how to use new software more 
quickly, so applications generally try to 
conform to Operating System standards; as such, 
cross-platform applications often employ 
multiple style schemas, depending on the 
kind of computer where the application happens 
to be running.  In addition to these 
operating-system variations, applications 
may also recognize flexible styles that can 
be adapted for different users, in case 
someone wants to view larger text, say, 
or wants to switch between different 
(human) languages for `GUI; labels. 
 
`item ->> Information Content ;;  Most 
`GUI; elements exist to show data, so 
their state is obviously influenced by the 
nature of information they seek to present 
at any given time.  In the simplest 
case, this data is in textual form, or 
is numeric data presented textually.  
For example, consider a label that 
shows the name and folder path of a file 
currently being viewed; when a new file 
is opened, the text shown on that 
label will be updated.  Here the relevant 
data is presented just through a text 
sequence.  Or, a digital map might 
have labels to represent the current 
latitude and longitude coordinates 
under the cursor.  These are numeric 
values, but can be represented for 
users merely by showing the numbers 
in character form.    
 
`pseudoIndent; Other numeric displays, however, 
might represent magnitudes more pictorially.  
Temperature, for example, may be expressed 
by coloring a bar at a height proportionate 
to degrees Farenheit or Celcius; the bar 
filled higher to the top would indicate 
higher temperatures, and lower bars 
show colder temperature.  Color could also 
reinforce these visuals, with warmer 
temperatures represented via reds and yellows 
and near-freezing conditions cued by 
blue or purple.  For some `GUI; controls, 
numeric values might be conveyed by 
visuals mimicking real-life physical 
gadgets, so the volume on an audio player 
could be shown via circular indicators 
mimicking the knobs on a stereo.

`pseudoIndent; One relevant contrast 
between numeric and textual data is that 
the latter can be long and open-ended; 
`GUI; controls designed to show paragraph-like 
text can represent content spanning many lines.  
On the other hand, numerical indicators 
typically show only one or two quantities, 
particularly if they are gadget-like displays 
(relying on bar/line-heights or angles to 
connote magnitude, rather than printed numerals).  
Multi-part numeric data would then normally 
be represented via collections of different 
controls.  Where appropriate, quantitative 
data sets could also be shown via charts or 
diagrams, either static images or 
aggregate components with multiple indepentent controls.

`pseudoIndent; Aside from textual and numeric 
data, some `GUI; controls are engineered to 
show `TwoD; images, or even interactive 
`ThreeD; graphics (in the latter case, 
users can modify `ThreeD; scenes %-- moving 
or rotating the display to show different 
angles onto the scene, which creates the 
illusion of three dimensions even though the 
graphic at any moment in time is confined 
to a `TwoD; computer screen).  Although we can speak 
of graphics displays as presenting `q.information`/, 
this is a more informal usage if a control shows, 
for example, a photograph.  However, images 
can also be generated on-the-fly to visualize 
data structures, in which case we could 
say that image-graphics (at least when showing 
tools such as charts, graphs, or diagrams) 
represent one strategy (separate from text and 
indicators) for data-visualization.  Image 
data, then, occupies a gray area where 
we can sometimes speak of controls simply 
showing users the contents of an image-file 
and sometimes instead treat image-displays 
as vehicles for presenting structured 
data analogous to other kinds of `GUI; controls.     

`pseudoIndent; To some degree this can also be 
true of text displays, when for example a 
control is intended to show contents of an 
`HTML; or `PDF; file.  The `PDF; format, in particular, 
is engineered so that each individual document-page 
becomes treated by applications as if it 
were an image or photograph (`PDF; text is 
not a data structure; pages instead are 
rendered and provided to `GUI; front-ends 
via mechanisms similar to photo-displays).  
On the other hand, `PDF; files also 
often include word-data so that 
applications can perform searches inside 
`PDF; text (although such data tends to be 
imperfect, with situations such as 
hyphenated words, ligatures, and foreign 
accents causing transcription errors; in short, 
`PDF; does not directly provide an 
accurate machine-readable transcript).  Text in 
`HTML; is similarly largely static, but users 
can select character-ranges and activate 
hyperlinks in both formats (this is true 
for any `HTML; document and most `PDF;s).  
Controls showing full text files, then, 
analogous to image-displays, are in some 
sense intermediate between organized 
information-displays which directly map 
data structures to `GUI; aggregates and 
raw file-viewers which are only 
in an indirect sense representing 
`q.information`/, but are primarily 
rendering file-contents into a static visual form. 
 
`pseudoIndent; The more canonical case 
of `GUI; controls showing structured 
data is one where `GUI; screen-areas are 
subdivided into units that represent 
individual data fields on a fine-grained 
scale.  For example, tabular data  
or `CSV; (Comma-Separated Value) files 
can be presented via spreadsheet-like 
controls, which are subdivided (by 
rows and columns) into cells that 
typically have one single numeric 
(or short textual) data.  Information shown 
in these sorts of displays may originate 
from files, insofar as such `GUI; controls 
are used to access files they need to 
load data into computational structures 
first, and then map individual parts 
of these structures onto parts of the 
`GUI; display.  The correlation between 
files and front-end controls is therefore 
granular and systematic, whereas 
image-viewers simply calculate how to render 
pictural data via on-screen pixel-areas and 
display the resulting graphs visually, 
without constructing distinct areas or 
sub-windows to show specific parts of a 
loaded file.  Text displays can be between these two 
alternatives; they are largely unstructured 
(like pictures) but portions of text may 
be isolated as if they were interactive windows 
(such as hypertext links) and users may 
select character-ranges (e.g., for copy-and-paste) 
in which case the screen-area spanning 
selected text needs to be treated as an 
interactive window in some sense.   
 
`item ->> `GUI; controls as containers for other controls ;;  
Because controls whose explicit purpose is 
to render individual data-units tend to handle 
relatively small pieces of information 
(e.g., single numeric values), multi-part 
data structures have to be displayed through 
higher-scale controls that group together 
such more narrowly-focused controls.  Partly, 
containers along these lines serve to aggregate 
smaller controls in an orderly manner; for example, a 
display of several numeric fields could be 
arranged with a single key-value pair on each 
line of a multi-line list (tables and 
spreadsheets, grouped by both rows 
`i.and` columns, are a more complex 
organizing motif).  `lGUI; containers 
do not need a fully symmetrical 
layout; often smaller controls are 
arranged in table-like patterns but 
with varying numers of elements on 
each line/row, depending on the 
amount of space each element needs.  
The important detail is that users 
can visually isolate and comprehend 
specific points of information, which is 
easier if `GUI;s are visually balanced and 
logically arranged.  Grouping 
related controls %-- and leaving 
spaces (or drawing lines) between 
different such groups %-- is 
also a useful layout convention.

`pseudoIndent; Apart from just organizing 
controls, `GUI; containers can also 
compensate for limited screen real-estate: 
`GUI; windows often have more data 
available than can be shown on-screen 
all at once.  As such, containers 
can use various tactics to 
show some contents and hide others, 
such as scroll-areas (where users 
manipulate scroll bars to alter 
which controls are visible and 
which are hidden); tab/notebook 
windows where entire (sub)windows 
are `q.stacked` or lined up so 
that only one window is visible at a 
time; dialog boxes (which are 
typically temporary displays that become 
visible to show the user specific 
information and then are closed); 
`q.wizards` (in effect, multi-page 
dialog boxes); and `q.collapsible` 
displays, whose parts can be 
toggled between visible or hidden 
states.  An canonical example 
of the latter is lists of files in 
folders, where individual folders 
may be seen in an `q.open` state 
(such that folder-contents, including 
other folders, are listed) or `q.closed`/, 
and likewise for subfolders inside 
(open) folders, and so on.  These 
kinds of controls are sometimes 
compared to an accordion, because 
as folders and subfolders  
open or close their screen-areas 
expands and contract respectively, creating a 
visual effect vaguely reminiscent 
of accordion leaves' folding patterns.   
`description`
`p`


`p.
There are several notions of `GUI; controls' 
`i.state` covered by the above 
breakdown.  Controls 
can have `i.functional` states, reflected 
in style changes, such as a button 
in `q.normal` or `q.hover` 
modes (or also, say, `q.down`/, `q.checked`/, 
and `q.disabled`/).  Most controls' 
state is also determined by the 
data they present (e.g., for 
single-value numeric indicators, 
the specific quantity 
expressed by the control at a given 
point in time).  And, for 
containers (`GUI; controls which 
group together multiple smaller controls), 
state is also characterized in 
many cases by the interplay 
of which elements are currently 
visible, and which hidden.
`p`


`p.
The forms of `GUI; state just 
enumerated refer specifically to 
controls' features that are 
visible to users, so that state-changes 
convey information.  This includes 
specific data-points which a 
control is designed to display, such as a 
numeric value; it also includes 
hints guiding the user to interoperate 
with a `GUI; most effectively.  Mouseover 
effects, for instance, communicate 
which controls can be `q.clicked` 
and which not.  There are other, more subtle 
forms of cues as well.  For example, 
when the mouse hovers over the corner of a 
resizable control (so that `q.dragging` %-- 
moving the mouse with the left button held down 
%-- adjusts the control's size by pulling the 
corner inward or outward) typically the 
cursor, that marks the current mouse position, 
will switch to a different icon (one 
drawn to imply something getting larger or smaller); 
there might be extra coloration or thickened 
lines at that corner too.  Similar patterns 
apply to other `q.drag` scenarios, such as 
moving a divider line between two parts of a 
`q.split` container, where different controls lie 
on either side of the line; moving the 
line resizes both parts of the container 
(one gets larger, the other smaller) potentially 
hiding or unhiding contained content and controls (depending 
on which side they lie on).  Another pattern is 
`q.drag and drop`/, typically involving icons being moved 
(figuratively `q.dragged` by the mouse) 
from one container to another: in some contexts 
the receiving container takes on a colored background 
to convey that it is possible to drop an 
item on its interior.  
`p`


`p.
Some visual hints are explicitly designed to inform 
users about applications' features, or the 
status of current operations.  For example, a 
mature front-end will often have `q.tool tips` for 
many controls, where hovering a mouse over the 
control causes a box of explanatory text to 
temporarily appear, explaining the purpose 
of that `GUI; element.  Tooltips serve both 
as didactic guides and as further visual 
markers that the relevant control accepts 
interactions.  Other examples of indicative 
`GUI; features include progress bars (which 
are usually visible only while an operation is 
ongoing, such as downloading a file); message 
boxes (presenting users with brief informative 
text, such as declaring that a download has 
completed); and status bars (typically single-line 
controls with text related to recent activity, 
e.g., `q.download complete`/: unlike 
a message box, which might also inform the 
users of something like a download completing, 
status bars are usually permanently visible in the 
front end).  For container-controls 
that alternately show and hide inner contents, 
visual cues sometimes clarify what material 
is currently visible: e.g., a `q.notebook` 
container, which has multiple tabs each 
showing a different window, will color and 
outline the tab corresponding to the 
currently open window with a different 
(more emphasized) style than the other tabs 
(whose windows are invisible at present).
Details can also be conveyed by 
discreet changes to textual data: for example, if a 
file has been modified and not yet saved, 
a label or status bar showing the file name 
will often append a small marker, such as an 
asterisk, to the file name, reminding users 
that they may need to save the file.     
`p`


`p.
Style conventions also inform how `GUI;s help 
users track the current mouse position.  
In general, the mouse is tracked with a cursor, 
which moves across the screen when users 
move the mouse (or run their fingers against a 
touchpad); a mouse click (or tap against a 
touchpad) is understood by the application 
to signal the user's intent to execute a 
`q.click` gesture at the screen position 
where the cursor currently hovers.  The cursor 
will then take on different icons depending 
on how the click would be processed, given 
the control under the mouse position (an 
example mentioned above would be 
a `q.resize` icon when the mouse hovers 
over a corner; this works also for 
some controls' edges); cursors tend to be 
given an arrow-like icon in these settings.  
When hovering overm on the 
other hand, cursors usually take on a shape 
remininiscent of a capital letter `q.I`/.  

`pseudoIndent; In some cases the 
on-screen mouse position can be correlated with 
some physical or empirical coordinate 
system %-- a good example is digital 
maps, where positions inside the map correpond 
to latitude and longitude numbers.  
Here it is common to print the geographic 
coordinates next to a corner of the map, 
so that the numbers change as users 
move the mouse around the map-view, which 
both aids users if they are trying to find a 
specific latitude/longitude pair and 
helps visually reinforce the idea that 
mouse-positions map directly to geospatial 
points.  A similar pattern in one dimension 
would be using a mouse to advance or rewind 
an audio or video player, wherein a numeric 
control shows the time ellapsed at different 
points relative to the file's start (the 
convention being to pair audio/video 
controls with a line-bar and position 
indicator such that moving the indicator 
right/left implies forward/backward in time, 
respectively).  Finally, some controls 
display graphics or data charts/diagrams 
against a background of orthogonal gridlines 
(similar to `q.graph paper` used for 
drawings), or sometimes just the 
lattice-points at gridline intersections.  
In these contexts mouse position may be 
indicated by highlighting the gridlines 
which a mouse passes over as it moves. 
`p`


`p.
One takeaway from this overview is that 
well-engineered `GUI;s are highly 
interactive; there are many conventions 
which govern how front-ends should 
present subtle visual cues and state-changes 
to assist users when interacting 
with the application.  Users may not 
appreciate the full scope of these effects, 
becoming habituated to `q.responsive` 
features and perhaps absorbing them at 
only a subconscious level; however, 
front-ends which fail to implement 
expected interactive patterns, where 
`GUI;s are not sufficiently responsive 
in terms of giving users frequent feedback 
on current state (such as mouse position)
and interactive possibilies, would 
almost certianly be experienced by 
users as erratic and confusing.  
Most of the front-end patterns 
mentioned here are probably familiar 
to people who work on 
desktop-style computers, but it is 
nonetheless useful to outline 
them explicitly, precisely because 
well-engineered responsiveness 
effects will be subtle and non-distacting.  
When we appreciate the full scope 
of interactive patterns, we can 
perceive the complexity of standard 
`GUI; programming: a well-featured 
front-end application will typically 
have a large collection of 
associations and interconnections 
between `GUI; controls, and mappings 
between control-state and 
visual styles/interactive cues.  
Systematically engineered application 
will carefully document these 
interconnections and implement 
the associated front-end functionality 
via a consistent set of coding patterns.  
`p`


`p.
As dicussed in this chapter (and also 
touched on at the start of Chapter 20), 
application functionality can be 
analyzed in terms of operations 
and procedure-sequences that are, 
in effect, bookended by user 
actions (which invite responses from 
the appliction) and by visible 
`GUI; changes (changes in the 
state of one or more controls, 
communicating to users the 
results of the actions they 
requested).  Reviewing forms of 
`GUI; state serves to explicate 
the second half of this equation.
We can also examine user gestures, 
constituting the first half 
of the `q.equation`/, insofar as 
gestures signal user intent, which 
leads to application responses, 
and finally to `GUI; changes.  
Gestures are, indeed, closely connected 
to `GUI; state, because a user's 
actual (literal and physical) action,
such as pressing a mouse button, 
needs to be interpreted in light 
of current `GUI; state to be 
seen as an `q.action` in the `q.virtual` 
context of a front-end display.  
We speak, for example, of `q.clicking` 
a `GUI; control; in reality, the 
`q.click` happens on the physical 
mouse, but the presence of cursors and 
mouse-tracking permits this 
physical movement to be read as an 
interactive gesture within the 
scope of a software component.  In this 
sense the `q.semantics` of user 
actions builds off of `GUI; state 
analogously to the semantics of 
`GUI; visuals conveying information, 
so that the two may be analyzed together. 
`p`


`subsection.The semantics of GUI-control state`
`p.
To briefly clarify terminology: a user `i.gesture` 
refers to some physical action which 
is `i.interpreted` as a specific kind 
of request, input, or instruction.  The 
gesture is interpreted as an `i.action`/, 
in the sense that gestures signal actions 
according to patterns which reappear 
in the logistics of how people interact 
with software (patterns that users 
recognize).  As a canonical example, 
the physical gesture of tapping a mouse 
button is interpreted as the contextual 
action of `q.clicking` a `GUI; button 
or other `GUI; control.  The relation of 
gestures to actions can perhaps be 
compared to that between audible words 
and their intended lexemes. 
`p`


`p.
Mapping gestures to actions depends on 
`GUI; state, such as the current mouse-position.  
Accordingly, `GUI; state overall provides the 
structures against which individual 
actions are defined: an action of 
`i.clicking a` (`GUI;) `i.button`/, for example, 
is meaningful in the context of a front-end 
environment where the specific button is among 
many controls that could be `q.clicked`/, and 
given that it is enabled and visible, etc.
`p`


`p.
Some `GUI; coding contexts will refer to `q.actions` as 
akin to `q.requests` that may be cued by 
more than one user gesture.  For example, instructions 
to save a file could derive from clicking a `q.save` 
button, but also selecting a save option from 
a context menu, or hitting a combination on the 
keyboard, such as `q.control`/-plus-`q.s`/.  For more rigorous 
discussion, I suggest referring to actions in this 
multi-indication context as `q.requests`/, so that 
the various gestures signaling one common 
request (like `q.save file`/) each have distinct 
actions.  In any case, all actions then 
get routed to interpretations of 
users' intentions; we can use the term 
`q.requests` to designate these interpretations in general, 
so that some requests are cued by one single 
action and some are targets of more than 
one possible action.  Current `GUI; state 
determines both how `i.gestures` are 
interpreted as `i.actions`/, and how `i.actions` 
are interpreted as `i.requests`/.     
`p`


`p.
By design, applications are engineered to 
`i.respond` to such requests, and `GUI; state 
(alongside application state overall) contributes 
to how software models the request to be 
handled.  Consider a notebook control 
that contains multiple windows, each displaying an 
editable text-doment: when the user requests a 
save, the application would infer `i.which` 
file should be saved based on which 
document's window is currently visible.  
This is an example of `GUI;-specific state.  
Whether or not the document has been 
modified (affecting whether a save is necessary), 
and the file path that would be overwritten, 
would be an example of application-state 
proper (because these details are not determined 
by the visible appearance of `GUI; elements; 
although the `GUI; can convey to 
users such information as whether the 
currently viewed document is modified). 
`p`


`p.
Some user requests may be handled in different 
ways depending on specific properties of 
application state or the surrounding computer 
environment.  Consider a request to save a 
file: if the file already exists, saving the 
updated version involves replacing the 
contents on disk; in some cases, the current 
user is not authorized to make such a change, 
so the save action (with the current file 
name) cannot be completed.  On the other hand, 
if this is a `i.new` file, the user needs 
to assign it a name.  There are, then, at 
least three possibilities: the file can 
be overwritten with its current name; the 
file cannot be saved with its current 
name but may be saved with a new name, 
so that there will be two different versions 
on disk; and the file cannot be saved 
until a name is provided, which will then
be one single version of the file.  How the 
application fulfills the user's request 
will different in each of these scenarios.  
Some of these differences might be noticed 
by users: if the file needs a new 
name, users will generally be shown a 
`q.save as` dialog configured for 
choosing file/folder names, whereas if a 
file is overwriting a prior version users 
might see a message box confirming that they 
intend to do so (maybe with an option 
to make a backup of the older 
file).   
`p`


`p.
The point of this example is that responding 
to user requests demands a rigorous calibration of 
`GUI; and application state.  This is one 
reason why Object-Oriented methods 
predominate in front-end programming; the 
logic of such state-correlations is 
typically simpler to reason through via 
`OO; paradigms than alternatives.  Indeed, `GUI; 
controls are best encapsulated as objects-with-state, 
and because `GUI; controls are functionally 
interconnected with many other application 
elements, similar `OO; concepts tend to be 
most effective on the application side as 
well.  For example, if a notebook window 
shows one document, the window itself 
corresponds to one `GUI; object, 
from the front-end point of view; on the 
application side, the actual document 
visible `i.in` the window might be a 
different object, encompassing data fields 
such as file path, file type, length, 
edit history, and permissions (e.g., the identity of the 
user who created the file).`footnote.
Sometimes deciding whether to qualify 
state as `GUI; or application-level can be a 
gray area: consider undo/redo history.  
Should user actions that can be 
reversed be tracked at the `GUI; level, 
becauese these actions are signaled 
by `GUI; actions, or within the application 
logic, because requests are managed by 
application code?  This question determined 
whether undo/redo history should be 
categorized as part of `GUI; or application state. 
`footnote`  User requests relative to the 
`iGUI; object would be carried 
out, by the application, in the context 
of the corresponding application object.  
These functional interconnections are 
best managed by mainting association 
between application and front-end 
objects (which implies an overall `OO; 
system unifying these two contexts).
`p`

`subsubsection.Extending Object Orientation`
`p.
One might argue, however, that there 
are details in application/`GUI; object 
systems that are inadequately addressed 
even by conventional `OO; models, 
and call for extensions to the 
`OO; framework (which is a different 
matter than replacing such a framework 
with something like `FP; methods 
oriented to stateless values). 
`p`


`p.
Here is one example: in some contexts a front-end 
display will include two (or more) `GUI; controls 
that are styled and positioned so that the user 
views them as an integral unit.  A simple case 
is a button which has both an icon and 
a descriptive text label; this arrangement 
can be implemented with a label control 
placed next to a button control, but configured 
so that the label appears to be a logical 
continuation of the button itself.  In this setup, 
some facets of `GUI; state should be 
shared between the two controls as if they 
were one single element.  For example, if 
the button is disabled (causing it to adopt a new style), 
the label should be restyled as well.  Or, consider 
tooltips, as mentioned earlier %-- explanatory 
text that temporarily appears near controls 
when the mouse hovers over them.  If users are 
to experience a button and a label as functionally 
integrated, this pattern is reinforced by them 
sharing a tooltip, which means that the same 
tooltip content should be applied to both 
controls. 
`p`


`p.
Consider a procedure to define this tooltip text.  
Ideally the same procedure would act to 
both objects, because we want to reinforce in 
code the idea that two controls share some 
state-details, including their tooltips 
(we do not want this correlation to be 
dependent on two different procedure-calls, 
partly because programmers may forget one 
of them and partly to remind those 
maintaining the code that the two objects 
are interdependent).  In `OO; systems, 
the basic pattern is that procedures 
which affect the state of a specific 
object are implemented via `q.methods`/, 
in which a specific object is singled 
out as a distinct form of input 
value, sometimes called the method `q.receiver` 
(in languages such as `Cpp;, `Csharp;, and 
`Java;, `q.receiver` values are 
designated with the special keyword `b.this`/; 
elsewhere the most popular name is `b.self`/).  
The problem with this convention 
in a context where procedures are intended 
to synchronize state between `i.two` objects 
is that it seems artifical to choose one or another 
as `q.the` receiver %-- a more fluent 
paradigm would be to allow `i.two` 
receivers (or more), in the same way that 
procedures can have two or more normal 
input arguments.
`p`

`p.
In Chapter 21 I mentioned 
the idea of grouping procedural parameters 
into `q.channels`/, including a `q.sigma` 
channel that can generalize receiver-objects 
to object-lists (derived from the `q.sigma calculus`/, 
which attempts to model `OO; methods by 
extending lambda calculii).  This would be 
one way to tweak `OO; systems %-- permitting 
multiple receivers.  There is no technical 
reason why programming languages could not 
support more than one `b.this` value; by 
analogy, most languages only recognize a 
single procedure `i.return` value, but 
there are outliers (e.g., Common Lisp), 
and generalizing returns to 
multi-value lists does not present 
special syntactic or implementational 
difficulties in those contexts.`footnote.
Disambiguating methods called on `q.multiple 
receivers` may prove more complicated 
when two `textbf.this` objects are of different types 
%-- which class should be searched for 
corresponding methods? %-- but compilers 
could adopt similar rules to those used 
when matching procedure-names to functions 
wherein argument lists have multiple types.    
`footnote`  By way of reference, 
the code accompanying this 
chapter includes some functionality 
which emulates `q.sigma channels` in 
ordinary (albeit unconventional) `Cpp;.
`p`


`p.
Apart from multiple method-receivers, a 
more substantial potential departure 
from conventional `OO; suggested by 
`GUI; state involves user actions and 
corresponding `q.signals`/.  A common 
pattern in `GUI; programming is to 
generalize the idea of procedures 
calling one another to a model 
wherein procedures can post and/or 
respond to signals; such a system 
is usually referred to as a `i.signal/slot` 
mechanisms, where signals can be `q.connected` 
to slots.  Rather than one procedure 
calling another directly, in this architecture 
the first procedure `q.emits` a signal, 
which the second then `q.receives`/, having the 
effect that the second procedure gets called, 
with parameters (if any) provided by the 
`q.sender`/.  Unlike direct inter-procedure 
calls, these connections are 
routed through an intemediary component 
and they might be dynamically reconfigured: 
signal/slot connections can be newly created 
or dropped while an application is running.  
When a procedure emits a signal, there is 
no guarantee that any other procedure 
will implement a `q.slot` that receives 
it; but also `i.multiple` procedures 
might connect to the original slot).  
Compared to direct inter-procedure 
calls, the two (or more) procedures 
involved are thereby less tightly connected.  
`p`


`p.
Programming environments that employ 
signal/slot connections often use this 
technique to handle responses to user 
gestures.  After a user clicks a (`GUI;) button, 
for example, an object representing that 
button broadcasts a `q.click` signal, which in turn 
is handled by procedures to initiate 
the application response.  For example, if 
the button in question represents requests 
to save a file, there will be some 
procedure whose purpose is to 
wait for `q.save` signals and then initiate 
the application-level process of actually 
saving the relevant file.  The slot thereby 
connected to the `q.save` signal only 
is responsible for initiating save operations; 
it does not consider where the save button 
is located on screen, or its `GUI; state 
and state changes (mouseovers, tooltips, etc.).  
On the other hand, the button-object 
would track these `GUI;-specific details 
but not get involved with actual save 
operations.  Signal/slot mechanisms 
are as such (as this case-study suggests) valuable 
tools for enforcing `q.separation of concerns`/, 
where each procedure and each object have 
a relatively narrow set of responsibilities.  
Signals and slots prevent objects from becoming 
tightly coupled, because signalling objects 
can be designed in isolation from procedures 
that receive (and act on) their signals. 
`p`


`p.
Although a powerful pattern that fits organically 
within `OO; paradigms, signals and slots are 
not directly supported by the `OO; model, 
and few programming languages have intrinsic 
signal/slot features.  In `Cpp;, several 
libraries emulate the signal/slot patten. 
The `Qt; framework, which is both a `GUI; 
library and a general-purpose technology 
for application development, supports a 
coding style wherein signals and slot 
function essentially as native language 
features %-- however, this is only possible 
because `Qt; implements an extended 
compiler workflow involving pre-compilation 
parsers and code-generators, in effect 
implementing an extension to the 
`Cpp; language itself.
`p`


`p.
Because most `OO; languages do not 
intrinsically support signal/slot 
connections %-- that is, they 
cannot be expressed directly 
through the language's syntax and 
semantics, but rather have to be 
approximated by code libaries 
(potentially including language 
extensions through code generators) 
%-- this patterns is for all intents 
and purposes an extension to 
`OO; which is not part of the 
basic `OO; model.
`p`


`p.
One further detail concerning signal/slot 
systems involves properly aligning multiple 
parameters of `GUI; state which should 
adhere to certain design regularities; for 
example, different lengths or magnitude 
in the front-display preserved in a 
constant ratio.  Consider a scroll area 
showing an image: if the image's size 
(at its current zoom level) exceeds the dimensions 
of the scroll area, then the visible part of the 
image is `q.clipped` and users can scroll left/right 
and top/down to alter this visible area.  On the 
other hand, if the image-size is `i.less` than the 
scroll area, it is conventional to center 
the image so that left and right margins, 
and likewise the top and bottom, are balanced.  
If the image is resized (by zooming in or out) 
its top-right coordinate therefore should be 
recalculated.  Similarly, if the scroll area's viewport  
is resized because the user 
expands or contracts its surrounding window, 
the image itself would either have to be 
resized proportionately, or else moved to  
a different top-left position, to preserve 
the margin's desired left/right and top/bottom 
symmetry.  In this example, there are 
several different numbers that need to be 
tracked in coordination: the overall window's 
size; the width and height of the scroll area's 
viewport (its visible screen-area); and 
the image's position, dimensions, and zoom factor.  
Changes to any one of these measures may 
need to trigger changes in some or all of 
the others, to ensure that the `GUI; 
continues to feel visually balanced.  
`p`


`p.
Because multiple quantities are involved, 
orchestrating the proper symmetry in 
this example can require coordinating 
multiple signal/slot connections.  For 
example, an object representing 
the main window might emit a signal when 
it expands or contracts.  Most 
`GUI; systems employ `q.layout managers` 
which calculate how controls should be 
oriented relative to application windows, 
so that front-ends can have a roughly 
tabular, gridlike, or top-down organized 
layout, with controls that need a 
fixed amount of space (such as labels 
whose text does not change) remaining 
constant while others gain or lose space 
in sync with available screen-area 
(scrollable containers, for example, can 
be downsized because users expect to 
scroll around their interior anyhow).  
Layout managers will therefore 
tend to automatically resize certain 
controls, which can potentially trigger 
new signals: a screen area resizes 
because its surrounding window does, 
and both end up producing signals 
broadcasting their new state.  
Code responsible for the image display 
accrodingly should keep track of 
either or both signals and modify 
the image's own size and/or on-screen 
placement accordingly.   
`p`


`p.
Quantitative changes such as window-size 
may also trigger other kinds of 
`GUI; state-changes.  For example, 
if an image is `i.smaller` than its 
scrollable viewport then scrolling 
per se is not possible; this situation 
is typically cued via scrollbars 
being visible but grayed 
out (users perceiving the scrollbars, 
even if they are disabled, reinforces 
that they `i.will` become active when necessary).  
Then, given either the image zooming in 
or the viewport shrinking, once internal 
scrolling becomes necessary the 
scrollbars should be enabled, 
taking on a new visible appearance.  
Resizing and zooming may therefore both 
affect the scrollbars' styling.
`p`

`p.  
For a related example, when an image 
is `i.first` opened many picture-viewers 
resize the main window so that the image 
can be seen, in its entirety, in its 
native size.  At this point,  
the scroll area and main window 
dimensions would be calculated on the 
basis of the image; the user 
can then resize the window if desired.  
However, `i.after` the image is loaded, 
ordinarily the user is free to expand or 
contract the window irrespective of the 
image size (scrolling being avaible 
to compensate for when the window get 
too small to show 
the whole image).  There are, accordingly, 
two different scenarios for how the 
relation between window-size (and by 
extension a scroll area's viewport-size) 
and image dimensions should be calculated.  
Application code needs to keep track 
of `GUI; `q.history` to properly separate 
these different contexts.  For example, 
if the main window is resized 
immediately after (and because of) a new 
image-file being opened, the window's 
resize-signal should be processed 
differently than a similar signal 
emitted due to users manually 
adjusting the window (typically 
by pulling at one corner or by 
clicking maximize/unmaximize buttons). 
`p`


`p.
The point of these examples is that 
signal/slot connections often do not 
occur in isolation, but must be 
coordinated to maintain desired 
style and layout conventions in the 
front-end.  Often these involve 
groups of interrelated parameters 
reflecting states from multiple 
different `GUI; controls.  `lGUI; 
state can be guided by sets of 
`q.rules`/, such as that an 
image top-left corner must be 
positioned and repositioned to ensure 
balanced margins, or that scrollbars 
should be visible but disabled when 
image-size is `i.less` than the 
available viewport area, but automatically 
enabled when the former expands to beyond 
the viewport dimensions.   
`p`


`p.
In the image-view 
case there are at least four quantities 
or coordinate-pairs which are 
numerically interdependent: the image 
width/height; its top-left corner 
position; the viewport dimensions; and 
the image zoom.  Most programming languages do not have an intrinsic 
feature for sustaining predefined mathematical 
relations amongst two or more independent 
variables along these lines %-- there 
is no way in code to declare 
interrelated variables such that changes to any 
one (or more) value will automatically 
propagate to the others.  The closest 
approximation might be to group 
all these values into one 
data structure, and then make any 
changes to specific parameters via 
procedures specific to that structure, 
which can be engineered to update the 
other fields as needed.  
In that case, attributes such as an 
image's size would not be magnitudes 
(or pairs thereof) directly, but would 
instead be handles onto specific parameters 
held within the coordinated data structure 
(one added complication is that while that 
structure's fields are interrelated 
in the sense of demanding specific mathematical 
invariants, they are also properties 
of different contols' states, so they 
need to be properly classified `visavis; 
the control they are associated with).
`p`

`p.  
Orchestrating these sorts of interrelationships 
among multiple objects and 
data-fields is a common problem but without a 
canonical design pattern, in particular 
in the `OO; context (this is one 
areas where Functional Programming has
produced somewhat more concise 
formulation, that `OO; could perhaps 
borrow).  Therefore, another kind of 
potential `OO; extension relevant 
to `GUI; state would be supporting 
groups of interrelated parameters, 
distributed across multiple objects 
but bound by stipulated invariance requirements.  
Such features would overlap with signal/slot 
systems because signal/slot connections 
are sometimes defined specifically 
to ensure proper inter-parameter 
relationships (by receiving signals 
notifying change in one interlinked 
value and then updating the others 
proportionately).
`p`


`p. 
From a practical point of view, 
these examples point to `OO; 
extensions that could potentially 
be incorporated into new language 
standards.  More theoretically, 
we can also study how such extensions 
add representational features 
to `OO; models, enhancing the `OO; 
repertoire for capturing the 
state and interrelationships 
of complex systems.  The `q.theory` 
in this case could provide a further 
perspective on `OO; `q.semantics` 
in the sense that Object-Oriented 
principles can inform data models, 
`q.knowledge system`/, and other 
technologies that are designed 
to have some explicit connection 
with real-world objects and 
phenomena.  More direct applications 
of an expanded `OO; `q.theory` 
might also lie with tools such as 
code-analyzers, software-development 
tools, and compiler extensions, collectively 
serving to accelerate the 
implementation and quality of `GUI; front-ends. 
`p`


`p.
Front-ends discussed here thus far 
have implicitly been focused on 
two-dimensional text and graphics, 
either viewers of `TwoD; images 
or layouts presenting structured 
information, via text, printed numbers, 
or magnitude-indicators.  In 
contexts such as robotics, 
`GUI;s also often work with `ThreeD; 
graphics, videos, and other 
multimedia assets which have 
properties and present complications 
different in kind from the 
more `TwoD; contexts and issue 
raised to this point.  Partly 
so as to circle back to the 
theme of robot environments, 
these multimedia concerns will 
be the topic of the rest of this section.  
`p`


`subsection.Multimedia Front-Ends`
`p.

`p`


